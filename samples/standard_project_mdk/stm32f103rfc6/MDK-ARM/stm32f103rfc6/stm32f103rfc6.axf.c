/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn _main();
int _scatterload_rt2_thumb_only();
int __fastcall _scatterload_null(int a1);
int *__fastcall _scatterload_copy(int *result, int *a2, unsigned int a3);
void __fastcall _scatterload_zeroinit(int a1, _DWORD *a2, unsigned int a3);
int _rt_lib_init();
int __fastcall _rt_lib_init_preinit_1(int a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall _rt_lib_init_user_alloc_1(_DWORD); // weak
void __noreturn _rt_entry_sh();
void __fastcall __noreturn _rt_entry_postsh_1(int a1, int a2);
int __cdecl _rt_entry_postli_1(int argc, const char **argv, const char **envp);
int __fastcall _rt_exit(_DWORD); // weak
void __noreturn _rt_exit_exit();
void Reset_Handler(); // idb
void *_user_initial_stackheap();
int __fastcall calloc(unsigned int a1, unsigned int a2);
int __fastcall malloc(unsigned int a1);
_DWORD *__fastcall free(int a1);
int __fastcall ll_udiv(unsigned __int64 a1, unsigned __int64 a2);
char *__fastcall strlen(char *a1);
int *__fastcall _rt_memcpy(_BYTE *a1, char *a2, unsigned int a3, int a4);
_BYTE *__fastcall memcpy_lastbytes(_BYTE *result, char *a2, int a3, char a4);
int *__fastcall _rt_memcpy_w(int *result, int *a2, unsigned int a3);
_WORD *__fastcall memcpy_lastbytes_aligned(_WORD *result, __int16 *a2, int a3, __int16 a4);
void __fastcall __spoils<R1,R2,R3,R12> memset(int a1, int a2, int c);
int __fastcall _rt_memclr(_DWORD, _DWORD); // weak
void *memset(void *s, int c, size_t n);
int __fastcall _rt_memclr_w(_DWORD, _DWORD); // weak
_DWORD *__fastcall memset_w(_DWORD *result, unsigned int a2, int a3);
void *_rt_heap_descriptor();
int _Heap_Full();
int _Heap_Broken();
_DWORD *__fastcall init_alloc(int a1, unsigned int a2, int a3, int a4);
_DWORD *__fastcall _Heap_Initialize(_DWORD *result);
int _Heap_DescSize();
void *_user_perthread_libspace();
_DWORD *__fastcall _Heap_ProvideMemory(_DWORD *a1, _DWORD *a2, int a3);
int __fastcall _rt_SIGRTMEM(int a1);
void *_user_setup_stackheap();
void __fastcall __noreturn exit(int a1);
int __fastcall _sig_exit(int error_code);
int __fastcall _rt_SIGRTMEM_inner(int a1);
int sys_exit(int error_code);
int __fastcall _default_signal_display(_BYTE *a1, _BYTE *a2);
int ttywrch();
crc32_t __fastcall _Ven_TT_L__advance_software_protect_crc32(uint8_t *buffer, size_t size, int a3, uint32_t a4);
void __fastcall _Ven_TT_L__advance_software_protect_encrypt_process(void *data, size_t size, uint64_t key, int isEnc);
void _Ven_TT_L__advance_software_protect_system_reset();
bool _Ven_TT_L__advance_software_protect_verify_authorization();
int _Ven_TT_L__advance_software_protect_flash_verify();
void __fastcall _Ven_TT_L__advance_software_protect_anti_debugger(AntiDebuggerCallback eventCallback);
int __fastcall FLASH_OB_DisableWRP(uint32_t WriteProtectPage);
int __fastcall FLASH_OB_EnableWRP(uint32_t WriteProtectPage);
uint32_t FLASH_OB_GetRDP(); // idb
HAL_StatusTypeDef __fastcall FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel);
void FLASH_SetErrorCode(); // idb
HAL_StatusTypeDef __fastcall FLASH_WaitForLastOperation(uint32_t Timeout);
uint32_t __fastcall HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength);
uint32_t __fastcall HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength);
HAL_StatusTypeDef __fastcall HAL_CRC_Init(CRC_HandleTypeDef *hcrc);
void __fastcall HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc);
int HAL_FLASHEx_OBErase();
void __fastcall HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
HAL_StatusTypeDef __fastcall HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
int HAL_FLASH_Lock();
int HAL_FLASH_OB_Lock();
int HAL_FLASH_OB_Unlock();
int HAL_FLASH_Unlock();
void __fastcall HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init);
void __fastcall HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
uint32_t HAL_GetTick(); // idb
void HAL_IncTick(); // idb
int HAL_Init();
HAL_StatusTypeDef __fastcall HAL_InitTick(uint32_t TickPriority);
void HAL_MspInit(); // idb
void __fastcall HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
void __fastcall HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
void SystemInit(); // idb
void advance_software_protect_anti_debugger_sample(E_AntiDebuggerEvent_0 event); // idb
void advance_software_protect_dynamic_muti_object_watcher_callback(E_ObjectWatchException_0 excep, void *param); // idb
HAL_StatusTypeDef __fastcall HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency);
uint32_t HAL_RCC_GetPCLK1Freq(); // idb
uint32_t HAL_RCC_GetPCLK2Freq(); // idb
uint32_t HAL_RCC_GetSysClockFreq(); // idb
HAL_StatusTypeDef __fastcall HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct);
uint32_t __fastcall HAL_SYSTICK_Config(uint32_t TicksNumb);
HAL_StatusTypeDef __fastcall HAL_UART_Init(UART_HandleTypeDef *huart);
void __fastcall HAL_UART_MspInit(UART_HandleTypeDef *huart);
void SystemClock_Config(); // idb
void __fastcall UART_SetConfig(UART_HandleTypeDef *huart);
void __fastcall _NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority);
bool __fastcall _advance_software_protect_objectwatch_check(void *object_ptr, size_t info_in_object);
void __fastcall _advance_software_protect_objectwatch_update(void *object_ptr, size_t info_in_object);
void __fastcall advance_software_protect_ramcode_data_process(uint8_t *buffer, size_t size, uint64_t a3, uint64_t key);
void __fastcall add32(uint32_t *dst, uint32_t src, char *carry);
void __fastcall add64(mbedtls_mpi_uint *dst, mbedtls_mpi_uint *src, mbedtls_mpi_uint *carry);
void advance_software_protect_dynamic_muti_object_watcher(); // idb
bool advance_software_protect_flash_verify_check(); // idb
int advance_software_protect_flash_verify_init();
bool __fastcall advance_software_protect_objectwatch_list_add(void *object_ptr, size_t object_size, bool del_object_when_remove);
bool __fastcall advance_software_protect_objectwatch_list_check(void *object_ptr);
int __fastcall advance_software_protect_objectwatch_list_check_all(int a1, int a2, int a3, uint32_t a4);
bool __fastcall advance_software_protect_objectwatch_list_find(void *object_ptr);
bool __fastcall advance_software_protect_objectwatch_list_remove(void *object_ptr);
void advance_software_protect_objectwatch_list_reset(); // idb
void __fastcall advance_software_protect_objectwatch_list_set_callback(ObjectWatcherCallback callback);
void __fastcall advance_software_protect_objectwatch_list_sigslot(E_ObjectWatchException_0 type, void *param);
size_t advance_software_protect_objectwatch_list_size(); // idb
bool __fastcall advance_software_protect_objectwatch_list_update(void *object_ptr);
void __fastcall advance_software_protect_objectwatch_list_update_all(int a1, int a2, int a3, uint32_t a4);
void __fastcall advance_software_protect_ramcode_loader(RamcodeLoaderCallback callback);
void __fastcall advance_software_protect_ramcode_sample(E_RAMCODE_EVENT_0 event);
void advance_software_protect_rights(); // idb
void advance_software_protect_samples(); // idb
void advance_software_protect_single_object_watcher(); // idb
void __fastcall carry64(mbedtls_mpi_uint *dst, mbedtls_mpi_uint *carry);
uint32_t __fastcall crc32(const void *data, int nBytes);
uint32_t __fastcall crc32_continue(uint32_t prev_crc, const void *data, int nBytes);
int __fastcall derive_mpi(const mbedtls_ecp_group_0 *grp, mbedtls_mpi_0 *x, const unsigned __int8 *buf, size_t blen);
int ecdsa_verify_restartable(mbedtls_ecp_group_0 *grp, const unsigned __int8 *buf, size_t blen, const mbedtls_ecp_point_0 *Q, const mbedtls_mpi_0 *r, const mbedtls_mpi_0 *s, mbedtls_ecdsa_restart_ctx *rs_ctx); // idb
void __fastcall ecp_comb_recode_core(unsigned __int8 *x, size_t d, unsigned __int8 w, const mbedtls_mpi_0 *m);
void __fastcall mbedtls_ecdsa_init(mbedtls_ecdsa_context *ctx);
void __fastcall mbedtls_mpi_zeroize(mbedtls_mpi_uint *v, size_t n);
int __fastcall ecp_mod_p192k1(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p224k1(mbedtls_mpi_0 *N);
void __fastcall ecp_mpi_load(mbedtls_mpi_0 *X, const mbedtls_mpi_uint *p, size_t len);
int __fastcall ecp_add_mixed(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *P, const mbedtls_ecp_point_0 *Q);
int __fastcall ecp_check_pubkey_sw(const mbedtls_ecp_group_0 *grp, const mbedtls_ecp_point_0 *pt);
int ecp_comb_recode_scalar(const mbedtls_ecp_group_0 *grp, const mbedtls_mpi_0 *m, unsigned __int8 *k, size_t d, unsigned __int8 w, unsigned __int8 *parity_trick); // idb
int ecp_double_add_mxz(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, mbedtls_ecp_point_0 *S, const mbedtls_ecp_point_0 *P, const mbedtls_ecp_point_0 *Q, const mbedtls_mpi_0 *d); // idb
int __fastcall ecp_double_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *P);
int ecp_group_load(mbedtls_ecp_group_0 *grp, const mbedtls_mpi_uint *p, size_t plen, const mbedtls_mpi_uint *a, size_t alen, const mbedtls_mpi_uint *b, size_t blen, const mbedtls_mpi_uint *gx, size_t gxlen, const mbedtls_mpi_uint *gy, size_t gylen, const mbedtls_mpi_uint *n, size_t nlen); // idb
int ecp_mod_koblitz(mbedtls_mpi_0 *N, mbedtls_mpi_uint *Rp, size_t p_limbs, size_t adjust, size_t shift, mbedtls_mpi_uint mask); // idb
int __fastcall ecp_mod_p192(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p224(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p255(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p256(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p256k1(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p384(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p448(mbedtls_mpi_0 *N);
int __fastcall ecp_mod_p521(mbedtls_mpi_0 *N);
int __fastcall ecp_modp(mbedtls_mpi_0 *N, const mbedtls_ecp_group_0 *grp);
int ecp_mul_comb(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng, mbedtls_ecp_restart_ctx *rs_ctx); // idb
int __fastcall ecp_mul_comb_core(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *T, unsigned int T_size, const unsigned __int8 *x, size_t d, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng, mbedtls_ecp_restart_ctx *rs_ctx);
int ecp_mul_mxz(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng); // idb
int __fastcall ecp_normalize_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *pt);
int __fastcall ecp_normalize_jac_many(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 **T, size_t T_size);
int __fastcall ecp_precompute_comb(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *T, const mbedtls_ecp_point_0 *P, int w, size_t d, mbedtls_ecp_restart_ctx *rs_ctx);
int __fastcall ecp_randomize_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *pt, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng);
int __fastcall ecp_randomize_mxz(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng);
int __fastcall ecp_safe_invert_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *Q, unsigned __int8 inv);
int __fastcall ecp_select_comb(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *T, unsigned int T_size, unsigned int i);
int __fastcall ecp_use_curve25519(mbedtls_ecp_group_0 *grp);
int __fastcall ecp_use_curve448(mbedtls_ecp_group_0 *grp);
int __fastcall encrypt_g(uint16_t g, uint8_t k, uint8_t *key);
int __fastcall encrypt_g_inv(uint16_t g, uint8_t k, uint8_t *key);
uint16_t __fastcall encrypt_sub_g(uint8_t g, uint8_t k, uint8_t *key);
int __fastcall fix_negative(mbedtls_mpi_0 *N, int c, mbedtls_mpi_0 *C, size_t bits);
int __cdecl main(int argc, const char **argv, const char **envp);
int __fastcall mbedtls_asn1_get_len(unsigned __int8 **p, const unsigned __int8 *end, size_t *len);
int __fastcall mbedtls_asn1_get_mpi(unsigned __int8 **p, const unsigned __int8 *end, mbedtls_mpi_0 *X);
int __fastcall mbedtls_asn1_get_tag(unsigned __int8 **p, const unsigned __int8 *end, size_t *len, int tag);
void __fastcall mbedtls_ecdsa_free(mbedtls_ecdsa_context *ctx);
int mbedtls_ecdsa_read_signature(mbedtls_ecdsa_context *ctx, const unsigned __int8 *hash, size_t hlen, const unsigned __int8 *sig, size_t slen); // idb
int mbedtls_ecdsa_read_signature_restartable(mbedtls_ecdsa_context *ctx, const unsigned __int8 *hash, size_t hlen, const unsigned __int8 *sig, size_t slen, mbedtls_ecdsa_restart_ctx *rs_ctx); // idb
int __fastcall mbedtls_ecp_check_privkey(const mbedtls_ecp_group_0 *grp, const mbedtls_mpi_0 *d);
int __fastcall mbedtls_ecp_check_pubkey(const mbedtls_ecp_group_0 *grp, const mbedtls_ecp_point_0 *pt);
int __fastcall mbedtls_ecp_copy(mbedtls_ecp_point_0 *P, const mbedtls_ecp_point_0 *Q);
const mbedtls_ecp_curve_info_0 *__fastcall mbedtls_ecp_curve_info_from_tls_id(uint16_t tls_id);
mbedtls_ecp_curve_type __fastcall mbedtls_ecp_get_type(const mbedtls_ecp_group_0 *grp);
void __fastcall mbedtls_ecp_group_free(mbedtls_ecp_group_0 *grp);
void __fastcall mbedtls_ecp_group_init(mbedtls_ecp_group_0 *grp);
int __fastcall mbedtls_ecp_group_load(mbedtls_ecp_group_0 *grp, mbedtls_ecp_group_id id);
int __fastcall mbedtls_ecp_is_zero(mbedtls_ecp_point_0 *pt);
void __fastcall mbedtls_ecp_keypair_free(mbedtls_ecp_keypair_0 *key);
void __fastcall mbedtls_ecp_keypair_init(mbedtls_ecp_keypair_0 *key);
int mbedtls_ecp_mul_restartable(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng, mbedtls_ecp_restart_ctx *rs_ctx); // idb
int mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, mbedtls_ecp_restart_ctx *rs_ctx); // idb
int mbedtls_ecp_muladd_restartable(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, const mbedtls_mpi_0 *n, const mbedtls_ecp_point_0 *Q, mbedtls_ecp_restart_ctx *rs_ctx); // idb
void __fastcall mbedtls_ecp_point_free(mbedtls_ecp_point_0 *pt);
void __fastcall mbedtls_ecp_point_init(mbedtls_ecp_point_0 *pt);
int __fastcall mbedtls_ecp_point_read_binary(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *pt, const unsigned __int8 *buf, size_t ilen);
int __fastcall mbedtls_ecp_set_zero(mbedtls_ecp_point_0 *pt);
int __fastcall mbedtls_ecp_tls_read_group(mbedtls_ecp_group_0 *grp, const unsigned __int8 **buf, size_t len);
int __fastcall mbedtls_ecp_tls_read_group_id(mbedtls_ecp_group_id *grp, const unsigned __int8 **buf, size_t len);
int __fastcall mbedtls_internal_sha256_process(mbedtls_sha256_context_0 *ctx, const unsigned __int8 *data);
int __fastcall mbedtls_mpi_add_abs(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
int __fastcall mbedtls_mpi_add_int(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, mbedtls_mpi_sint b);
int __fastcall mbedtls_mpi_add_mpi(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
size_t __fastcall mbedtls_mpi_bitlen(const mbedtls_mpi_0 *X);
int __fastcall mbedtls_mpi_cmp_abs(const mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y);
int __fastcall mbedtls_mpi_cmp_int(const mbedtls_mpi_0 *X, mbedtls_mpi_sint z);
int __fastcall mbedtls_mpi_cmp_mpi(const mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y);
int __fastcall mbedtls_mpi_copy(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y);
int __fastcall mbedtls_mpi_div_mpi(mbedtls_mpi_0 *Q, mbedtls_mpi_0 *R, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
int __fastcall mbedtls_mpi_fill_random(mbedtls_mpi_0 *X, size_t size, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng);
void __fastcall mbedtls_mpi_free(mbedtls_mpi_0 *X);
int __fastcall mbedtls_mpi_gcd(mbedtls_mpi_0 *G, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
int __fastcall mbedtls_mpi_get_bit(const mbedtls_mpi_0 *X, size_t pos);
int __fastcall mbedtls_mpi_grow(mbedtls_mpi_0 *X, size_t nblimbs);
void __fastcall mbedtls_mpi_init(mbedtls_mpi_0 *X);
int __fastcall mbedtls_mpi_inv_mod(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *N);
size_t __fastcall mbedtls_mpi_lsb(const mbedtls_mpi_0 *X);
int __fastcall mbedtls_mpi_lset(mbedtls_mpi_0 *X, mbedtls_mpi_sint z);
int __fastcall mbedtls_mpi_mod_mpi(mbedtls_mpi_0 *R, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
int __fastcall mbedtls_mpi_mul_int(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, mbedtls_mpi_uint b);
int __fastcall mbedtls_mpi_mul_mpi(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
int __fastcall mbedtls_mpi_read_binary(mbedtls_mpi_0 *X, const unsigned __int8 *buf, size_t buflen);
int __fastcall mbedtls_mpi_read_binary_le(mbedtls_mpi_0 *X, const unsigned __int8 *buf, size_t buflen);
int __fastcall mbedtls_mpi_read_string(mbedtls_mpi_0 *X, int radix, const unsigned __int8 *s);
int __fastcall mbedtls_mpi_safe_cond_assign(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y, unsigned int assign);
int __fastcall mbedtls_mpi_safe_cond_swap(mbedtls_mpi_0 *X, mbedtls_mpi_0 *Y, unsigned int swap);
int __fastcall mbedtls_mpi_set_bit(mbedtls_mpi_0 *X, size_t pos, unsigned __int8 val);
int __fastcall mbedtls_mpi_shift_l(mbedtls_mpi_0 *X, size_t count);
int __fastcall mbedtls_mpi_shift_r(mbedtls_mpi_0 *X, size_t count);
int __fastcall mbedtls_mpi_shrink(mbedtls_mpi_0 *X, size_t nblimbs);
size_t __fastcall mbedtls_mpi_size(const mbedtls_mpi_0 *X);
int __fastcall mbedtls_mpi_sub_abs(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
int __fastcall mbedtls_mpi_sub_int(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, mbedtls_mpi_sint b);
int __fastcall mbedtls_mpi_sub_mpi(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B);
void __fastcall mbedtls_platform_zeroize(void *buf, size_t len);
int __fastcall mbedtls_sha256_finish_ret(mbedtls_sha256_context_0 *ctx, unsigned __int8 *output);
void __fastcall mbedtls_sha256_free(mbedtls_sha256_context_0 *ctx);
void __fastcall mbedtls_sha256_init(mbedtls_sha256_context_0 *ctx);
int __fastcall mbedtls_sha256_ret(const unsigned __int8 *input, size_t ilen, unsigned __int8 *output, int is224);
int __fastcall mbedtls_sha256_starts_ret(mbedtls_sha256_context_0 *ctx, int is224);
int __fastcall mbedtls_sha256_update_ret(mbedtls_sha256_context_0 *ctx, const unsigned __int8 *input, size_t ilen);
void __fastcall mpi_bigendian_to_host(mbedtls_mpi_uint *const p, size_t limbs);
int __fastcall mpi_get_digit(mbedtls_mpi_uint *d, int radix, unsigned __int8 c);
void mpi_mul_hlp(size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b); // idb
void __fastcall mpi_sub_hlp(size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d);
mbedtls_mpi_uint __fastcall mpi_uint_bigendian_to_host(mbedtls_mpi_uint x);
unsigned int __fastcall reflect(unsigned int data, unsigned __int8 nBits);
bool __fastcall sissdk_ecdsa_load_group(mbedtls_ecdsa_context *ctx);
bool __fastcall sissdk_ecdsa_load_publickey(const uint8_t *pubkey, mbedtls_ecdsa_context *ctx);
uint8_t *__fastcall sissdk_ecdsa_sha256(const uint8_t *src, uint32_t size);
bool __fastcall sissdk_ecdsa_verify(const uint8_t *pubKey, const uint8_t *src, uint32_t src_size, const S_ECDSA_SIGN_0 *sig);
void __fastcall sub32(uint32_t *dst, uint32_t src, char *carry);
void util_dump_buf(const unsigned __int8 *title, unsigned __int8 *buf, size_t len); // idb
int advance_software_protect_flash_verify();
int _Ven_TT_L__advance_software_protect_flash_verify_init();
bool _Ven_TT_L__advance_software_protect_flash_verify_check();
uint32_t __fastcall _Ven_TT_L__crc32(const void *data, int nBytes);
uint32_t __fastcall _Ven_TT_L__crc32_continue(uint32_t prev_crc, const void *data, int nBytes);
int __fastcall _Ven_TT_L__encrypt_g(uint16_t g, uint8_t k, uint8_t *key);
int __fastcall _Ven_TT_L__encrypt_g_inv(uint16_t g, uint8_t k, uint8_t *key);
uint32_t __fastcall _Ven_TT_L__HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength);
uint32_t __fastcall _Ven_TT_L__HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength);
void __fastcall _Ven_TT_L__HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
int _Ven_TT_L__HAL_FLASH_Unlock();
int _Ven_TT_L__HAL_FLASH_OB_Unlock();
int __fastcall _Ven_TT_L__HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
int _Ven_TT_L__HAL_FLASH_OB_Lock();
int _Ven_TT_L__HAL_FLASH_Lock();
bool __fastcall _Ven_TT_L__sissdk_ecdsa_verify(const uint8_t *pubKey, const uint8_t *src, uint32_t src_size, const S_ECDSA_SIGN_0 *sig);
void __fastcall advance_software_protect_anti_debugger(AntiDebuggerCallback eventCallback);
void __fastcall advance_software_protect_encrypt_process(void *data, size_t size, uint64_t key, int isEnc);
crc32_t __fastcall advance_software_protect_crc32(uint8_t *buffer, size_t size, int a3, uint32_t a4);
void __fastcall advance_software_protect_get_cid(uint32_t id_addr, uint8_t size, uint8_t *id_data);
void __noreturn advance_software_protect_system_reset();
void advance_software_protect_debugger_disable(); // idb
bool advance_software_protect_rdp_check(); // idb
void advance_software_protect_rdp_enable(); // idb
bool advance_software_protect_verify_authorization(); // idb

//-------------------------------------------------------------------------
// Data declarations

int dword_8000164[2] = { 32896, 32928 }; // weak
const uint8_t AHBPrescTable[16] = { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 2u, 3u, 4u, 6u, 7u, 8u, 9u }; // idb
const uint8_t APBPrescTable[8] = { 0u, 0u, 0u, 0u, 1u, 2u, 3u, 4u }; // idb
const mbedtls_ecp_curve_info_0 ecp_supported_curves[12] =
{
  { MBEDTLS_ECP_DP_SECP521R1, 25u, 521u, &aSecp521r1 },
  { MBEDTLS_ECP_DP_BP512R1, 28u, 512u, &aBrainpoolp512r },
  { MBEDTLS_ECP_DP_SECP384R1, 24u, 384u, &aSecp384r1 },
  { MBEDTLS_ECP_DP_BP384R1, 27u, 384u, &aBrainpoolp384r },
  { MBEDTLS_ECP_DP_SECP256R1, 23u, 256u, &aSecp256r1 },
  { MBEDTLS_ECP_DP_SECP256K1, 22u, 256u, &aSecp256k1 },
  { MBEDTLS_ECP_DP_BP256R1, 26u, 256u, &aBrainpoolp256r },
  { MBEDTLS_ECP_DP_SECP224R1, 21u, 224u, &aSecp224r1 },
  { MBEDTLS_ECP_DP_SECP224K1, 20u, 224u, &aSecp224k1 },
  { MBEDTLS_ECP_DP_SECP192R1, 19u, 192u, &aSecp192r1 },
  { MBEDTLS_ECP_DP_SECP192K1, 18u, 192u, &aSecp192k1 },
  { MBEDTLS_ECP_DP_NONE, 0u, 0u, NULL }
}; // idb
const mbedtls_mpi_uint secp192k1_a[1] = { 0u }; // idb
const mbedtls_mpi_uint secp192k1_b[1] = { 3u }; // idb
const mbedtls_mpi_uint secp224k1_a[1] = { 0u }; // idb
const mbedtls_mpi_uint secp224k1_b[1] = { 5u }; // idb
const mbedtls_mpi_uint secp256k1_a[1] = { 0u }; // idb
const mbedtls_mpi_uint secp256k1_b[1] = { 7u }; // idb
const mbedtls_mpi_uint secp192r1_p[6] = { 4294967295u, 4294967295u, 4294967294u, 4294967295u, 4294967295u, 4294967295u }; // idb
const mbedtls_mpi_uint secp192r1_b[6] = { 3242637745u, 4273528556u, 1914974281u, 262662571u, 3852239079u, 1679885593u }; // idb
const mbedtls_mpi_uint secp192r1_gx[6] = { 2197753874u, 4110355197u, 1134659584u, 2092900587u, 2955972854u, 411936782u }; // idb
const mbedtls_mpi_uint secp192r1_gy[6] = { 511264785u, 1945728929u, 1797574101u, 1661997549u, 4291353208u, 119090069u }; // idb
const mbedtls_mpi_uint secp192r1_n[6] = { 3033671729u, 342608305u, 2581526582u, 4294967295u, 4294967295u, 4294967295u }; // idb
const mbedtls_mpi_uint secp224r1_p[8] = { 1u, 0u, 0u, 4294967295u, 4294967295u, 4294967295u, 4294967295u, 0u }; // idb
const mbedtls_mpi_uint secp224r1_b[7] =
{
  592838580u,
  655046979u,
  3619674298u,
  1346678967u,
  4114690646u,
  201634731u,
  3020229253u
}; // idb
const mbedtls_mpi_uint secp224r1_gx[7] =
{
  291249441u,
  875725014u,
  1455558946u,
  1241760211u,
  840143033u,
  1807007615u,
  3071151293u
}; // idb
const mbedtls_mpi_uint secp224r1_gy[7] =
{
  2231402036u,
  1154843033u,
  1510426468u,
  3443750304u,
  1277353958u,
  3052872699u,
  3174523784u
}; // idb
const mbedtls_mpi_uint secp224r1_n[7] =
{
  1549543997u,
  333261125u,
  3770216510u,
  4294907554u,
  4294967295u,
  4294967295u,
  4294967295u
}; // idb
const mbedtls_mpi_uint secp256r1_p[8] = { 4294967295u, 4294967295u, 4294967295u, 0u, 0u, 0u, 1u, 4294967295u }; // idb
const mbedtls_mpi_uint secp256r1_b[8] =
{
  668098635u,
  1003371582u,
  3428036854u,
  1696401072u,
  1989707452u,
  3018571093u,
  2855965671u,
  1522939352u
}; // idb
const mbedtls_mpi_uint secp256r1_gx[8] =
{
  3633889942u,
  4104206661u,
  770388896u,
  1996717441u,
  1671708914u,
  4173129445u,
  3777774151u,
  1796723186u
}; // idb
const mbedtls_mpi_uint secp256r1_gy[8] =
{
  935285237u,
  3417718888u,
  1798397646u,
  734933847u,
  2081398294u,
  2397563722u,
  4263149467u,
  1340293858u
}; // idb
const mbedtls_mpi_uint secp256r1_n[8] =
{
  4234356049u,
  4089039554u,
  2803342980u,
  3169254061u,
  4294967295u,
  4294967295u,
  0u,
  4294967295u
}; // idb
const mbedtls_mpi_uint secp384r1_p[12] =
{
  4294967295u,
  0u,
  0u,
  4294967295u,
  4294967294u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u
}; // idb
const mbedtls_mpi_uint secp384r1_b[12] =
{
  3555470063u,
  713410797u,
  2318324125u,
  3327539597u,
  1343457114u,
  51644559u,
  4269883666u,
  404593774u,
  3824692505u,
  2559444331u,
  3795773412u,
  3006345127u
}; // idb
const mbedtls_mpi_uint secp384r1_gx[12] =
{
  1920338615u,
  978607672u,
  3210029420u,
  1426256477u,
  2186553912u,
  1509376480u,
  2343017368u,
  1847409506u,
  4079005044u,
  2394015518u,
  3196781879u,
  2861025826u
}; // idb
const mbedtls_mpi_uint secp384r1_gy[12] =
{
  2431258207u,
  2051218812u,
  494829981u,
  174109134u,
  3052452032u,
  3923390739u,
  681186428u,
  4176747965u,
  2459098153u,
  1570674879u,
  2519084143u,
  907533898u
}; // idb
const mbedtls_mpi_uint secp384r1_n[12] =
{
  3435473267u,
  3974895978u,
  1219536762u,
  1478102450u,
  4097256927u,
  3345173889u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u
}; // idb
const mbedtls_mpi_uint secp521r1_p[17] =
{
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  511u
}; // idb
const mbedtls_mpi_uint secp521r1_b[17] =
{
  1800421120u,
  4014284756u,
  1026307313u,
  896786312u,
  1001504519u,
  374522045u,
  3967718267u,
  1444493649u,
  2398161377u,
  3098839441u,
  2578650611u,
  2732225115u,
  3062186222u,
  2459574688u,
  2384239135u,
  2503915873u,
  81u
}; // idb
const mbedtls_mpi_uint secp521r1_gx[17] =
{
  3269836134u,
  4185816625u,
  2238333595u,
  860402625u,
  2734663902u,
  4263362855u,
  4024916264u,
  2706071159u,
  1800224186u,
  4163415904u,
  88061217u,
  2623832377u,
  597013570u,
  2654915430u,
  67430861u,
  2240677559u,
  198u
}; // idb
const mbedtls_mpi_uint secp521r1_gy[17] =
{
  2681300560u,
  2294191222u,
  2725429824u,
  893153414u,
  1068304225u,
  3310401793u,
  1593058880u,
  2548986521u,
  658400812u,
  397393175u,
  1469793384u,
  2566210633u,
  746396633u,
  1552572340u,
  2587607044u,
  959015544u,
  280u
}; // idb
const mbedtls_mpi_uint secp521r1_n[17] =
{
  2436391945u,
  3144660766u,
  2308720558u,
  1001769400u,
  4144604624u,
  2144076104u,
  3207566955u,
  1367771011u,
  4294967290u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  511u
}; // idb
const mbedtls_mpi_uint secp192k1_p[6] = { 4294962743u, 4294967294u, 4294967295u, 4294967295u, 4294967295u, 4294967295u }; // idb
const mbedtls_mpi_uint secp192k1_gx[6] = { 3940576381u, 497406385u, 2159539252u, 649100546u, 3226986926u, 3679449358u }; // idb
const mbedtls_mpi_uint secp192k1_gy[6] = { 3646828445u, 1082305160u, 364807732u, 2218877904u, 2622892199u, 2603560813u }; // idb
const mbedtls_mpi_uint secp192k1_n[6] = { 1960770957u, 258557546u, 653458455u, 4294967294u, 4294967295u, 4294967295u }; // idb
const mbedtls_mpi_uint secp224k1_p[7] =
{
  4294960493u,
  4294967294u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u
}; // idb
const mbedtls_mpi_uint secp224k1_gx[7] =
{
  3065488476u,
  259941646u,
  3832575401u,
  1772382185u,
  821831841u,
  1307613663u,
  2705677107u
}; // idb
const mbedtls_mpi_uint secp224k1_gy[7] =
{
  1433231781u,
  3804908507u,
  3232808281u,
  4158855671u,
  2194340822u,
  2142909506u,
  2114494445u
}; // idb
const mbedtls_mpi_uint secp224k1_n[8] = { 1990177271u, 3404769649u, 3538706820u, 122088u, 0u, 0u, 0u, 1u }; // idb
const mbedtls_mpi_uint secp256k1_p[8] =
{
  4294966319u,
  4294967294u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u,
  4294967295u
}; // idb
const mbedtls_mpi_uint secp256k1_gx[8] =
{
  385357720u,
  1509065051u,
  768485593u,
  43777243u,
  3464956679u,
  1436574357u,
  4191992748u,
  2042521214u
}; // idb
const mbedtls_mpi_uint secp256k1_gy[8] =
{
  4212184248u,
  2621952143u,
  2793755673u,
  4246189128u,
  235997352u,
  1571093500u,
  648266853u,
  1211816567u
}; // idb
const mbedtls_mpi_uint secp256k1_n[8] =
{
  3493216577u,
  3218235020u,
  2940772411u,
  3132021990u,
  4294967294u,
  4294967295u,
  4294967295u,
  4294967295u
}; // idb
const mbedtls_mpi_uint brainpoolP256r1_p[8] =
{
  527324023u,
  538134557u,
  3576045608u,
  1849423395u,
  2642644338u,
  1046874768u,
  2716772796u,
  2851821531u
}; // idb
const mbedtls_mpi_uint brainpoolP256r1_a[8] =
{
  4080055769u,
  3913960260u,
  651975788u,
  4219491777u,
  1098579943u,
  4009129264u,
  4230754391u,
  2103052661u
}; // idb
const mbedtls_mpi_uint brainpoolP256r1_b[8] =
{
  4287367094u,
  1808587800u,
  1559749070u,
  2508461609u,
  3151461567u,
  4080055769u,
  3913960260u,
  651975788u
}; // idb
const mbedtls_mpi_uint brainpoolP256r1_gx[8] =
{
  2597204578u,
  977556413u,
  3820823490u,
  3118344161u,
  4236359599u,
  743131183u,
  3414054859u,
  2345840313u
}; // idb
const mbedtls_mpi_uint brainpoolP256r1_gy[8] =
{
  788818327u,
  1545426119u,
  770543188u,
  3262596371u,
  341908937u,
  2549630490u,
  3285894397u,
  1417607221u
}; // idb
const mbedtls_mpi_uint brainpoolP256r1_n[8] =
{
  2538100391u,
  2417888898u,
  3043075831u,
  2352577187u,
  2642644337u,
  1046874768u,
  2716772796u,
  2851821531u
}; // idb
const mbedtls_mpi_uint brainpoolP384r1_p[12] =
{
  822602835u,
  2269577235u,
  2417826417u,
  2899552041u,
  2142703907u,
  313645593u,
  3981727412u,
  355430665u,
  1357267423u,
  257781630u,
  2738384168u,
  2360942210u
}; // idb
const mbedtls_mpi_uint brainpoolP384r1_a[12] =
{
  583936038u,
  78170077u,
  1346032875u,
  2326102346u,
  3130128655u,
  328295919u,
  1337075591u,
  3267273358u,
  3456479136u,
  1014106122u,
  1032590604u,
  2076410566u
}; // idb
const mbedtls_mpi_uint brainpoolP384r1_b[12] =
{
  4199566353u,
  985106070u,
  2514209172u,
  2092185858u,
  1055613653u,
  780668581u,
  131912358u,
  800554465u,
  384844924u,
  2335814996u,
  583936038u,
  78170077u
}; // idb
const mbedtls_mpi_uint brainpoolP384r1_gx[12] =
{
  1205120798u,
  4018647778u,
  920012458u,
  3894861876u,
  213717224u,
  3682585342u,
  2129743843u,
  2286396391u,
  3082895211u,
  2728802945u,
  1758414335u,
  488400112u
}; // idb
const mbedtls_mpi_uint brainpoolP384r1_gy[12] =
{
  641487637u,
  1115816769u,
  2006024465u,
  239486497u,
  4187040040u,
  3785098575u,
  4276901988u,
  1656163113u,
  2513425746u,
  1555164046u,
  553239204u,
  2327715189u
}; // idb
const mbedtls_mpi_uint brainpoolP384r1_n[12] =
{
  3909379429u,
  998781442u,
  1803535120u,
  3476731567u,
  2885952935u,
  521563756u,
  3981727411u,
  355430665u,
  1357267423u,
  257781630u,
  2738384168u,
  2360942210u
}; // idb
const mbedtls_mpi_uint brainpoolP512r1_p[16] =
{
  1480214771u,
  682254422u,
  763545221u,
  679608111u,
  3869475046u,
  2932711722u,
  2613471298u,
  2102237952u,
  1882392689u,
  3596852426u,
  3016348174u,
  3408956851u,
  868875271u,
  1070917294u,
  3689530507u,
  2866650552u
}; // idb
const mbedtls_mpi_uint brainpoolP512r1_a[16] =
{
  2013041866u,
  3888229453u,
  737331129u,
  2131826599u,
  2342176949u,
  170848713u,
  2821012129u,
  770530650u,
  3935855548u,
  2821997002u,
  1039734288u,
  2496388493u,
  2887994565u,
  3794956613u,
  2338339721u,
  2016453425u
}; // idb
const mbedtls_mpi_uint brainpoolP512r1_b[16] =
{
  2148988707u,
  671726947u,
  1589306845u,
  2554351799u,
  3691527783u,
  2013041866u,
  3888229453u,
  737331129u,
  2131826599u,
  2342176949u,
  170848713u,
  2821012129u,
  770530650u,
  3935855548u,
  2821997002u,
  1039734288u
}; // idb
const mbedtls_mpi_uint brainpoolP512r1_gx[16] =
{
  3166304290u,
  2335515145u,
  1080712808u,
  2087538759u,
  2478407007u,
  1355901051u,
  3805336717u,
  4282064760u,
  4107274638u,
  3023790830u,
  3050903233u,
  2246942576u,
  2622253715u,
  1512124974u,
  3626948964u,
  2175722685u
}; // idb
const mbedtls_mpi_uint brainpoolP512r1_gy[16] =
{
  987236498u,
  2026708495u,
  2834322438u,
  3519687471u,
  2317837230u,
  1539984344u,
  1247758430u,
  3000819273u,
  2283766033u,
  2684405083u,
  614824730u,
  4060739328u,
  3480756989u,
  3236609961u,
  1449341676u,
  2111715421u
}; // idb
const mbedtls_mpi_uint brainpoolP512r1_n[16] =
{
  2628321385u,
  3045561986u,
  140368605u,
  498193281u,
  2141982791u,
  1099325721u,
  1286153753u,
  1430150209u,
  1882392688u,
  3596852426u,
  3016348174u,
  3408956851u,
  868875271u,
  1070917294u,
  3689530507u,
  2866650552u
}; // idb
const uint32_t K[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
const S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_SKIP_0 m_flash_verify_skip_items[3] =
{
  { &m_flash_verify, 36u },
  { &m_signature_data, 141u },
  { &m_serialnumber, 4u }
}; // idb
const uint8_t m_ptable[256] =
{
  166u,
  32u,
  147u,
  194u,
  184u,
  193u,
  76u,
  12u,
  243u,
  11u,
  115u,
  190u,
  68u,
  119u,
  157u,
  225u,
  238u,
  202u,
  118u,
  195u,
  36u,
  237u,
  183u,
  203u,
  255u,
  57u,
  70u,
  206u,
  205u,
  134u,
  87u,
  62u,
  91u,
  133u,
  187u,
  198u,
  200u,
  242u,
  21u,
  73u,
  188u,
  161u,
  212u,
  112u,
  219u,
  51u,
  20u,
  101u,
  26u,
  86u,
  150u,
  125u,
  201u,
  89u,
  102u,
  96u,
  29u,
  213u,
  174u,
  15u,
  244u,
  55u,
  6u,
  64u,
  231u,
  136u,
  247u,
  253u,
  116u,
  228u,
  146u,
  137u,
  17u,
  211u,
  169u,
  204u,
  132u,
  69u,
  148u,
  25u,
  245u,
  160u,
  28u,
  220u,
  77u,
  135u,
  246u,
  54u,
  100u,
  13u,
  7u,
  98u,
  80u,
  209u,
  78u,
  189u,
  221u,
  153u,
  108u,
  18u,
  1u,
  139u,
  217u,
  182u,
  239u,
  56u,
  33u,
  145u,
  152u,
  252u,
  10u,
  123u,
  52u,
  176u,
  110u,
  181u,
  215u,
  42u,
  45u,
  192u,
  185u,
  27u,
  165u,
  0u,
  126u,
  127u,
  172u,
  170u,
  94u,
  199u,
  196u,
  158u,
  251u,
  179u,
  46u,
  72u,
  224u,
  47u,
  106u,
  149u,
  48u,
  186u,
  60u,
  63u,
  229u,
  254u,
  155u,
  97u,
  207u,
  248u,
  104u,
  111u,
  31u,
  227u,
  16u,
  53u,
  140u,
  144u,
  30u,
  130u,
  214u,
  235u,
  143u,
  3u,
  90u,
  79u,
  141u,
  164u,
  117u,
  82u,
  159u,
  83u,
  114u,
  121u,
  38u,
  230u,
  8u,
  5u,
  138u,
  41u,
  223u,
  177u,
  180u,
  218u,
  61u,
  151u,
  226u,
  9u,
  35u,
  37u,
  240u,
  107u,
  103u,
  74u,
  128u,
  197u,
  173u,
  84u,
  58u,
  14u,
  142u,
  210u,
  105u,
  88u,
  249u,
  129u,
  34u,
  75u,
  99u,
  175u,
  95u,
  22u,
  2u,
  208u,
  93u,
  71u,
  19u,
  120u,
  109u,
  67u,
  40u,
  156u,
  236u,
  65u,
  43u,
  113u,
  167u,
  92u,
  222u,
  81u,
  241u,
  44u,
  178u,
  154u,
  232u,
  124u,
  23u,
  162u,
  66u,
  59u,
  50u,
  85u,
  191u,
  39u,
  250u,
  234u,
  233u,
  216u,
  24u,
  4u,
  49u,
  168u,
  171u,
  163u,
  131u,
  122u
}; // idb
const uint8_t ECDSA_PUBLIC_KEY[49] =
{
  4u,
  55u,
  8u,
  55u,
  134u,
  223u,
  37u,
  15u,
  140u,
  31u,
  146u,
  216u,
  51u,
  14u,
  130u,
  56u,
  74u,
  103u,
  39u,
  9u,
  172u,
  254u,
  122u,
  31u,
  36u,
  2u,
  73u,
  164u,
  3u,
  237u,
  103u,
  171u,
  74u,
  153u,
  97u,
  55u,
  254u,
  122u,
  237u,
  30u,
  108u,
  233u,
  31u,
  11u,
  236u,
  202u,
  11u,
  31u,
  38u
}; // idb
CRC_HandleTypeDef hcrc = { NULL, HAL_UNLOCKED, HAL_CRC_STATE_RESET }; // idb
HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_1KHZ; // idb
uint32_t uwTickPrio = 16u; // idb
volatile uint32_t uwTick = 0u; // idb
uint32_t SystemCoreClock = 16000000u; // idb
uint8_t m_grp[3] = { 3u, 0u, 19u }; // idb
_UNKNOWN one; // weak
mbedtls_mpi_uint Rp[2] = { 4553u, 1u }; // idb
mbedtls_mpi_uint Rp_0[2] = { 6803u, 1u }; // idb
mbedtls_mpi_uint Rp_1[2] = { 977u, 1u }; // idb
void *(*const volatile memset_func)(void *, int, size_t) = (void *(*const volatile)(void *, int, size_t))0x8000503; // idb
const volatile uint64_t m_anti_debugger_tag_s = 6469269757705222760uLL; // idb
volatile uint64_t m_anti_debugger_tag_m = 14139388263887712899uLL; // idb
volatile uint64_t m_anti_debugger_tag_r = 11384611846400559339uLL; // idb
S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_APP_0 m_ObjectWatchList = { NULL, NULL }; // idb
bool m_ramcode_loaded = false; // idb
bool once_only = false; // idb
volatile uint32_t m_Chip_ID_Addr = 1143247494u; // idb
volatile uint32_t m_Chip_ID_Size = 1541104994u; // idb
const volatile uint32_t m_signature_data_addr = 1406879086u; // idb
UART_HandleTypeDef huart1; // idb
FLASH_ProcessTypeDef pFlash; // idb
uint8_t m_hash[32]; // idb
volatile S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_0 m_flash_verify_r; // idb
volatile S_ADV_SOFTWARE_PROTECT_RAMCODE_0 m_ramcode_r; // idb
S_Object_Watcher_0 m_Object; // idb
S_Object_0 m_object; // idb
S_A_0 m_aType; // idb
S_B_0 m_bType; // idb
S_Class_0 m_class; // idb
uint8_t m_Chip_ID_Data[12]; // idb
_UNKNOWN _libspace_start; // weak
_UNKNOWN unk_200001C4; // weak
_UNKNOWN Heap_Mem; // weak


//----- (08000130) --------------------------------------------------------
void __noreturn _main()
{
  _scatterload_rt2_thumb_only();
  _rt_entry_sh();
}

//----- (08000138) --------------------------------------------------------
int _scatterload_rt2_thumb_only()
{
  return _scatterload_null((int)dword_8000164);
}
// 8000164: using guessed type int dword_8000164[2];

//----- (08000146) --------------------------------------------------------
int __fastcall _scatterload_null(int a1)
{
  int v1; // r7
  _DWORD *v2; // r10
  _DWORD *v3; // r11
  int v4; // r3

  if ( v2 == v3 )
    _rt_entry_sh();
  v4 = v2[3];
  if ( (v4 & 1) != 0 )
    v4 = v1 - v4;
  return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD))(v4 | 1))(*v2, v2[1], v2[2]);
}
// 8000148: variable 'v2' is possibly undefined
// 8000148: variable 'v3' is possibly undefined
// 800015C: variable 'v1' is possibly undefined

//----- (0800016C) --------------------------------------------------------
int *__fastcall _scatterload_copy(int *result, int *a2, unsigned int a3)
{
  bool v3; // cf
  int v4; // r3
  int v5; // r4
  int v6; // r5
  int v7; // r6
  int v8; // r2
  int v9; // r4
  int v10; // r5

  do
  {
    v3 = a3 >= 0x10;
    a3 -= 16;
    if ( v3 )
    {
      v4 = *result;
      v5 = result[1];
      v6 = result[2];
      v7 = result[3];
      result += 4;
      *a2 = v4;
      a2[1] = v5;
      a2[2] = v6;
      a2[3] = v7;
      a2 += 4;
    }
  }
  while ( a3 != 0 && v3 );
  v3 = __CFSHL__(a3, 29);
  v8 = a3 << 29;
  if ( v3 )
  {
    v9 = *result;
    v10 = result[1];
    result += 2;
    *a2 = v9;
    a2[1] = v10;
    a2 += 2;
  }
  if ( v8 < 0 )
    *a2 = *result;
  return result;
}

//----- (08000188) --------------------------------------------------------
void __fastcall _scatterload_zeroinit(int a1, _DWORD *a2, unsigned int a3)
{
  bool v3; // cf
  int v4; // r2

  do
  {
    v3 = a3 >= 0x10;
    a3 -= 16;
    if ( v3 )
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      a2[3] = 0;
      a2 += 4;
    }
  }
  while ( a3 != 0 && v3 );
  v3 = __CFSHL__(a3, 29);
  v4 = a3 << 29;
  if ( v3 )
  {
    *a2 = 0;
    a2[1] = 0;
    a2 += 2;
  }
  if ( v4 < 0 )
    *a2 = 0;
}

//----- (080001A6) --------------------------------------------------------
int __fastcall _rt_lib_init_preinit_1(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // r0

  v6 = init_alloc(a5, a6, a3, a4);
  return _rt_lib_init_user_alloc_1(v6);
}
// 80001AE: using guessed type int __fastcall _rt_lib_init_user_alloc_1(_DWORD);

//----- (080001B4) --------------------------------------------------------
void __noreturn _rt_entry_sh()
{
  void *v0; // r0
  int v1; // r2

  v0 = _user_setup_stackheap();
  _rt_entry_postsh_1((int)v0, v1);
}
// 80001B9: variable 'v1' is possibly undefined

//----- (080001CC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn _rt_exit_exit()
{
  int v0; // [sp-8h] [bp-8h]

  sys_exit(v0);
}
// 80001CE: positive sp value 8 has been found
// 80001CE: variable 'v0' is possibly undefined

//----- (080001D4) --------------------------------------------------------
void Reset_Handler()
{
  SystemInit();
  _main();
}

//----- (080001F0) --------------------------------------------------------
void *_user_initial_stackheap()
{
  return &Heap_Mem;
}

//----- (08000214) --------------------------------------------------------
int __fastcall calloc(unsigned int a1, unsigned int a2)
{
  unsigned __int64 v2; // kr00_8
  int v4; // r5

  v2 = a1 * (unsigned __int64)a2;
  if ( v2 >= 0x10000000 )
    return 0;
  v4 = malloc(v2);
  if ( v4 )
    _rt_memclr(HIDWORD(v2), v2);
  return v4;
}
// 8000518: using guessed type int __fastcall _rt_memclr(_DWORD, _DWORD);

//----- (0800023C) --------------------------------------------------------
int __fastcall malloc(unsigned int a1)
{
  int v2; // r5
  unsigned int v3; // r4
  int result; // r0
  unsigned int *v5; // r3
  unsigned int *v6; // r2
  _DWORD *v7; // r0

  v2 = *(_DWORD *)_rt_heap_descriptor();
  v3 = (a1 + 11) & 0xFFFFFFF8;
  if ( v3 <= a1 )
    return 0;
  while ( 1 )
  {
    v5 = (unsigned int *)v2;
    v6 = *(unsigned int **)(v2 + 4);
    if ( v6 )
      break;
LABEL_10:
    result = _Heap_Full();
    if ( !result )
      return result;
  }
  while ( *v6 < v3 )
  {
    v5 = v6;
    v6 = (unsigned int *)v6[1];
    if ( !v6 )
      goto LABEL_10;
  }
  if ( *v6 >= v3 + 8 )
  {
    v7 = (unsigned int *)((char *)v6 + v3);
    v7[1] = v6[1];
    *v7 = *v6 - v3;
    v5[1] = (unsigned int)v6 + v3;
    *v6 = v3;
  }
  else
  {
    v5[1] = v6[1];
  }
  return (int)(v6 + 1);
}

//----- (0800029A) --------------------------------------------------------
_DWORD *__fastcall free(int a1)
{
  _DWORD *v2; // r5
  _DWORD *result; // r0
  _DWORD *i; // r4
  bool v5; // cf
  _DWORD *v6; // r2

  v2 = (_DWORD *)(a1 - 4);
  result = *(_DWORD **)_rt_heap_descriptor();
  if ( a1 )
  {
    for ( i = (_DWORD *)result[1]; ; i = (_DWORD *)i[1] )
    {
      v5 = 1;
      if ( i )
        v5 = i >= v2;
      if ( v5 )
        break;
      result = i;
    }
    if ( (_DWORD *)((char *)result + *result) == v2 )
    {
      v6 = (_DWORD *)*v2;
      v2 = result;
      *result += v6;
    }
    else
    {
      result[1] = v2;
    }
    result = (_DWORD *)*v2;
    if ( (_DWORD *)((char *)v2 + *v2) == i )
    {
      v2[1] = i[1];
      result = (_DWORD *)((char *)result + *i);
      *v2 = result;
    }
    else
    {
      v2[1] = i;
    }
  }
  return result;
}

//----- (080002E8) --------------------------------------------------------
int __fastcall ll_udiv(unsigned __int64 a1, unsigned __int64 a2)
{
  int v2; // r6
  unsigned int v3; // r5
  unsigned int v4; // r4
  unsigned int v5; // r5
  bool v6; // zf
  unsigned int v7; // r4
  int v8; // r9
  unsigned int v9; // r7
  unsigned int v10; // r6
  unsigned int v11; // r7
  int v12; // r7
  int v13; // r11
  unsigned int v14; // r6

  if ( !a2 )
    return 0;
  v2 = 0;
  if ( HIDWORD(a2) )
  {
    v3 = __clz(HIDWORD(a2));
    v4 = HIDWORD(a2) << v3;
    v2 = (HIDWORD(a2) << v3 >> v3) ^ HIDWORD(a2) | a2;
  }
  else
  {
    v3 = __clz(a2);
    v4 = (_DWORD)a2 << v3;
  }
  v5 = 32 - v3;
  if ( HIDWORD(a2) )
  {
    v4 |= (unsigned int)a2 >> v5;
    v5 += 32;
  }
  v6 = (v2 | (v4 << 16)) == 0;
  v7 = HIWORD(v4);
  if ( !v6 )
    ++v7;
  v8 = 0;
  while ( a1 >= a2 )
  {
    if ( HIDWORD(a1) )
    {
      v9 = __clz(HIDWORD(a1));
      v10 = HIDWORD(a1) << v9;
    }
    else
    {
      v9 = __clz(a1);
      v10 = (_DWORD)a1 << v9;
    }
    v11 = 32 - v9;
    if ( HIDWORD(a1) )
    {
      v10 |= (unsigned int)a1 >> v11;
      v11 += 32;
    }
    v12 = v11 - v5 - 16;
    v13 = (v10 / v7) << (v12 & 0x1F);
    v14 = (v10 / v7) >> (32 - (v12 & 0x1F));
    if ( v12 < 0 )
    {
      v13 = v14;
      v14 = 0;
    }
    if ( v12 >= 32 )
    {
      v14 = v13;
      v13 = 0;
    }
    if ( !(v13 | v14) )
      v13 = 1;
    v8 += v13;
    a1 -= a2 * __PAIR64__(v14, v13);
  }
  return v8;
}

//----- (080003D6) --------------------------------------------------------
char *__fastcall strlen(char *a1)
{
  char *v1; // r3
  int v3; // r1
  unsigned int v4; // r1
  char *result; // r0

  v1 = a1 + 1;
  while ( (_DWORD)a1 << 30 )
  {
    if ( !*a1++ )
      return (char *)(a1 - v1);
  }
  do
  {
    v3 = *(_DWORD *)a1;
    a1 += 4;
    v4 = (v3 - 16843009) & ~v3 & 0x80808080;
  }
  while ( !v4 );
  result = (char *)(a1 - v1);
  if ( v4 << 24 )
  {
    result -= 3;
  }
  else if ( v4 << 16 )
  {
    result -= 2;
  }
  else if ( v4 << 8 )
  {
    --result;
  }
  return result;
}

//----- (08000414) --------------------------------------------------------
int *__fastcall _rt_memcpy(_BYTE *a1, char *a2, unsigned int a3, int a4)
{
  unsigned int v5; // r12
  char v6; // r3
  char v7; // t1
  bool v8; // cf
  bool v9; // cc
  unsigned int v10; // r2
  char v11; // t1
  char v12; // t1
  bool v13; // cf
  unsigned int v14; // r2
  char *v15; // r1
  int v16; // t1
  int v17; // t1
  int v18; // t1

  if ( a3 <= 3 )
    return (int *)memcpy_lastbytes(a1, a2, a3, a4);
  v5 = (unsigned __int8)a1 & 3;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    v7 = *a2++;
    v6 = v7;
    v8 = v5 >= 2;
    v9 = v5 > 2;
    v10 = a3 + v5;
    if ( ((unsigned __int8)a1 & 3) != 3 )
    {
      v11 = *a2++;
      LOBYTE(v5) = v11;
    }
    *a1++ = v6;
    if ( !v8 )
    {
      v12 = *a2++;
      v6 = v12;
    }
    a3 = v10 - 4;
    if ( !v9 )
      *a1++ = v5;
    if ( !v8 )
      *a1++ = v6;
  }
  LOBYTE(a4) = (unsigned __int8)a2 & 3;
  if ( ((unsigned __int8)a2 & 3) != 0 )
  {
    v13 = a3 >= 8;
    v14 = a3 - 8;
    while ( v13 )
    {
      v16 = *(_DWORD *)a2;
      v15 = a2 + 4;
      a4 = v16;
      v13 = v14 >= 8;
      v14 -= 8;
      v17 = *(_DWORD *)v15;
      a2 = v15 + 4;
      *(_DWORD *)a1 = a4;
      *((_DWORD *)a1 + 1) = v17;
      a1 += 8;
    }
    a3 = v14 + 4;
    if ( (a3 & 0x80000000) == 0 )
    {
      v18 = *(_DWORD *)a2;
      a2 += 4;
      LOBYTE(a4) = v18;
      *(_DWORD *)a1 = v18;
      a1 += 4;
    }
    return (int *)memcpy_lastbytes(a1, a2, a3, a4);
  }
  return _rt_memcpy_w((int *)a1, (int *)a2, a3);
}

//----- (0800047A) --------------------------------------------------------
_BYTE *__fastcall memcpy_lastbytes(_BYTE *result, char *a2, int a3, char a4)
{
  char v4; // r12
  bool v5; // cf
  bool v6; // nf
  int v7; // r2
  char *v8; // r1
  char v9; // t1
  char v10; // t1
  char *v11; // r0

  v5 = __CFSHL__(a3, 31);
  v7 = a3 << 31;
  v6 = v7 < 0;
  if ( v5 )
  {
    v9 = *a2;
    v8 = a2 + 1;
    a4 = v9;
    v10 = *v8;
    a2 = v8 + 1;
    v4 = v10;
  }
  if ( v7 < 0 )
    LOBYTE(v7) = *a2;
  if ( v5 )
  {
    *result = a4;
    v11 = result + 1;
    *v11 = v4;
    result = v11 + 1;
  }
  if ( v6 )
    *result++ = v7;
  return result;
}
// 8000492: variable 'v4' is possibly undefined

//----- (0800049E) --------------------------------------------------------
int *__fastcall _rt_memcpy_w(int *result, int *a2, unsigned int a3)
{
  bool v3; // cf
  unsigned int i; // r2
  int *v5; // r1
  int v6; // r3
  int v7; // r4
  int v8; // r12
  int v9; // lr
  _DWORD *v10; // r0
  int v11; // r3
  int v12; // r4
  int v13; // r12
  int v14; // lr
  int v15; // r3
  int v16; // r4
  int v17; // r12
  int v18; // lr
  int v19; // r3
  int v20; // r4

  v3 = a3 >= 0x20;
  for ( i = a3 - 32; v3; result = v10 + 4 )
  {
    v6 = *a2;
    v7 = a2[1];
    v8 = a2[2];
    v9 = a2[3];
    v5 = a2 + 4;
    v3 = i >= 0x20;
    i -= 32;
    *result = v6;
    result[1] = v7;
    result[2] = v8;
    result[3] = v9;
    v10 = result + 4;
    v11 = *v5;
    v12 = v5[1];
    v13 = v5[2];
    v14 = v5[3];
    a2 = v5 + 4;
    *v10 = v11;
    v10[1] = v12;
    v10[2] = v13;
    v10[3] = v14;
  }
  if ( __CFSHL__(i, 28) )
  {
    v15 = *a2;
    v16 = a2[1];
    v17 = a2[2];
    v18 = a2[3];
    a2 += 4;
    *result = v15;
    result[1] = v16;
    result[2] = v17;
    result[3] = v18;
    result += 4;
  }
  if ( (i & 8) != 0 )
  {
    v19 = *a2;
    v20 = a2[1];
    a2 += 2;
    *result = v19;
    result[1] = v20;
    result += 2;
  }
  if ( __CFSHL__(i, 30) )
    *result++ = *a2;
  if ( i << 30 )
    result = (int *)memcpy_lastbytes_aligned();
  return result;
}
// 80004E6: using guessed type int memcpy_lastbytes_aligned(void);

//----- (080004E6) --------------------------------------------------------
_WORD *__fastcall memcpy_lastbytes_aligned(_WORD *result, __int16 *a2, int a3, __int16 a4)
{
  bool v4; // cf
  bool v5; // nf
  int v6; // r2
  __int16 v7; // t1

  v4 = __CFSHL__(a3, 31);
  v6 = a3 << 31;
  v5 = v6 < 0;
  if ( v4 )
  {
    v7 = *a2++;
    a4 = v7;
  }
  if ( v6 < 0 )
    LOBYTE(v6) = *(_BYTE *)a2;
  if ( v4 )
    *result++ = a4;
  if ( v5 )
  {
    *(_BYTE *)result = v6;
    result = (_WORD *)((char *)result + 1);
  }
  return result;
}

//----- (08000502) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12> memset(int a1, int a2, int c)
{
  memset(
    (void *)a1,
    c,
    (unsigned __int8)a2 | ((unsigned __int8)a2 << 8) | (((unsigned __int8)a2 | ((unsigned __int8)a2 << 8)) << 16));
}

//----- (0800051C) --------------------------------------------------------
void *memset(void *s, int c, size_t n)
{
  int v3; // r12
  char *v4; // r0

  if ( (unsigned int)c < 4 )
  {
    if ( __CFSHL__(c, 31) )
    {
      *(_BYTE *)s = n;
      v4 = (char *)s + 1;
      *v4 = n;
      s = v4 + 1;
    }
    if ( (c & 1) != 0 )
    {
      *(_BYTE *)s = n;
      s = (char *)s + 1;
    }
  }
  else
  {
    if ( ((unsigned __int8)s & 3) != 0 )
    {
      v3 = 4 - ((unsigned __int8)s & 3);
      if ( v3 != 2 )
      {
        *(_BYTE *)s = n;
        s = (char *)s + 1;
      }
      if ( v3 >= 2 )
      {
        *(_WORD *)s = n;
        s = (char *)s + 2;
      }
      c -= v3;
    }
    s = memset_w(s, c, (unsigned __int16)n);
  }
  return s;
}

//----- (08000560) --------------------------------------------------------
_DWORD *__fastcall memset_w(_DWORD *result, unsigned int a2, int a3)
{
  bool v3; // cf
  unsigned int v4; // r1
  _DWORD *v5; // r0
  int v6; // r1
  int v7; // r1

  v3 = a2 >= 0x20;
  v4 = a2 - 32;
  do
  {
    if ( !v3 )
      break;
    *result = a3;
    result[1] = a3;
    result[2] = a3;
    result[3] = a3;
    v5 = result + 4;
    *v5 = a3;
    v5[1] = a3;
    v5[2] = a3;
    v5[3] = a3;
    result = v5 + 4;
    v3 = v4 >= 0x20;
    v4 -= 32;
  }
  while ( v3 );
  v3 = __CFSHL__(v4, 28);
  v6 = v4 << 28;
  if ( v3 )
  {
    *result = a3;
    result[1] = a3;
    result[2] = a3;
    result[3] = a3;
    result += 4;
  }
  if ( v6 < 0 )
  {
    *result = a3;
    result[1] = a3;
    result += 2;
  }
  v3 = __CFSHL__(v6, 2);
  v7 = 4 * v6;
  if ( v3 )
    *result++ = a3;
  if ( v7 )
  {
    if ( v7 < 0 )
    {
      *(_WORD *)result = a3;
      result = (_DWORD *)((char *)result + 2);
    }
    if ( (v7 & 0x40000000) != 0 )
    {
      *(_BYTE *)result = a3;
      result = (_DWORD *)((char *)result + 1);
    }
  }
  return result;
}

//----- (080005B0) --------------------------------------------------------
void *_rt_heap_descriptor()
{
  return &unk_200001C4;
}

//----- (080005C0) --------------------------------------------------------
int _Heap_Full()
{
  return 0;
}
// 80005C8: returning address of temporary local variable '%var_10'

//----- (080005E2) --------------------------------------------------------
int _Heap_Broken()
{
  return _rt_SIGRTMEM(1);
}

//----- (080005E8) --------------------------------------------------------
_DWORD *__fastcall init_alloc(int a1, unsigned int a2, int a3, int a4)
{
  _DWORD *v4; // r5
  unsigned int v5; // r4
  _DWORD *v6; // r0
  _DWORD **v7; // r7
  _DWORD *result; // r0

  v4 = (_DWORD *)a1;
  v5 = a2;
  if ( a1 + 16 > a2 )
  {
    _rt_SIGRTMEM(0);
    if ( a4 != v5 )
      v4 = (_DWORD *)a4;
    v5 = a4;
  }
  v6 = _rt_heap_descriptor();
  *v6 = v4;
  v7 = (_DWORD **)v6;
  result = _Heap_Initialize(v4);
  if ( (_DWORD *)v5 != v4 + 4 )
    result = _Heap_ProvideMemory(*v7, v4 + 4, v5 - (_DWORD)(v4 + 4));
  return result;
}

//----- (08000646) --------------------------------------------------------
_DWORD *__fastcall _Heap_Initialize(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = result;
  return result;
}

//----- (08000650) --------------------------------------------------------
int _Heap_DescSize()
{
  return 16;
}

//----- (08000654) --------------------------------------------------------
void *_user_perthread_libspace()
{
  return &_libspace_start;
}

//----- (0800065C) --------------------------------------------------------
_DWORD *__fastcall _Heap_ProvideMemory(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // r3
  _DWORD *i; // r0
  bool v5; // cf

  v3 = a1;
  for ( i = (_DWORD *)a1[1]; ; i = (_DWORD *)i[1] )
  {
    v5 = 1;
    if ( i )
      v5 = i >= a2;
    if ( v5 )
      break;
    v3 = i;
  }
  if ( (_DWORD *)((char *)v3 + *v3) != a2 )
  {
    a3 -= (((unsigned int)a2 + 3) & 0xFFFFFFF8) + 4 - (_DWORD)a2;
    a2 = (_DWORD *)((((unsigned int)a2 + 3) & 0xFFFFFFF8) + 4);
  }
  *a2 = a3;
  return free((int)(a2 + 1));
}

//----- (08000690) --------------------------------------------------------
int __fastcall _rt_SIGRTMEM(int a1)
{
  int v1; // r0

  v1 = _rt_SIGRTMEM_inner(a1);
  return _sig_exit(v1);
}

//----- (080006A0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *_user_setup_stackheap()
{
  void *result; // r0
  _DWORD *v1; // [sp-8h] [bp-8h]

  v1 = _user_perthread_libspace();
  result = _user_initial_stackheap();
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = 0;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0;
  v1[9] = 0;
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  v1[13] = 0;
  v1[14] = 0;
  v1[15] = 0;
  return result;
}
// 80006B6: positive sp value 60 has been found

//----- (080006EA) --------------------------------------------------------
void __fastcall __noreturn exit(int a1)
{
  _rt_exit(a1);
}
// 80001C6: using guessed type int __fastcall _rt_exit(_DWORD);

//----- (080006FC) --------------------------------------------------------
int __fastcall _sig_exit(int error_code)
{
  if ( error_code )
    sys_exit(error_code);
  return error_code;
}

//----- (08000708) --------------------------------------------------------
int __fastcall _rt_SIGRTMEM_inner(int a1)
{
  char *v1; // r1

  if ( a1 == 1 )
    v1 = ": Heap memory corrupted";
  else
    v1 = 0;
  _default_signal_display("SIGRTMEM: Out of heap memory", v1);
  return 1;
}

//----- (08000758) --------------------------------------------------------
int __noreturn sys_exit(int error_code)
{
  __breakpoint(171);
  while ( 1 )
    ;
}

//----- (08000764) --------------------------------------------------------
int __fastcall _default_signal_display(_BYTE *a1, _BYTE *a2)
{
  while ( 1 )
  {
    ttywrch();
    if ( !a1 || !*a1 )
      break;
    ++a1;
  }
  while ( a2 && *a2 )
  {
    ++a2;
    ttywrch();
  }
  return ttywrch();
}

//----- (08000796) --------------------------------------------------------
int ttywrch()
{
  int result; // r0

  result = 3;
  __breakpoint(171);
  return result;
}

//----- (080007A4) --------------------------------------------------------
crc32_t __fastcall _Ven_TT_L__advance_software_protect_crc32(uint8_t *buffer, size_t size, int a3, uint32_t a4)
{
  return advance_software_protect_crc32(buffer, size, a3, a4);
}

//----- (080007AE) --------------------------------------------------------
void __fastcall _Ven_TT_L__advance_software_protect_encrypt_process(void *data, size_t size, uint64_t key, int isEnc)
{
  advance_software_protect_encrypt_process(data, size, key, isEnc);
}

//----- (080007B8) --------------------------------------------------------
void _Ven_TT_L__advance_software_protect_system_reset()
{
  advance_software_protect_system_reset();
}

//----- (080007C2) --------------------------------------------------------
bool _Ven_TT_L__advance_software_protect_verify_authorization()
{
  return advance_software_protect_verify_authorization();
}

//----- (080007CC) --------------------------------------------------------
int _Ven_TT_L__advance_software_protect_flash_verify()
{
  return advance_software_protect_flash_verify();
}

//----- (080007D6) --------------------------------------------------------
void __fastcall _Ven_TT_L__advance_software_protect_anti_debugger(AntiDebuggerCallback eventCallback)
{
  advance_software_protect_anti_debugger(eventCallback);
}

//----- (080007E4) --------------------------------------------------------
int __fastcall FLASH_OB_DisableWRP(uint32_t WriteProtectPage)
{
  int v1; // r7
  int v2; // r6
  int v3; // r5
  uint32_t v4; // r4
  int result; // r0

  v1 = (unsigned __int8)(MEMORY[0x40022020] | WriteProtectPage);
  v2 = (unsigned __int8)((unsigned __int16)(MEMORY[0x40022020] | WriteProtectPage) >> 8);
  v3 = (unsigned __int8)((MEMORY[0x40022020] | WriteProtectPage) >> 16);
  v4 = (MEMORY[0x40022020] | WriteProtectPage) >> 24;
  result = FLASH_WaitForLastOperation(0xC350u);
  if ( !result )
  {
    pFlash.ErrorCode = 0;
    result = HAL_FLASHEx_OBErase();
    if ( !result )
    {
      MEMORY[0x40022010] |= 0x10u;
      if ( v1 == 255 || (MEMORY[0x1FFFF808] |= v1, (result = FLASH_WaitForLastOperation(0xC350u)) == 0) )
      {
        if ( v2 == 255 || (MEMORY[0x1FFFF80A] |= v2, (result = FLASH_WaitForLastOperation(0xC350u)) == 0) )
        {
          if ( v3 == 255 || (MEMORY[0x1FFFF80C] |= v3, (result = FLASH_WaitForLastOperation(0xC350u)) == 0) )
          {
            if ( v4 != 255 )
            {
              MEMORY[0x1FFFF80E] |= v4;
              result = FLASH_WaitForLastOperation(0xC350u);
            }
          }
        }
      }
      MEMORY[0x40022010] &= 0xFFFFFFEF;
    }
  }
  return result;
}

//----- (08000894) --------------------------------------------------------
int __fastcall FLASH_OB_EnableWRP(uint32_t WriteProtectPage)
{
  uint32_t v1; // r1
  int v2; // r7
  int v3; // r6
  int v4; // r5
  uint32_t v5; // r4
  int result; // r0

  v1 = MEMORY[0x40022020] & ~WriteProtectPage;
  v2 = (unsigned __int8)v1;
  v3 = BYTE1(v1);
  v4 = BYTE2(v1);
  v5 = HIBYTE(v1);
  result = FLASH_WaitForLastOperation(0xC350u);
  if ( !result )
  {
    pFlash.ErrorCode = 0;
    result = HAL_FLASHEx_OBErase();
    if ( !result )
    {
      MEMORY[0x40022010] |= 0x10u;
      if ( v2 == 255 || (MEMORY[0x1FFFF808] &= v2, (result = FLASH_WaitForLastOperation(0xC350u)) == 0) )
      {
        if ( v3 == 255 || (MEMORY[0x1FFFF80A] &= v3, (result = FLASH_WaitForLastOperation(0xC350u)) == 0) )
        {
          if ( v4 == 255 || (MEMORY[0x1FFFF80C] &= v4, (result = FLASH_WaitForLastOperation(0xC350u)) == 0) )
          {
            if ( v5 != 255 )
            {
              MEMORY[0x1FFFF80E] &= v5;
              result = FLASH_WaitForLastOperation(0xC350u);
            }
          }
        }
      }
      MEMORY[0x40022010] &= 0xFFFFFFEF;
    }
  }
  return result;
}

//----- (08000944) --------------------------------------------------------
uint32_t FLASH_OB_GetRDP()
{
  uint32_t result; // r0

  result = 165;
  if ( (MEMORY[0x4002201C] & 2) == 2 )
    result = 0;
  return result;
}

//----- (0800095C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
HAL_StatusTypeDef __fastcall FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel)
{
  __int16 v1; // r6
  int v2; // r0

  v1 = ReadProtectLevel;
  v2 = FLASH_WaitForLastOperation(0xC350u);
  if ( !v2 )
  {
    pFlash.ErrorCode = 0;
    MEMORY[0x40022010] |= 0x20u;
    MEMORY[0x40022010] |= 0x40u;
    v2 = FLASH_WaitForLastOperation(0xC350u);
    MEMORY[0x40022010] &= 0xFFFFFFDF;
    if ( !v2 )
    {
      MEMORY[0x40022010] |= 0x10u;
      MEMORY[0x1FFFF800] = v1;
      LOBYTE(v2) = FLASH_WaitForLastOperation(0xC350u);
      MEMORY[0x40022010] &= 0xFFFFFFEF;
    }
  }
  return (char)v2;
}
// 800095C: variables would overlap: r0.1 and r0.2

//----- (080009C0) --------------------------------------------------------
void FLASH_SetErrorCode()
{
  unsigned int v0; // r1

  v0 = 0;
  if ( (MEMORY[0x4002200C] & 0x10) != 0 || (MEMORY[0x4002204C] & 0x10) != 0 )
  {
    pFlash.ErrorCode |= 2u;
    v0 = 1048592;
  }
  if ( (MEMORY[0x4002200C] & 4) != 0 || (MEMORY[0x4002204C] & 4) != 0 )
  {
    pFlash.ErrorCode |= 1u;
    v0 |= 0x40004u;
  }
  if ( MEMORY[0x4002201C] << 31 )
  {
    pFlash.ErrorCode |= 4u;
    MEMORY[0x4002201C] &= 0xFFFFFFFE;
  }
  if ( (v0 & 0x35) != 0 )
    MEMORY[0x4002200C] = v0 & 0x35;
  if ( HIWORD(v0) )
    MEMORY[0x4002204C] = HIWORD(v0);
}
// 8000A12: conditional instruction was optimized away because of 'r1.4 in (==0|>=40004u)'

//----- (08000A3C) --------------------------------------------------------
HAL_StatusTypeDef __fastcall FLASH_WaitForLastOperation(uint32_t Timeout)
{
  uint32_t v2; // r6

  v2 = HAL_GetTick();
  while ( MEMORY[0x4002200C] << 31 )
  {
    if ( Timeout != -1 && (!Timeout || HAL_GetTick() - v2 > Timeout) )
      return 3;
  }
  if ( (MEMORY[0x4002200C] & 0x20) != 0 )
    MEMORY[0x4002200C] = 32;
  if ( (MEMORY[0x4002200C] & 0x10) == 0 && !(MEMORY[0x4002201C] << 31) && (MEMORY[0x4002200C] & 4) == 0 )
    return 0;
  FLASH_SetErrorCode();
  return 1;
}

//----- (08000A90) --------------------------------------------------------
uint32_t __fastcall HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength)
{
  uint32_t i; // r3
  uint32_t v4; // r1

  hcrc->State = HAL_CRC_STATE_BUSY;
  for ( i = 0; i < BufferLength; ++i )
    hcrc->Instance->DR = pBuffer[i];
  v4 = hcrc->Instance->DR;
  hcrc->State = HAL_CRC_STATE_READY;
  return v4;
}

//----- (08000AB6) --------------------------------------------------------
uint32_t __fastcall HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength)
{
  uint32_t i; // r3
  uint32_t v4; // r1

  hcrc->State = HAL_CRC_STATE_BUSY;
  hcrc->Instance->CR |= 1u;
  for ( i = 0; i < BufferLength; ++i )
    hcrc->Instance->DR = pBuffer[i];
  v4 = hcrc->Instance->DR;
  hcrc->State = HAL_CRC_STATE_READY;
  return v4;
}

//----- (08000AE4) --------------------------------------------------------
HAL_StatusTypeDef __fastcall HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
  if ( !hcrc )
    return 1;
  if ( hcrc->State == HAL_CRC_STATE_RESET )
  {
    hcrc->Lock = HAL_UNLOCKED;
    HAL_CRC_MspInit(hcrc);
  }
  hcrc->State = HAL_CRC_STATE_READY;
  return 0;
}

//----- (08000B08) --------------------------------------------------------
void __fastcall HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  if ( hcrc->Instance == (CRC_TypeDef *)1073885184 )
    MEMORY[0x40021014] |= 0x40u;
}

//----- (08000B30) --------------------------------------------------------
int HAL_FLASHEx_OBErase()
{
  uint8_t v0; // r5
  int result; // r0

  v0 = FLASH_OB_GetRDP();
  result = FLASH_WaitForLastOperation(0xC350u);
  if ( !result )
  {
    pFlash.ErrorCode = 0;
    MEMORY[0x40022010] |= 0x20u;
    MEMORY[0x40022010] |= 0x40u;
    result = FLASH_WaitForLastOperation(0xC350u);
    MEMORY[0x40022010] &= 0xFFFFFFDF;
    if ( !result )
      result = FLASH_OB_RDP_LevelConfig(v0);
  }
  return result;
}

//----- (08000B84) --------------------------------------------------------
void __fastcall HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
  pOBInit->OptionType = 7;
  pOBInit->WRPPage = MEMORY[0x40022020];
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
  pOBInit->USERConfig = (MEMORY[0x4002201C] >> 2) & 0xF;
}

//----- (08000BA8) --------------------------------------------------------
HAL_StatusTypeDef __fastcall HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
  FLASH_OBProgramInitTypeDef *v1; // r4
  uint32_t v2; // r0
  __int16 v3; // r8
  _WORD *v4; // r8
  __int16 v5; // r4

  v1 = pOBInit;
  LOBYTE(pOBInit) = 1;
  if ( pFlash.Lock == HAL_LOCKED )
  {
    LOBYTE(pOBInit) = 2;
  }
  else
  {
    pFlash.Lock = HAL_LOCKED;
    if ( !(LOBYTE(v1->OptionType) << 31)
      || ((v2 = v1->WRPPage, v1->WRPState == 1) ? (pOBInit = (FLASH_OBProgramInitTypeDef *)FLASH_OB_EnableWRP(v2)) : (pOBInit = (FLASH_OBProgramInitTypeDef *)FLASH_OB_DisableWRP(v2)),
          !pOBInit) )
    {
      if ( (v1->OptionType & 2) == 0
        || (pOBInit = (FLASH_OBProgramInitTypeDef *)FLASH_OB_RDP_LevelConfig(v1->RDPLevel)) == 0 )
      {
        if ( (v1->OptionType & 4) == 0 )
          goto LABEL_22;
        v3 = v1->USERConfig;
        pOBInit = (FLASH_OBProgramInitTypeDef *)FLASH_WaitForLastOperation(0xC350u);
        if ( !pOBInit )
        {
          pFlash.ErrorCode = 0;
          MEMORY[0x40022010] |= 0x10u;
          MEMORY[0x1FFFF802] = v3 | 0xF0;
          pOBInit = (FLASH_OBProgramInitTypeDef *)FLASH_WaitForLastOperation(0xC350u);
          MEMORY[0x40022010] &= 0xFFFFFFEF;
        }
        if ( !pOBInit )
        {
LABEL_22:
          if ( (v1->OptionType & 8) != 0 )
          {
            v4 = (_WORD *)v1->DATAAddress;
            v5 = v1->DATAData;
            pOBInit = (FLASH_OBProgramInitTypeDef *)FLASH_WaitForLastOperation(0xC350u);
            if ( !pOBInit )
            {
              pFlash.ErrorCode = 0;
              MEMORY[0x40022010] |= 0x10u;
              *v4 = v5;
              LOBYTE(pOBInit) = FLASH_WaitForLastOperation(0xC350u);
              MEMORY[0x40022010] &= 0xFFFFFFEF;
            }
          }
        }
      }
    }
    pFlash.Lock = HAL_UNLOCKED;
  }
  return (char)pOBInit;
}

//----- (08000C70) --------------------------------------------------------
int HAL_FLASH_Lock()
{
  MEMORY[0x40022010] |= 0x80u;
  MEMORY[0x40022050] |= 0x80u;
  return 0;
}

//----- (08000C8C) --------------------------------------------------------
int HAL_FLASH_OB_Lock()
{
  MEMORY[0x40022010] &= 0xFFFFFDFF;
  return 0;
}

//----- (08000CA0) --------------------------------------------------------
int HAL_FLASH_OB_Unlock()
{
  if ( (MEMORY[0x40022010] & 0x200) != 0 )
    return 1;
  MEMORY[0x40022008] = -839939669;
  return 0;
}

//----- (08000CC4) --------------------------------------------------------
int HAL_FLASH_Unlock()
{
  int result; // r0

  result = 0;
  if ( (MEMORY[0x40022010] & 0x80) != 0 )
  {
    MEMORY[0x40022004] = -839939669;
    if ( (MEMORY[0x40022010] & 0x80) != 0 )
      result = 1;
  }
  if ( (MEMORY[0x40022050] & 0x80) != 0 )
  {
    MEMORY[0x40022044] = -839939669;
    if ( (MEMORY[0x40022050] & 0x80) != 0 )
      result = 1;
  }
  return result;
}

//----- (08000D00) --------------------------------------------------------
void __fastcall HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  int v2; // r4
  uint32_t v3; // r3
  volatile uint32_t v4; // r5
  uint32_t v5; // r2
  signed int v6; // r6
  uint32_t v7; // r3
  bool v8; // zf
  GPIO_TypeDef *v9; // r6
  char v10; // r5
  int v11; // r8
  int v12; // r6
  int v13; // r6
  int v14; // r6
  int v15; // r6

  v2 = 0;
  v3 = 0;
  while ( GPIO_Init->Pin >> v2 )
  {
    v4 = 1 << v2;
    v5 = GPIO_Init->Pin & (1 << v2);
    if ( v5 != 1 << v2 )
      goto LABEL_63;
    v6 = GPIO_Init->Mode;
    if ( v6 == 269549568 )
      goto LABEL_24;
    if ( v6 <= 269549568 )
    {
      if ( v6 == 3 )
      {
        v3 = 0;
        goto LABEL_30;
      }
      if ( v6 > 3 )
      {
        if ( v6 == 17 )
        {
          v3 = GPIO_Init->Speed + 4;
        }
        else if ( v6 == 18 )
        {
          v3 = GPIO_Init->Speed + 12;
        }
        goto LABEL_30;
      }
      if ( v6 )
      {
        if ( v6 == 1 )
        {
          v3 = GPIO_Init->Speed;
        }
        else if ( v6 == 2 )
        {
          v3 = GPIO_Init->Speed + 8;
        }
        goto LABEL_30;
      }
LABEL_24:
      v7 = GPIO_Init->Pull;
      if ( v7 )
      {
        v8 = v7 == 1;
        v3 = 8;
        if ( v8 )
          GPIOx->BSRR = v4;
        else
          GPIOx->BRR = v4;
      }
      else
      {
        v3 = 4;
      }
      goto LABEL_30;
    }
    if ( v6 == 270663680 )
      goto LABEL_24;
    if ( v6 - 269549568 > 1114112 )
    {
      if ( v6 == 271646720 || v6 == 271712256 )
        goto LABEL_24;
    }
    else if ( v6 == 269615104 || v6 == 270598144 )
    {
      goto LABEL_24;
    }
LABEL_30:
    if ( v5 > 0xFF )
      v9 = (GPIO_TypeDef *)&GPIOx->CRH;
    else
      v9 = GPIOx;
    v10 = 4 * v2;
    if ( v5 > 0xFF )
      v10 -= 32;
    v9->CRL = v9->CRL & ~(15 << v10) | (v3 << v10);
    if ( (GPIO_Init->Mode & 0x10000000) != 0 )
    {
      MEMORY[0x40021018] |= 1u;
      if ( GPIOx == (GPIO_TypeDef *)1073809408 )
      {
        v11 = 0;
      }
      else if ( GPIOx == (GPIO_TypeDef *)1073810432 )
      {
        v11 = 1;
      }
      else if ( GPIOx == (GPIO_TypeDef *)1073811456 )
      {
        v11 = 2;
      }
      else if ( GPIOx == (GPIO_TypeDef *)1073812480 )
      {
        v11 = 3;
      }
      else if ( GPIOx == (GPIO_TypeDef *)1073813504 )
      {
        v11 = 4;
      }
      else if ( GPIOx == (GPIO_TypeDef *)1073814528 )
      {
        v11 = 5;
      }
      else
      {
        v11 = 6;
      }
      *(_DWORD *)((v2 & 0xFFFFFFFC) + 1073807368) = (v11 << ((4 * v2) & 0xF)) | *(_DWORD *)((v2 & 0xFFFFFFFC)
                                                                                          + 1073807368) & ~(15 << ((4 * v2) & 0xF));
      if ( (GPIO_Init->Mode & 0x10000) != 0 )
        v12 = MEMORY[0x40010400] | v5;
      else
        v12 = MEMORY[0x40010400] & ~v5;
      MEMORY[0x40010400] = v12;
      if ( (GPIO_Init->Mode & 0x20000) != 0 )
        v13 = MEMORY[0x40010404] | v5;
      else
        v13 = MEMORY[0x40010404] & ~v5;
      MEMORY[0x40010404] = v13;
      if ( (GPIO_Init->Mode & 0x100000) != 0 )
        v14 = MEMORY[0x40010408] | v5;
      else
        v14 = MEMORY[0x40010408] & ~v5;
      MEMORY[0x40010408] = v14;
      if ( (GPIO_Init->Mode & 0x200000) != 0 )
        v15 = MEMORY[0x4001040C] | v5;
      else
        v15 = MEMORY[0x4001040C] & ~v5;
      MEMORY[0x4001040C] = v15;
    }
LABEL_63:
    ++v2;
  }
}

//----- (08000EF8) --------------------------------------------------------
void __fastcall HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
  if ( PinState == GPIO_PIN_RESET )
    *(_DWORD *)&GPIO_Pin = GPIO_Pin << 16;
  GPIOx->BSRR = GPIO_Pin;
}

//----- (08000F04) --------------------------------------------------------
uint32_t HAL_GetTick()
{
  return uwTick;
}

//----- (08000F10) --------------------------------------------------------
void HAL_IncTick()
{
  uwTick += (unsigned __int8)uwTickFreq;
}

//----- (08000F20) --------------------------------------------------------
int HAL_Init()
{
  MEMORY[0x40022000] |= 0x10u;
  HAL_NVIC_SetPriorityGrouping(3u);
  HAL_InitTick(0xFu);
  HAL_MspInit();
  return 0;
}

//----- (08000F44) --------------------------------------------------------
HAL_StatusTypeDef __fastcall HAL_InitTick(uint32_t TickPriority)
{
  HAL_StatusTypeDef result; // r0

  if ( HAL_SYSTICK_Config(SystemCoreClock / (0x3E8u / (unsigned __int8)uwTickFreq)) || TickPriority >= 0x10 )
    return 1;
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
  result = HAL_OK;
  uwTickPrio = TickPriority;
  return result;
}

//----- (08000F84) --------------------------------------------------------
void HAL_MspInit()
{
  MEMORY[0x40021018] |= 1u;
  MEMORY[0x4002101C] |= 0x10000000u;
  MEMORY[0x40010004] = MEMORY[0x40010004] & 0xF8FFFFFF | 0x2000000;
}

//----- (08000FC0) --------------------------------------------------------
void __fastcall HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  int v3; // r3
  char v4; // r5
  char v5; // r3

  v3 = (MEMORY[0xE000ED0C] >> 8) & 7;
  v4 = 7 - v3;
  if ( (unsigned int)(7 - v3) > 4 )
    v4 = 4;
  if ( (unsigned int)(v3 + 4) >= 7 )
    v5 = v3 - 3;
  else
    v5 = 0;
  _NVIC_SetPriority(IRQn, ((((1 << v4) - 1) & PreemptPriority) << v5) | ((1 << v5) - 1) & SubPriority);
}

//----- (08001004) --------------------------------------------------------
void __fastcall HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  MEMORY[0xE000ED0C] = MEMORY[0xE000ED0C] & 0xF8FF | ((PriorityGroup & 7) << 8) | 0x5FA0000;
}

//----- (08001040) --------------------------------------------------------
HAL_StatusTypeDef __fastcall HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t v4; // r0
  uint32_t v5; // r0
  int v6; // r1
  uint32_t v7; // r8

  if ( !RCC_ClkInitStruct )
    return 1;
  if ( (MEMORY[0x40022000] & 7u) < FLatency )
  {
    MEMORY[0x40022000] = MEMORY[0x40022000] & 0xFFFFFFF8 | FLatency;
    if ( (MEMORY[0x40022000] & 7) != FLatency )
      return 1;
  }
  v4 = RCC_ClkInitStruct->ClockType;
  if ( (RCC_ClkInitStruct->ClockType & 2) != 0 )
  {
    if ( (v4 & 4) != 0 )
      MEMORY[0x40021004] |= 0x700u;
    if ( (RCC_ClkInitStruct->ClockType & 8) != 0 )
      MEMORY[0x40021004] |= 0x3800u;
    MEMORY[0x40021004] = MEMORY[0x40021004] & 0xFFFFFF0F | RCC_ClkInitStruct->AHBCLKDivider;
  }
  if ( LOBYTE(RCC_ClkInitStruct->ClockType) << 31 )
  {
    v5 = RCC_ClkInitStruct->SYSCLKSource;
    if ( v5 == 1 )
    {
      v6 = MEMORY[0x40021000] << 14;
    }
    else if ( v5 == 2 )
    {
      v6 = MEMORY[0x40021000] << 6;
    }
    else
    {
      v6 = MEMORY[0x40021000] << 30;
    }
    if ( v6 >= 0 )
      return 1;
    MEMORY[0x40021004] = MEMORY[0x40021004] & 0xFFFFFFFC | v5;
    v7 = HAL_GetTick();
    while ( (MEMORY[0x40021004] & 0xC) != 4 * RCC_ClkInitStruct->SYSCLKSource )
    {
      if ( HAL_GetTick() - v7 > 0x1388 )
        return 3;
    }
  }
  if ( (MEMORY[0x40022000] & 7u) > FLatency )
  {
    MEMORY[0x40022000] = MEMORY[0x40022000] & 0xFFFFFFF8 | FLatency;
    if ( (MEMORY[0x40022000] & 7) != FLatency )
      return 1;
  }
  if ( (RCC_ClkInitStruct->ClockType & 4) != 0 )
    MEMORY[0x40021004] = MEMORY[0x40021004] & 0xFFFFF8FF | RCC_ClkInitStruct->APB1CLKDivider;
  if ( (RCC_ClkInitStruct->ClockType & 8) != 0 )
    MEMORY[0x40021004] = MEMORY[0x40021004] & 0xFFFFC7FF | (8 * RCC_ClkInitStruct->APB2CLKDivider);
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[MEMORY[0x40021004] >> 4];
  HAL_InitTick(uwTickPrio);
  return 0;
}

//----- (0800116C) --------------------------------------------------------
uint32_t HAL_RCC_GetPCLK1Freq()
{
  return SystemCoreClock >> APBPrescTable[(MEMORY[0x40021004] >> 8) & 7];
}

//----- (0800118C) --------------------------------------------------------
uint32_t HAL_RCC_GetPCLK2Freq()
{
  return SystemCoreClock >> APBPrescTable[(MEMORY[0x40021004] >> 11) & 7];
}

//----- (080011AC) --------------------------------------------------------
uint32_t HAL_RCC_GetSysClockFreq()
{
  uint32_t result; // r0
  int v1; // r0
  uint8_t aPLLMULFactorTable[16]; // [sp+0h] [bp-14h]
  int aPredivFactorTable; // [sp+10h] [bp-4h]

  *(_DWORD *)aPLLMULFactorTable = 84148994;
  *(_DWORD *)&aPLLMULFactorTable[4] = 151521030;
  *(_DWORD *)&aPLLMULFactorTable[8] = 218893066;
  *(_DWORD *)&aPLLMULFactorTable[12] = 269487886;
  aPredivFactorTable = 513;
  result = 8000000;
  if ( (MEMORY[0x40021004] & 0xC) != 4 && (MEMORY[0x40021004] & 0xC) == 8 )
  {
    v1 = aPLLMULFactorTable[(MEMORY[0x40021004] >> 18) & 0xF];
    if ( (MEMORY[0x40021004] & 0x10000) != 0 )
      result = 8000000 * v1 / (unsigned int)*((unsigned __int8 *)&aPredivFactorTable + ((MEMORY[0x40021004] >> 17) & 1));
    else
      result = 4000000 * v1;
  }
  return result;
}

//----- (08001218) --------------------------------------------------------
HAL_StatusTypeDef __fastcall HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct)
{
  bool v1; // zf
  uint32_t v3; // r0
  uint32_t v4; // r0
  unsigned int v5; // r0
  uint32_t v6; // r6
  bool v7; // cc
  unsigned int v8; // r0
  uint32_t v9; // r7
  unsigned int v10; // r0
  uint32_t v11; // r7
  uint32_t v12; // r7
  uint32_t v14; // r7
  int v15; // r7
  uint32_t v16; // r10
  uint32_t v17; // r0
  unsigned int v18; // r0
  uint32_t v19; // r10
  uint32_t v20; // r10
  uint32_t v21; // r0
  uint32_t v22; // r4
  uint32_t v23; // r7
  uint32_t v24; // r4
  uint32_t tmpreg; // [sp+0h] [bp-28h]

  v1 = RCC_OscInitStruct == 0;
  while ( 1 )
  {
    if ( v1 )
      goto LABEL_99;
    if ( !(LOBYTE(RCC_OscInitStruct->OscillatorType) << 31) )
      goto LABEL_25;
    if ( ((MEMORY[0x40021004] >> 2) & 3) != 1
      && (((MEMORY[0x40021004] >> 2) & 3) != 2 || (MEMORY[0x40021004] & 0x10000) == 0) )
    {
      break;
    }
    if ( (MEMORY[0x40021000] & 0x20000) != 0 )
    {
      v3 = RCC_OscInitStruct->HSEState;
      v1 = v3 == 0;
      if ( !v3 )
        continue;
    }
    goto LABEL_25;
  }
  v4 = RCC_OscInitStruct->HSEState;
  if ( v4 != 0x10000 )
  {
    if ( !v4 || v4 != 327680 )
    {
      MEMORY[0x40021000] &= 0xFFFEFFFF;
      v5 = MEMORY[0x40021000] & 0xFFFBFFFF;
      goto LABEL_15;
    }
    MEMORY[0x40021000] |= 0x40000u;
  }
  v5 = MEMORY[0x40021000] | 0x10000;
LABEL_15:
  MEMORY[0x40021000] = v5;
  if ( RCC_OscInitStruct->HSEState )
  {
    v6 = HAL_GetTick();
    goto LABEL_20;
  }
  v6 = HAL_GetTick();
  while ( (MEMORY[0x40021000] & 0x20000) != 0 )
  {
    v8 = HAL_GetTick() - v6;
    v7 = v8 > 0x64;
    if ( v8 > 0x64 )
      goto LABEL_19;
  }
LABEL_25:
  v6 = 1111621632;
  if ( (RCC_OscInitStruct->OscillatorType & 2) != 0 )
  {
    if ( (MEMORY[0x40021004] & 0xC) == 0 || ((MEMORY[0x40021004] >> 2) & 3) == 2 && (MEMORY[0x40021004] & 0x10000) == 0 )
    {
      if ( (MEMORY[0x40021000] & 2) != 0 && RCC_OscInitStruct->HSIState != 1 )
        goto LABEL_99;
      goto LABEL_37;
    }
    if ( RCC_OscInitStruct->HSIState )
    {
      MEMORY[0x42420000] = 1;
      v9 = HAL_GetTick();
      while ( (MEMORY[0x40021000] & 2) == 0 )
      {
        v10 = HAL_GetTick() - v9;
        v7 = v10 > 2;
        if ( v10 > 2 )
        {
LABEL_19:
          while ( !v7 )
          {
LABEL_20:
            if ( (MEMORY[0x40021000] & 0x20000) != 0 )
              goto LABEL_25;
            v7 = HAL_GetTick() - v6 > 0x64;
          }
          goto LABEL_92;
        }
      }
LABEL_37:
      MEMORY[0x40021000] = MEMORY[0x40021000] & 0xFFFFFF07 | (8 * RCC_OscInitStruct->HSICalibrationValue);
      goto LABEL_41;
    }
    MEMORY[0x42420000] = 0;
    v11 = HAL_GetTick();
    while ( (MEMORY[0x40021000] & 2) != 0 )
    {
      if ( HAL_GetTick() - v11 > 2 )
      {
LABEL_92:
        LOBYTE(v21) = 3;
        return (char)v21;
      }
    }
  }
LABEL_41:
  if ( (RCC_OscInitStruct->OscillatorType & 8) != 0 )
  {
    if ( RCC_OscInitStruct->LSIState )
    {
      MEMORY[0x42420480] = 1;
      v12 = HAL_GetTick();
      while ( (MEMORY[0x40021024] & 2) == 0 )
      {
        if ( HAL_GetTick() - v12 > 2 )
          goto LABEL_92;
      }
      tmpreg = SystemCoreClock / 0x1F40;
      while ( tmpreg-- != 0 )
        ;
    }
    else
    {
      MEMORY[0x42420480] = 0;
      v14 = HAL_GetTick();
      while ( (MEMORY[0x40021024] & 2) != 0 )
      {
        if ( HAL_GetTick() - v14 > 2 )
          goto LABEL_92;
      }
    }
  }
  if ( (RCC_OscInitStruct->OscillatorType & 4) != 0 )
  {
    v15 = 0;
    if ( (MEMORY[0x4002101C] & 0x10000000) == 0 )
    {
      MEMORY[0x4002101C] |= 0x10000000u;
      v15 = 1;
    }
    if ( (MEMORY[0x40007000] & 0x100) == 0 )
    {
      MEMORY[0x40007000] |= 0x100u;
      v16 = HAL_GetTick();
      while ( (MEMORY[0x40007000] & 0x100) == 0 )
      {
        if ( HAL_GetTick() - v16 > 0x64 )
          goto LABEL_92;
      }
    }
    v17 = RCC_OscInitStruct->LSEState;
    if ( v17 != 1 )
    {
      if ( !v17 || v17 != 5 )
      {
        MEMORY[0x40021020] &= 0xFFFFFFFE;
        v18 = MEMORY[0x40021020] & 0xFFFFFFFB;
LABEL_65:
        MEMORY[0x40021020] = v18;
        if ( RCC_OscInitStruct->LSEState )
        {
          v19 = HAL_GetTick();
          while ( (MEMORY[0x40021020] & 2) == 0 )
          {
            if ( HAL_GetTick() - v19 > 0x1388 )
              goto LABEL_92;
          }
        }
        else
        {
          v20 = HAL_GetTick();
          while ( (MEMORY[0x40021020] & 2) != 0 )
          {
            if ( HAL_GetTick() - v20 > 0x1388 )
              goto LABEL_92;
          }
        }
        if ( v15 )
          MEMORY[0x4002101C] &= 0xEFFFFFFF;
        goto LABEL_76;
      }
      MEMORY[0x40021020] |= 4u;
    }
    v18 = MEMORY[0x40021020] | 1;
    goto LABEL_65;
  }
LABEL_76:
  v21 = RCC_OscInitStruct->PLL.PLLState;
  if ( v21 )
  {
    if ( ((MEMORY[0x40021004] >> 2) & 3) != 2 )
    {
      MEMORY[0x42420060] = 0;
      if ( v21 == 2 )
      {
        v23 = HAL_GetTick();
        while ( (MEMORY[0x40021000] & 0x2000000) != 0 )
        {
          if ( HAL_GetTick() - v23 > 2 )
            goto LABEL_92;
        }
        if ( RCC_OscInitStruct->PLL.PLLSource == 0x10000 )
          MEMORY[0x40021004] = MEMORY[0x40021004] & 0xFFFDFFFF | RCC_OscInitStruct->HSEPredivValue;
        MEMORY[0x40021004] = RCC_OscInitStruct->PLL.PLLSource | RCC_OscInitStruct->PLL.PLLMUL | MEMORY[0x40021004] & 0xFFC2FFFF;
        MEMORY[0x42420060] = 1;
        v24 = HAL_GetTick();
        while ( (MEMORY[0x40021000] & 0x2000000) == 0 )
        {
          if ( HAL_GetTick() - v24 > 2 )
            goto LABEL_92;
        }
      }
      else
      {
        v22 = HAL_GetTick();
        while ( (MEMORY[0x40021000] & 0x2000000) != 0 )
        {
          if ( HAL_GetTick() - v22 > 2 )
            goto LABEL_92;
        }
      }
      goto LABEL_100;
    }
    if ( v21 == 1 )
      return (char)v21;
    if ( (MEMORY[0x40021004] & 0x10000) == RCC_OscInitStruct->PLL.PLLSource
      && (MEMORY[0x40021004] & 0x3C0000) == RCC_OscInitStruct->PLL.PLLMUL )
    {
      goto LABEL_100;
    }
LABEL_99:
    LOBYTE(v21) = 1;
    return (char)v21;
  }
LABEL_100:
  LOBYTE(v21) = 0;
  return (char)v21;
}

//----- (08001538) --------------------------------------------------------
uint32_t __fastcall HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  uint32_t v1; // r0

  v1 = TicksNumb - 1;
  if ( v1 >= 0x1000000 )
    return 1;
  MEMORY[0xE000E014] = v1;
  _NVIC_SetPriority(SysTick_IRQn, 0xFu);
  MEMORY[0xE000E018] = 0;
  MEMORY[0xE000E010] = 7;
  return 0;
}

//----- (08001560) --------------------------------------------------------
HAL_StatusTypeDef __fastcall HAL_UART_Init(UART_HandleTypeDef *huart)
{
  if ( !huart )
    return 1;
  if ( huart->gState == HAL_UART_STATE_RESET )
  {
    huart->Lock = HAL_UNLOCKED;
    HAL_UART_MspInit(huart);
  }
  huart->gState = HAL_UART_STATE_BUSY;
  huart->Instance->CR1 &= 0xFFFFDFFF;
  UART_SetConfig(huart);
  huart->Instance->CR2 &= 0xFFFFB7FF;
  huart->Instance->CR3 &= 0xFFFFFFD5;
  huart->Instance->CR1 |= 0x2000u;
  huart->ErrorCode = 0;
  huart->gState = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;
  return 0;
}

//----- (080015C4) --------------------------------------------------------
void __fastcall HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
  GPIO_InitTypeDef GPIO_InitStruct; // [sp+0h] [bp-20h] BYREF
  uint32_t tmpreg; // [sp+10h] [bp-10h]

  GPIO_InitStruct.Pin = 0;
  GPIO_InitStruct.Mode = 0;
  GPIO_InitStruct.Pull = 0;
  GPIO_InitStruct.Speed = 0;
  if ( huart->Instance == (USART_TypeDef *)1073821696 )
  {
    MEMORY[0x40021018] |= 0x4000u;
    MEMORY[0x40021018] |= 4u;
    tmpreg = MEMORY[0x40021018] & 4;
    GPIO_InitStruct.Pin = 512;
    GPIO_InitStruct.Mode = 2;
    GPIO_InitStruct.Speed = 3;
    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800, &GPIO_InitStruct);
    GPIO_InitStruct.Pin = 1024;
    GPIO_InitStruct.Mode = 0;
    GPIO_InitStruct.Pull = 0;
    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800, &GPIO_InitStruct);
  }
}

//----- (08001634) --------------------------------------------------------
void SystemClock_Config()
{
  RCC_OscInitTypeDef RCC_OscInitStruct; // [sp+0h] [bp-48h] BYREF
  RCC_ClkInitTypeDef RCC_ClkInitStruct; // [sp+28h] [bp-20h] BYREF

  _rt_memclr_w(&RCC_OscInitStruct, 40);
  _rt_memclr_w(&RCC_ClkInitStruct, 20);
  RCC_OscInitStruct.HSIState = 1;
  RCC_OscInitStruct.OscillatorType = 2;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLSource = 0;
  RCC_OscInitStruct.PLL.PLLMUL = 3670016;
  RCC_OscInitStruct.PLL.PLLState = 2;
  if ( HAL_RCC_OscConfig(&RCC_OscInitStruct) )
  {
    __disable_irq();
    while ( 1 )
      ;
  }
  RCC_ClkInitStruct.ClockType = 15;
  RCC_ClkInitStruct.SYSCLKSource = 2;
  RCC_ClkInitStruct.AHBCLKDivider = 0;
  RCC_ClkInitStruct.APB1CLKDivider = 1024;
  RCC_ClkInitStruct.APB2CLKDivider = 0;
  if ( HAL_RCC_ClockConfig(&RCC_ClkInitStruct, 2u) )
  {
    __disable_irq();
    while ( 1 )
      ;
  }
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08001690) --------------------------------------------------------
void __fastcall UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t v2; // r0

  huart->Instance->CR2 = huart->Instance->CR2 & 0xFFFFCFFF | huart->Init.StopBits;
  huart->Instance->CR1 = huart->Instance->CR1 & 0xFFFFE9F3 | huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
  huart->Instance->CR3 = huart->Instance->CR3 & 0xFFFFFCFF | huart->Init.HwFlowCtl;
  if ( huart->Instance == (USART_TypeDef *)1073821696 )
    v2 = HAL_RCC_GetPCLK2Freq();
  else
    v2 = HAL_RCC_GetPCLK1Freq();
  huart->Instance->BRR = (((16 * (25 * v2 / (4 * huart->Init.BaudRate) % 0x64) + 50) / 0x64) & 0xF)
                       + (((16 * (25 * v2 / (4 * huart->Init.BaudRate) % 0x64) + 50) / 0x64) & 0xF0)
                       + 16 * (25 * v2 / (4 * huart->Init.BaudRate) / 0x64);
}

//----- (08001748) --------------------------------------------------------
void __fastcall _NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  char v2; // r1

  v2 = 16 * priority;
  if ( IRQn < WWDG_IRQn )
    *(_BYTE *)((IRQn & 0xF) - 536810220) = v2;
  else
    *(_BYTE *)(IRQn - 536812544) = v2;
}

//----- (08001768) --------------------------------------------------------
bool __fastcall _advance_software_protect_objectwatch_check(void *object_ptr, size_t info_in_object)
{
  uint32_t v2; // r3

  if ( !object_ptr || !info_in_object )
    return 0;
  if ( *((_BYTE *)object_ptr + info_in_object + 1) )
  {
    if ( *(_DWORD *)((char *)object_ptr + info_in_object + 4) != _Ven_TT_L__advance_software_protect_crc32(
                                                                   (uint8_t *)object_ptr,
                                                                   info_in_object,
                                                                   *((unsigned __int8 *)object_ptr + info_in_object + 1),
                                                                   v2) )
      return 0;
  }
  else
  {
    _advance_software_protect_objectwatch_update(object_ptr, info_in_object);
  }
  return 1;
}
// 8001774: variable 'v2' is possibly undefined

//----- (0800178A) --------------------------------------------------------
void __fastcall _advance_software_protect_objectwatch_update(void *object_ptr, size_t info_in_object)
{
  int v2; // r2
  uint32_t v3; // r3
  char *v4; // r4

  if ( object_ptr )
  {
    if ( info_in_object )
    {
      v4 = (char *)object_ptr + info_in_object;
      *((_DWORD *)v4 + 1) = _Ven_TT_L__advance_software_protect_crc32((uint8_t *)object_ptr, info_in_object, v2, v3);
      v4[1] = 1;
    }
  }
}
// 8001796: variable 'v2' is possibly undefined
// 8001796: variable 'v3' is possibly undefined

//----- (080017A2) --------------------------------------------------------
void __fastcall advance_software_protect_ramcode_data_process(uint8_t *buffer, size_t size, uint64_t a3, uint64_t key)
{
  size_t i; // r2
  uint64_t keya[3]; // [sp+8h] [bp-18h]

  keya[0] = a3;
  for ( i = 0; i < size; ++i )
    buffer[i] ^= *((_BYTE *)keya + (i & 7));
}

//----- (080017BE) --------------------------------------------------------
void __fastcall add32(uint32_t *dst, uint32_t src, char *carry)
{
  uint32_t v3; // r3

  v3 = *dst + src;
  *dst = v3;
  *carry += v3 < src;
}

//----- (080017D8) --------------------------------------------------------
void __fastcall add64(mbedtls_mpi_uint *dst, mbedtls_mpi_uint *src, mbedtls_mpi_uint *carry)
{
  unsigned int v3; // r3
  unsigned int v4; // r4
  mbedtls_mpi_uint v5; // r5
  _BOOL4 v6; // r3
  mbedtls_mpi_uint v7; // r5
  _BOOL4 v8; // r5

  v3 = 0;
  LOBYTE(v4) = 0;
  do
  {
    v5 = *dst + v3;
    *dst = v5;
    v6 = v5 < v3;
    v7 = v5 + *src;
    *dst = v7;
    v8 = v7 < *src;
    v4 = (unsigned __int8)(v4 + 1);
    ++dst;
    ++src;
    v3 = v6 + v8;
  }
  while ( v4 < 2 );
  *carry += v3;
}

//----- (08001818) --------------------------------------------------------
void advance_software_protect_dynamic_muti_object_watcher()
{
  unsigned int i; // r4
  void *v1; // r0
  int v2; // r2
  uint32_t v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  uint32_t v7; // r3
  int v8; // r0
  int v9; // r1
  int v10; // r2
  uint32_t v11; // r3

  advance_software_protect_objectwatch_list_set_callback(advance_software_protect_dynamic_muti_object_watcher_callback);
  advance_software_protect_objectwatch_list_add(&m_object, 0x10u, 0);
  advance_software_protect_objectwatch_list_add(&m_aType, 0x14u, 0);
  advance_software_protect_objectwatch_list_add(&m_bType, 0x14u, 0);
  advance_software_protect_objectwatch_list_add(&m_class, 0x20u, 0);
  advance_software_protect_objectwatch_list_add(&m_class, 0x20u, 0);
  advance_software_protect_objectwatch_list_add(0, 0x20u, 0);
  for ( i = 0; i < 0x64; ++i )
  {
    v1 = (void *)malloc(0x20u);
    if ( !v1 )
      break;
    advance_software_protect_objectwatch_list_add(v1, 0x20u, 1);
  }
  advance_software_protect_objectwatch_list_find(&m_aType);
  advance_software_protect_objectwatch_list_check(&m_class);
  m_class._data_.m_a.m_data.m_sample1 ^= 0xABu;
  advance_software_protect_objectwatch_list_check_all((int)&m_class, m_class._data_.m_a.m_data.m_sample1, v2, v3);
  advance_software_protect_objectwatch_list_size();
  v4 = advance_software_protect_objectwatch_list_update(&m_class);
  advance_software_protect_objectwatch_list_check_all(v4, v5, v6, v7);
  v8 = advance_software_protect_objectwatch_list_remove(&m_bType);
  advance_software_protect_objectwatch_list_update_all(v8, v9, v10, v11);
  advance_software_protect_objectwatch_list_reset();
}
// 8001898: variable 'v2' is possibly undefined
// 8001898: variable 'v3' is possibly undefined
// 80018A8: variable 'v5' is possibly undefined
// 80018A8: variable 'v6' is possibly undefined
// 80018A8: variable 'v7' is possibly undefined
// 80018B4: variable 'v9' is possibly undefined
// 80018B4: variable 'v10' is possibly undefined
// 80018B4: variable 'v11' is possibly undefined

//----- (080018C8) --------------------------------------------------------
bool advance_software_protect_flash_verify_check()
{
  return m_flash_verify_r.m_flash_verify_migic_s == 0xACD8961B9BDD2188LL
      && m_flash_verify_r.m_flash_verify_migic_e == 0x39AD096731447C82LL;
}

//----- (08001920) --------------------------------------------------------
int advance_software_protect_flash_verify_init()
{
  int *v0; // r6
  unsigned int v1; // r5
  int result; // r0

  if ( m_flash_verify_r.m_flash_verify_skip_items )
    goto LABEL_6;
  m_flash_verify_r.m_flash_verify_migic_s = 0xACD8961B9BDD2188LL;
  m_flash_verify_r.m_flash_verify_skip_count = 3;
  m_flash_verify_r.m_flash_verify_skip_items = (S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_SKIP_0 *)m_flash_verify_skip_items;
  m_flash_verify_r.m_flash_addr_start = -1;
  m_flash_verify_r.m_flash_addr_end = 0;
  m_flash_verify_r.m_total_crc32 = -1;
  m_flash_verify_r.m_flash_verify_migic_e = 0x39AD096731447C82LL;
  if ( !advance_software_protect_flash_verify_check() )
    _Ven_TT_L__advance_software_protect_encrypt_process((void *)&m_flash_verify_r, 0x24u, 0xFB90FFCB9B62C2E6LL, 0);
  v0 = (int *)m_flash_verify_r.m_flash_verify_skip_items;
  v1 = 8 * m_flash_verify_r.m_flash_verify_skip_count;
  m_flash_verify_r.m_flash_verify_skip_items = (S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_SKIP_0 *)malloc(
                                                                                               8
                                                                                             * m_flash_verify_r.m_flash_verify_skip_count);
  result = (int)m_flash_verify_r.m_flash_verify_skip_items;
  if ( m_flash_verify_r.m_flash_verify_skip_items )
  {
    _rt_memcpy_w((int *)m_flash_verify_r.m_flash_verify_skip_items, v0, v1);
LABEL_6:
    result = 1;
  }
  return result;
}

//----- (08001998) --------------------------------------------------------
bool __fastcall advance_software_protect_objectwatch_list_add(void *object_ptr, size_t object_size, bool del_object_when_remove)
{
  E_ObjectWatchException_0 v6; // r0
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v7; // r0
  int v8; // r2
  uint32_t v9; // r3
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v10; // r4
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v11; // r0

  if ( !object_ptr || !object_size )
  {
    v6 = ObjectParamError;
    goto LABEL_10;
  }
  if ( !advance_software_protect_objectwatch_list_find(object_ptr) )
  {
    v7 = (S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *)malloc(0x14u);
    v10 = v7;
    if ( v7 )
    {
      v7->m_object_ptr = object_ptr;
      v7->m_object_info.m_size = object_size;
      v7->next = 0;
      v7->m_object_info.m_crc32 = _Ven_TT_L__advance_software_protect_crc32((uint8_t *)object_ptr, object_size, v8, v9);
      v10->m_object_info.m_initialed = 1;
      v10->m_object_info.m_auto_del = del_object_when_remove;
      v11 = m_ObjectWatchList.m_objets;
      if ( m_ObjectWatchList.m_objets )
      {
        while ( v11->next )
          v11 = v11->next;
        v11->next = v10;
      }
      else
      {
        m_ObjectWatchList.m_objets = v10;
      }
      return 1;
    }
    v6 = ObjectMemoryError;
LABEL_10:
    advance_software_protect_objectwatch_list_sigslot(v6, 0);
    return 0;
  }
  advance_software_protect_objectwatch_list_sigslot(ObjectAlreadyExits, object_ptr);
  return 1;
}
// 80019D2: variable 'v8' is possibly undefined
// 80019D2: variable 'v9' is possibly undefined

//----- (08001A0C) --------------------------------------------------------
bool __fastcall advance_software_protect_objectwatch_list_check(void *object_ptr)
{
  int v1; // r2
  uint32_t v2; // r3
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *i; // r4

  for ( i = m_ObjectWatchList.m_objets; i; i = i->next )
  {
    if ( i->m_object_ptr == object_ptr )
      return _Ven_TT_L__advance_software_protect_crc32((uint8_t *)i->m_object_ptr, i->m_object_info.m_size, v1, v2) == i->m_object_info.m_crc32;
  }
  return 0;
}
// 8001A1E: variable 'v1' is possibly undefined
// 8001A1E: variable 'v2' is possibly undefined

//----- (08001A3C) --------------------------------------------------------
int __fastcall advance_software_protect_objectwatch_list_check_all(int a1, int a2, int a3, uint32_t a4)
{
  int v4; // r5
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *i; // r4

  v4 = 0;
  for ( i = m_ObjectWatchList.m_objets; i; i = i->next )
  {
    if ( _Ven_TT_L__advance_software_protect_crc32((uint8_t *)i->m_object_ptr, i->m_object_info.m_size, a3, a4) == i->m_object_info.m_crc32 )
      ++v4;
    else
      advance_software_protect_objectwatch_list_sigslot(ObjectModified, i->m_object_ptr);
  }
  return v4;
}
// 8001A4A: variable 'a3' is possibly undefined
// 8001A4A: variable 'a4' is possibly undefined

//----- (08001A70) --------------------------------------------------------
bool __fastcall advance_software_protect_objectwatch_list_find(void *object_ptr)
{
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v1; // r1

  v1 = m_ObjectWatchList.m_objets;
  if ( object_ptr )
  {
    while ( v1 )
    {
      if ( v1->m_object_ptr == object_ptr )
        return 1;
      v1 = v1->next;
    }
  }
  else
  {
    advance_software_protect_objectwatch_list_sigslot(ObjectParamError, 0);
  }
  return 0;
}

//----- (08001A9C) --------------------------------------------------------
bool __fastcall advance_software_protect_objectwatch_list_remove(void *object_ptr)
{
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v2; // r4
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v3; // r0

  v2 = m_ObjectWatchList.m_objets;
  v3 = m_ObjectWatchList.m_objets;
  while ( 1 )
  {
    if ( !v2 )
      return 0;
    if ( v2->m_object_ptr == object_ptr )
      break;
    v3 = v2;
    v2 = v2->next;
  }
  if ( v3 == v2 )
    m_ObjectWatchList.m_objets = m_ObjectWatchList.m_objets->next;
  else
    v3->next = v2->next;
  if ( v2->m_object_info.m_auto_del )
    free((int)v2->m_object_ptr);
  free((int)v2);
  return 1;
}

//----- (08001AE4) --------------------------------------------------------
void advance_software_protect_objectwatch_list_reset()
{
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *i; // r4
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM *v1; // r5

  for ( i = m_ObjectWatchList.m_objets; i; i = v1 )
  {
    v1 = i->next;
    if ( i->m_object_info.m_auto_del )
      free((int)i->m_object_ptr);
    free((int)i);
  }
  m_ObjectWatchList.m_objets = 0;
}

//----- (08001B10) --------------------------------------------------------
void __fastcall advance_software_protect_objectwatch_list_set_callback(ObjectWatcherCallback callback)
{
  m_ObjectWatchList.m_callback = callback;
}

//----- (08001B1C) --------------------------------------------------------
void __fastcall advance_software_protect_objectwatch_list_sigslot(E_ObjectWatchException_0 type, void *param)
{
  if ( m_ObjectWatchList.m_callback )
    m_ObjectWatchList.m_callback(type, param);
}

//----- (08001B2C) --------------------------------------------------------
size_t advance_software_protect_objectwatch_list_size()
{
  size_t result; // r0
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *v1; // r1

  result = 0;
  v1 = m_ObjectWatchList.m_objets;
  while ( v1 )
  {
    v1 = v1->next;
    ++result;
  }
  return result;
}

//----- (08001B44) --------------------------------------------------------
bool __fastcall advance_software_protect_objectwatch_list_update(void *object_ptr)
{
  int v1; // r2
  uint32_t v2; // r3
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *i; // r4

  for ( i = m_ObjectWatchList.m_objets; i; i = i->next )
  {
    if ( i->m_object_ptr == object_ptr )
    {
      i->m_object_info.m_crc32 = _Ven_TT_L__advance_software_protect_crc32(
                                   (uint8_t *)i->m_object_ptr,
                                   i->m_object_info.m_size,
                                   v1,
                                   v2);
      return 1;
    }
  }
  advance_software_protect_objectwatch_list_sigslot(ObjectParamError, 0);
  return 0;
}
// 8001B56: variable 'v1' is possibly undefined
// 8001B56: variable 'v2' is possibly undefined

//----- (08001B78) --------------------------------------------------------
void __fastcall advance_software_protect_objectwatch_list_update_all(int a1, int a2, int a3, uint32_t a4)
{
  S_ADV_SOFTWARE_PROTECT_OBJECTWATCH_ITEM_0 *i; // r4

  for ( i = m_ObjectWatchList.m_objets; i; i = i->next )
    i->m_object_info.m_crc32 = _Ven_TT_L__advance_software_protect_crc32(
                                 (uint8_t *)i->m_object_ptr,
                                 i->m_object_info.m_size,
                                 a3,
                                 a4);
}
// 8001B84: variable 'a3' is possibly undefined
// 8001B84: variable 'a4' is possibly undefined

//----- (08001B98) --------------------------------------------------------
void __fastcall advance_software_protect_ramcode_loader(RamcodeLoaderCallback callback)
{
  if ( m_ramcode_loaded )
  {
    callback(RamcodeOk);
  }
  else
  {
    m_ramcode_r.m_tag_s = 0x51E6D4150230AEADLL;
    m_ramcode_r.m_load_addr = 536965120;
    m_ramcode_r.m_flash_addr = 0;
    m_ramcode_r.m_flash_size = 0;
    m_ramcode_r.m_cumulative = -1;
    m_ramcode_r.m_tag_e = 0xCBECCBE6DD91892CLL;
    callback(RamcodeUnprocessed);
  }
}

//----- (08001C80) --------------------------------------------------------
void __fastcall advance_software_protect_ramcode_sample(E_RAMCODE_EVENT_0 event)
{
  if ( event && event != RamcodeOk && event == RamcodeError )
    _Ven_TT_L__advance_software_protect_system_reset();
}

//----- (08001C94) --------------------------------------------------------
void advance_software_protect_rights()
{
  if ( !once_only )
    once_only = 1;
}

//----- (08001CA8) --------------------------------------------------------
void advance_software_protect_samples()
{
  advance_software_protect_rights();
  advance_software_protect_ramcode_loader(advance_software_protect_ramcode_sample);
  advance_software_protect_single_object_watcher();
  advance_software_protect_dynamic_muti_object_watcher();
  _Ven_TT_L__advance_software_protect_verify_authorization();
  _Ven_TT_L__advance_software_protect_flash_verify();
  _Ven_TT_L__advance_software_protect_anti_debugger(advance_software_protect_anti_debugger_sample);
}

//----- (08001CD8) --------------------------------------------------------
void advance_software_protect_single_object_watcher()
{
  _advance_software_protect_objectwatch_check(&m_Object, 0x10u);
  m_Object.m_Object.m_sample1 = 1;
  m_Object.m_Object.m_sample2 = 2;
  m_Object.m_Object.m_sample3 = 3;
  m_Object.m_Object.m_ptr8 = (uint8_t *)305419896;
  _advance_software_protect_objectwatch_check(&m_Object, 0x10u);
  _advance_software_protect_objectwatch_update(&m_Object, 0x10u);
  _advance_software_protect_objectwatch_check(&m_Object, 0x10u);
}

//----- (08001D18) --------------------------------------------------------
void __fastcall carry64(mbedtls_mpi_uint *dst, mbedtls_mpi_uint *carry)
{
  unsigned int v2; // r2
  mbedtls_mpi_uint v3; // r3

  LOBYTE(v2) = 0;
  do
  {
    v3 = *dst + *carry;
    *dst = v3;
    v2 = (unsigned __int8)(v2 + 1);
    ++dst;
    *carry = v3 < *carry;
  }
  while ( v2 < 2 );
}

//----- (08001D40) --------------------------------------------------------
uint32_t __fastcall crc32(const void *data, int nBytes)
{
  int v4; // r4
  int i; // r5
  int v6; // r0

  v4 = -1;
  for ( i = 0; i < nBytes; ++i )
  {
    v4 ^= reflect(*((unsigned __int8 *)data + i), 8u) << 24;
    LOBYTE(v6) = 8;
    do
    {
      if ( v4 >= 0 )
        v4 *= 2;
      else
        v4 = (2 * v4) ^ 0x4C11DB7;
      v6 = (unsigned __int8)(v6 - 1);
    }
    while ( v6 );
  }
  return ~reflect(v4, 0x20u);
}

//----- (08001D90) --------------------------------------------------------
uint32_t __fastcall crc32_continue(uint32_t prev_crc, const void *data, int nBytes)
{
  int v5; // r4
  int i; // r5
  int v7; // r0

  v5 = reflect(~prev_crc, 0x20u);
  for ( i = 0; i < nBytes; ++i )
  {
    v5 ^= reflect(*((unsigned __int8 *)data + i), 8u) << 24;
    LOBYTE(v7) = 8;
    do
    {
      if ( v5 >= 0 )
        v5 *= 2;
      else
        v5 = (2 * v5) ^ 0x4C11DB7;
      v7 = (unsigned __int8)(v7 - 1);
    }
    while ( v7 );
  }
  return ~reflect(v5, 0x20u);
}

//----- (08001DE8) --------------------------------------------------------
int __fastcall derive_mpi(const mbedtls_ecp_group_0 *grp, mbedtls_mpi_0 *x, const unsigned __int8 *buf, size_t blen)
{
  size_t v5; // r4
  int v7; // r7
  size_t v8; // r0

  v5 = (grp->nbits + 7) >> 3;
  if ( blen <= v5 )
    v5 = blen;
  v7 = mbedtls_mpi_read_binary(x, buf, v5);
  if ( !v7 )
  {
    v8 = grp->nbits;
    if ( (v8 >= 8 * v5 || (v7 = mbedtls_mpi_shift_r(x, 8 * v5 - v8)) == 0) && mbedtls_mpi_cmp_mpi(x, &grp->N) >= 0 )
      v7 = mbedtls_mpi_sub_mpi(x, x, &grp->N);
  }
  return v7;
}

//----- (08001E44) --------------------------------------------------------
int __fastcall ecdsa_verify_restartable(mbedtls_ecp_group_0 *grp, const unsigned __int8 *buf, size_t blen, const mbedtls_ecp_point_0 *Q, const mbedtls_mpi_0 *r, const mbedtls_mpi_0 *s, mbedtls_ecdsa_restart_ctx *rs_ctx)
{
  int v11; // r4
  int v13; // r0
  mbedtls_ecp_point_0 R; // [sp+Ch] [bp-58h] BYREF
  mbedtls_mpi_0 *Y; // [sp+30h] [bp-34h]
  mbedtls_mpi_0 s_inv; // [sp+40h] [bp-24h] BYREF
  mbedtls_mpi_0 e; // [sp+4Ch] [bp-18h] BYREF
  mbedtls_mpi_0 u1; // [sp+58h] [bp-Ch] BYREF
  mbedtls_mpi_0 u2; // [sp+64h] [bp+0h] BYREF

  mbedtls_ecp_point_init(&R);
  mbedtls_mpi_init(&e);
  mbedtls_mpi_init(&s_inv);
  mbedtls_mpi_init(&u1);
  mbedtls_mpi_init(&u2);
  if ( !grp->N.p )
    return -20352;
  if ( mbedtls_mpi_cmp_int(r, 1) < 0 )
    goto LABEL_19;
  Y = &grp->N;
  if ( mbedtls_mpi_cmp_mpi(r, &grp->N) >= 0 )
    goto LABEL_19;
  if ( mbedtls_mpi_cmp_int(s, 1) < 0 )
    goto LABEL_19;
  if ( mbedtls_mpi_cmp_mpi(s, Y) >= 0 )
    goto LABEL_19;
  v11 = derive_mpi(grp, &e, buf, blen);
  if ( !v11 )
  {
    v13 = mbedtls_mpi_inv_mod(&s_inv, s, Y);
    v11 = v13;
    if ( !v13 )
    {
      v11 = mbedtls_mpi_mul_mpi(&u1, &e, &s_inv);
      if ( !v11 )
      {
        v11 = mbedtls_mpi_mod_mpi(&u1, &u1, Y);
        if ( !v11 )
        {
          v11 = mbedtls_mpi_mul_mpi(&u2, r, &s_inv);
          if ( !v11 )
          {
            v11 = mbedtls_mpi_mod_mpi(&u2, &u2, Y);
            if ( !v11 )
            {
              v11 = mbedtls_ecp_muladd_restartable(grp, &R, &u1, &grp->G, &u2, Q, 0);
              if ( !v11
                && (mbedtls_ecp_is_zero(&R)
                 || (v11 = mbedtls_mpi_mod_mpi(&R.X, &R.X, Y)) == 0 && mbedtls_mpi_cmp_mpi(&R.X, r)) )
              {
LABEL_19:
                v11 = -19968;
              }
            }
          }
        }
      }
    }
  }
  mbedtls_ecp_point_free(&R);
  mbedtls_mpi_free(&e);
  mbedtls_mpi_free(&s_inv);
  mbedtls_mpi_free(&u1);
  mbedtls_mpi_free(&u2);
  return v11;
}

//----- (08001F7C) --------------------------------------------------------
void __fastcall ecp_comb_recode_core(unsigned __int8 *x, size_t d, unsigned __int8 w, const mbedtls_mpi_0 *m)
{
  unsigned int v6; // r8
  size_t i; // r6
  unsigned int j; // r7
  int v10; // r2
  size_t k; // r1
  int v12; // r3
  int v13; // r0
  int v14; // r3
  int v15; // r12
  int v16; // r7

  v6 = w;
  _rt_memclr(x, d + 1);
  for ( i = 0; i < d; ++i )
  {
    for ( j = 0; j < v6; ++j )
      x[i] |= (unsigned __int8)mbedtls_mpi_get_bit(m, i + d * j) << j;
  }
  v10 = 0;
  for ( k = 1; k <= d; ++k )
  {
    v12 = x[k];
    v13 = v12 & v10;
    v14 = v12 ^ v10;
    v15 = 1 - (v14 & 1);
    v16 = x[k - 1];
    v10 = v14 & (v16 * v15) | v13;
    x[k] = v14 ^ (v16 * v15);
    x[k - 1] = v16 | ((_BYTE)v15 << 7);
  }
}
// 8000518: using guessed type int __fastcall _rt_memclr(_DWORD, _DWORD);

//----- (08001FFA) --------------------------------------------------------
void __fastcall mbedtls_mpi_zeroize(mbedtls_mpi_uint *v, size_t n)
{
  mbedtls_platform_zeroize(v, 4 * n);
}

//----- (08002090) --------------------------------------------------------
int __fastcall ecp_mod_p192k1(mbedtls_mpi_0 *N)
{
  return ecp_mod_koblitz(N, Rp, 6u, 0, 0, 0);
}

//----- (080020A8) --------------------------------------------------------
int __fastcall ecp_mod_p224k1(mbedtls_mpi_0 *N)
{
  return ecp_mod_koblitz(N, Rp_0, 7u, 0, 0, 0);
}

//----- (080020C0) --------------------------------------------------------
void __fastcall ecp_mpi_load(mbedtls_mpi_0 *X, const mbedtls_mpi_uint *p, size_t len)
{
  X->s = 1;
  X->n = len >> 2;
  X->p = (mbedtls_mpi_uint *)p;
}

//----- (080020CC) --------------------------------------------------------
int __fastcall ecp_add_mixed(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *P, const mbedtls_ecp_point_0 *Q)
{
  mbedtls_mpi_0 *v8; // r9
  const mbedtls_ecp_point_0 *v10; // r1
  bool v11; // zf
  int v12; // r4
  int i; // r0
  int j; // r0
  int v15; // r0
  int v16; // r0
  int k; // r0
  int l; // r0
  int m; // r0
  int n; // r0
  int v21; // r0
  int ii; // r0
  mbedtls_mpi_0 T1; // [sp+0h] [bp-70h] BYREF
  mbedtls_mpi_0 T3; // [sp+Ch] [bp-64h] BYREF
  mbedtls_mpi_0 X; // [sp+18h] [bp-58h] BYREF
  mbedtls_mpi_0 T2; // [sp+24h] [bp-4Ch] BYREF
  mbedtls_mpi_0 Y; // [sp+30h] [bp-40h] BYREF
  mbedtls_mpi_0 T4; // [sp+3Ch] [bp-34h] BYREF
  mbedtls_mpi_0 Z; // [sp+48h] [bp-28h] BYREF

  v8 = &P->Z;
  if ( !mbedtls_mpi_cmp_int(&P->Z, 0) )
  {
    v10 = Q;
    return mbedtls_ecp_copy(R, v10);
  }
  if ( Q->Z.p )
  {
    if ( mbedtls_mpi_cmp_int(&Q->Z, 0) )
    {
      if ( Q->Z.p && mbedtls_mpi_cmp_int(&Q->Z, 1) )
        return -20352;
      goto LABEL_10;
    }
    v10 = P;
    return mbedtls_ecp_copy(R, v10);
  }
LABEL_10:
  mbedtls_mpi_init(&T1);
  mbedtls_mpi_init(&T2);
  mbedtls_mpi_init(&T3);
  mbedtls_mpi_init(&T4);
  mbedtls_mpi_init(&X);
  mbedtls_mpi_init(&Y);
  mbedtls_mpi_init(&Z);
  v12 = mbedtls_mpi_mul_mpi(&T1, v8, v8);
  v11 = v12 == 0;
LABEL_11:
  while ( v11 )
  {
    v12 = ecp_modp(&T1, grp);
    v11 = v12 == 0;
LABEL_14:
    if ( v11 )
    {
      v12 = mbedtls_mpi_mul_mpi(&T2, &T1, v8);
      v11 = v12 == 0;
LABEL_17:
      if ( v11 )
      {
        v12 = ecp_modp(&T2, grp);
        v11 = v12 == 0;
        if ( !v12 )
        {
          v12 = mbedtls_mpi_mul_mpi(&T1, &T1, &Q->X);
          v11 = v12 == 0;
          if ( !v12 )
          {
            v12 = ecp_modp(&T1, grp);
            v11 = v12 == 0;
            if ( !v12 )
            {
              v12 = mbedtls_mpi_mul_mpi(&T2, &T2, &Q->Y);
              v11 = v12 == 0;
              if ( !v12 )
              {
                v12 = ecp_modp(&T2, grp);
                v11 = v12 == 0;
                if ( !v12 )
                {
                  for ( i = mbedtls_mpi_sub_mpi(&T1, &T1, &P->X); ; i = mbedtls_mpi_add_mpi(&T1, &T1, &grp->P) )
                  {
                    v12 = i;
                    v11 = i == 0;
                    if ( i )
                      break;
                    if ( T1.s >= 0 || !mbedtls_mpi_cmp_int(&T1, 0) )
                    {
                      Q = (const mbedtls_ecp_point_0 *)&P->Y;
                      for ( j = mbedtls_mpi_sub_mpi(&T2, &T2, &P->Y); ; j = mbedtls_mpi_add_mpi(&T2, &T2, &grp->P) )
                      {
                        v12 = j;
                        v11 = j == 0;
                        if ( j )
                          break;
                        if ( T2.s >= 0 || !mbedtls_mpi_cmp_int(&T2, 0) )
                        {
                          if ( !mbedtls_mpi_cmp_int(&T1, 0) )
                          {
                            if ( mbedtls_mpi_cmp_int(&T2, 0) )
                              v15 = mbedtls_ecp_set_zero(R);
                            else
                              v15 = ecp_double_jac(grp, R, P);
LABEL_82:
                            v12 = v15;
                            goto LABEL_83;
                          }
                          v12 = mbedtls_mpi_mul_mpi(&Z, v8, &T1);
                          v11 = v12 == 0;
                          if ( v12 )
                            goto LABEL_11;
                          v16 = ecp_modp(&Z, grp);
                          v12 = v16;
                          v11 = v16 == 0;
                          if ( !v16 )
                          {
                            v12 = mbedtls_mpi_mul_mpi(&T3, &T1, &T1);
                            v11 = v12 == 0;
                            if ( v12 )
                              goto LABEL_17;
                            v12 = ecp_modp(&T3, grp);
                            if ( !v12 )
                            {
                              v12 = mbedtls_mpi_mul_mpi(&T4, &T3, &T1);
                              if ( !v12 )
                              {
                                v12 = ecp_modp(&T4, grp);
                                if ( !v12 )
                                {
                                  v12 = mbedtls_mpi_mul_mpi(&T3, &T3, &P->X);
                                  if ( !v12 )
                                  {
                                    v12 = ecp_modp(&T3, grp);
                                    if ( !v12 )
                                    {
                                      for ( k = mbedtls_mpi_mul_int(&T1, &T3, 2u);
                                            ;
                                            k = mbedtls_mpi_sub_abs(&T1, &T1, &grp->P) )
                                      {
                                        v12 = k;
                                        if ( k )
                                          break;
                                        if ( mbedtls_mpi_cmp_mpi(&T1, &grp->P) < 0 )
                                        {
                                          v12 = mbedtls_mpi_mul_mpi(&X, &T2, &T2);
                                          if ( !v12 )
                                          {
                                            v12 = ecp_modp(&X, grp);
                                            if ( !v12 )
                                            {
                                              for ( l = mbedtls_mpi_sub_mpi(&X, &X, &T1);
                                                    ;
                                                    l = mbedtls_mpi_add_mpi(&X, &X, &grp->P) )
                                              {
                                                v12 = l;
                                                if ( l )
                                                  break;
                                                if ( X.s >= 0 || !mbedtls_mpi_cmp_int(&X, 0) )
                                                {
                                                  for ( m = mbedtls_mpi_sub_mpi(&X, &X, &T4);
                                                        ;
                                                        m = mbedtls_mpi_add_mpi(&X, &X, &grp->P) )
                                                  {
                                                    v12 = m;
                                                    if ( m )
                                                      break;
                                                    if ( X.s >= 0 || !mbedtls_mpi_cmp_int(&X, 0) )
                                                    {
                                                      for ( n = mbedtls_mpi_sub_mpi(&T3, &T3, &X);
                                                            ;
                                                            n = mbedtls_mpi_add_mpi(&T3, &T3, &grp->P) )
                                                      {
                                                        v12 = n;
                                                        if ( n )
                                                          break;
                                                        if ( T3.s >= 0 || !mbedtls_mpi_cmp_int(&T3, 0) )
                                                        {
                                                          v21 = mbedtls_mpi_mul_mpi(&T3, &T3, &T2);
                                                          v12 = v21;
                                                          if ( !v21 )
                                                          {
                                                            v12 = ecp_modp(&T3, grp);
                                                            if ( !v12 )
                                                            {
                                                              v12 = mbedtls_mpi_mul_mpi(&T4, &T4, &P->Y);
                                                              if ( !v12 )
                                                              {
                                                                v12 = ecp_modp(&T4, grp);
                                                                if ( !v12 )
                                                                {
                                                                  for ( ii = mbedtls_mpi_sub_mpi(&Y, &T3, &T4);
                                                                        ;
                                                                        ii = mbedtls_mpi_add_mpi(&Y, &Y, &grp->P) )
                                                                  {
                                                                    v12 = ii;
                                                                    if ( ii )
                                                                      break;
                                                                    if ( Y.s >= 0 || !mbedtls_mpi_cmp_int(&Y, 0) )
                                                                    {
                                                                      v12 = mbedtls_mpi_copy(&R->X, &X);
                                                                      if ( !v12 )
                                                                      {
                                                                        v12 = mbedtls_mpi_copy(&R->Y, &Y);
                                                                        if ( !v12 )
                                                                        {
                                                                          v15 = mbedtls_mpi_copy(&R->Z, &Z);
                                                                          goto LABEL_82;
                                                                        }
                                                                      }
                                                                      goto LABEL_83;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                          goto LABEL_83;
                                                        }
                                                      }
                                                      goto LABEL_83;
                                                    }
                                                  }
                                                  goto LABEL_83;
                                                }
                                              }
                                            }
                                          }
                                          goto LABEL_83;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            goto LABEL_83;
                          }
                          goto LABEL_14;
                        }
                      }
                      goto LABEL_11;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_83:
  mbedtls_mpi_free(&T1);
  mbedtls_mpi_free(&T2);
  mbedtls_mpi_free(&T3);
  mbedtls_mpi_free(&T4);
  mbedtls_mpi_free(&X);
  mbedtls_mpi_free(&Y);
  mbedtls_mpi_free(&Z);
  return v12;
}

//----- (08002424) --------------------------------------------------------
int __fastcall ecp_check_pubkey_sw(const mbedtls_ecp_group_0 *grp, const mbedtls_ecp_point_0 *pt)
{
  int v5; // r4
  int i; // r0
  int j; // r0
  int k; // r0
  mbedtls_mpi_0 RHS; // [sp+0h] [bp-30h] BYREF
  mbedtls_mpi_0 YY; // [sp+Ch] [bp-24h] BYREF

  if ( mbedtls_mpi_cmp_int(&pt->X, 0) < 0
    || mbedtls_mpi_cmp_int(&pt->Y, 0) < 0
    || mbedtls_mpi_cmp_mpi(&pt->X, &grp->P) >= 0
    || mbedtls_mpi_cmp_mpi(&pt->Y, &grp->P) >= 0 )
  {
    return -19584;
  }
  mbedtls_mpi_init(&YY);
  mbedtls_mpi_init(&RHS);
  v5 = mbedtls_mpi_mul_mpi(&YY, &pt->Y, &pt->Y);
  if ( !v5 )
  {
    v5 = ecp_modp(&YY, grp);
    if ( !v5 )
    {
      v5 = mbedtls_mpi_mul_mpi(&RHS, &pt->X, &pt->X);
      if ( !v5 )
      {
        v5 = ecp_modp(&RHS, grp);
        if ( !v5 )
        {
          if ( grp->A.p )
          {
            for ( i = mbedtls_mpi_add_mpi(&RHS, &RHS, &grp->A); ; i = mbedtls_mpi_sub_abs(&RHS, &RHS, &grp->P) )
            {
              v5 = i;
              if ( i )
                break;
              if ( mbedtls_mpi_cmp_mpi(&RHS, &grp->P) < 0 )
                goto LABEL_21;
            }
          }
          else
          {
            for ( j = mbedtls_mpi_sub_int(&RHS, &RHS, 3); ; j = mbedtls_mpi_add_mpi(&RHS, &RHS, &grp->P) )
            {
              v5 = j;
              if ( j )
                break;
              if ( RHS.s >= 0 || !mbedtls_mpi_cmp_int(&RHS, 0) )
              {
LABEL_21:
                v5 = mbedtls_mpi_mul_mpi(&RHS, &RHS, &pt->X);
                if ( !v5 )
                {
                  v5 = ecp_modp(&RHS, grp);
                  if ( !v5 )
                  {
                    for ( k = mbedtls_mpi_add_mpi(&RHS, &RHS, &grp->B); ; k = mbedtls_mpi_sub_abs(&RHS, &RHS, &grp->P) )
                    {
                      v5 = k;
                      if ( k )
                        break;
                      if ( mbedtls_mpi_cmp_mpi(&RHS, &grp->P) < 0 )
                      {
                        if ( mbedtls_mpi_cmp_mpi(&YY, &RHS) )
                          v5 = -19584;
                        goto LABEL_29;
                      }
                    }
                  }
                }
                break;
              }
            }
          }
        }
      }
    }
  }
LABEL_29:
  mbedtls_mpi_free(&YY);
  mbedtls_mpi_free(&RHS);
  return v5;
}

//----- (08002564) --------------------------------------------------------
int __fastcall ecp_comb_recode_scalar(const mbedtls_ecp_group_0 *grp, const mbedtls_mpi_0 *m, unsigned __int8 *k, size_t d, unsigned __int8 w, unsigned __int8 *parity_trick)
{
  mbedtls_mpi_0 *v10; // r10
  int v12; // r4
  mbedtls_mpi_0 v13; // [sp+0h] [bp-38h] BYREF
  mbedtls_mpi_0 mm; // [sp+Ch] [bp-2Ch] BYREF

  mbedtls_mpi_init(&v13);
  mbedtls_mpi_init(&mm);
  v10 = &grp->N;
  if ( mbedtls_mpi_get_bit(&grp->N, 0) != 1 )
    return -20352;
  *parity_trick = mbedtls_mpi_get_bit(m, 0) == 0;
  v12 = mbedtls_mpi_copy(&v13, m);
  if ( !v12 )
  {
    v12 = mbedtls_mpi_sub_mpi(&mm, v10, m);
    if ( !v12 )
    {
      v12 = mbedtls_mpi_safe_cond_assign(&v13, &mm, *parity_trick);
      if ( !v12 )
        ecp_comb_recode_core(k, d, w, &v13);
    }
  }
  mbedtls_mpi_free(&mm);
  mbedtls_mpi_free(&v13);
  return v12;
}

//----- (080025F8) --------------------------------------------------------
int __fastcall ecp_double_add_mxz(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, mbedtls_ecp_point_0 *S, const mbedtls_ecp_point_0 *P, const mbedtls_ecp_point_0 *Q, const mbedtls_mpi_0 *d)
{
  mbedtls_mpi_0 *v10; // r11
  int v11; // r0
  bool v12; // zf
  int v13; // r4
  int i; // r0
  int j; // r0
  int k; // r0
  int l; // r0
  int v18; // r0
  int m; // r0
  int n; // r0
  mbedtls_mpi_0 B; // [sp+0h] [bp-90h] BYREF
  mbedtls_mpi_0 E; // [sp+Ch] [bp-84h] BYREF
  mbedtls_mpi_0 X; // [sp+18h] [bp-78h] BYREF
  mbedtls_mpi_0 A; // [sp+24h] [bp-6Ch] BYREF
  mbedtls_mpi_0 BB; // [sp+30h] [bp-60h] BYREF
  mbedtls_mpi_0 C; // [sp+3Ch] [bp-54h] BYREF
  mbedtls_mpi_0 AA; // [sp+48h] [bp-48h] BYREF
  mbedtls_mpi_0 DA; // [sp+54h] [bp-3Ch] BYREF
  mbedtls_mpi_0 CB; // [sp+60h] [bp-30h] BYREF

  mbedtls_mpi_init(&A);
  mbedtls_mpi_init(&AA);
  mbedtls_mpi_init(&B);
  mbedtls_mpi_init(&BB);
  mbedtls_mpi_init(&E);
  mbedtls_mpi_init(&C);
  mbedtls_mpi_init(&X);
  mbedtls_mpi_init(&DA);
  mbedtls_mpi_init(&CB);
  v10 = &P->Z;
  v11 = mbedtls_mpi_add_mpi(&A, &P->X, &P->Z);
LABEL_3:
  v13 = v11;
  v12 = v11 == 0;
LABEL_4:
  while ( v12 )
  {
    if ( mbedtls_mpi_cmp_mpi(&A, &grp->P) >= 0 )
    {
      v11 = mbedtls_mpi_sub_abs(&A, &A, &grp->P);
      goto LABEL_3;
    }
    v13 = mbedtls_mpi_mul_mpi(&AA, &A, &A);
    v12 = v13 == 0;
    if ( !v13 )
    {
      v13 = ecp_modp(&AA, grp);
      v12 = v13 == 0;
      if ( !v13 )
      {
        for ( i = mbedtls_mpi_sub_mpi(&B, &P->X, v10); ; i = mbedtls_mpi_add_mpi(&B, &B, &grp->P) )
        {
          v13 = i;
          v12 = i == 0;
          if ( i )
            break;
          if ( B.s >= 0 || !mbedtls_mpi_cmp_int(&B, 0) )
          {
            v13 = mbedtls_mpi_mul_mpi(&BB, &B, &B);
            v12 = v13 == 0;
            if ( !v13 )
            {
              v13 = ecp_modp(&BB, grp);
              v12 = v13 == 0;
              if ( !v13 )
              {
                for ( j = mbedtls_mpi_sub_mpi(&E, &AA, &BB); ; j = mbedtls_mpi_add_mpi(&E, &E, &grp->P) )
                {
                  v13 = j;
                  v12 = j == 0;
                  if ( j )
                    break;
                  if ( E.s >= 0 || !mbedtls_mpi_cmp_int(&E, 0) )
                  {
                    P = (const mbedtls_ecp_point_0 *)&Q->Z;
                    for ( k = mbedtls_mpi_add_mpi(&C, &Q->X, &Q->Z); ; k = mbedtls_mpi_sub_abs(&C, &C, &grp->P) )
                    {
                      v13 = k;
                      v12 = k == 0;
                      if ( k )
                        break;
                      if ( mbedtls_mpi_cmp_mpi(&C, &grp->P) < 0 )
                      {
                        for ( l = mbedtls_mpi_sub_mpi(&X, &Q->X, &Q->Z); ; l = mbedtls_mpi_add_mpi(&X, &X, &grp->P) )
                        {
                          v13 = l;
                          if ( l )
                            break;
                          if ( X.s >= 0 || !mbedtls_mpi_cmp_int(&X, 0) )
                          {
                            v13 = mbedtls_mpi_mul_mpi(&DA, &X, &A);
                            if ( !v13 )
                            {
                              v18 = ecp_modp(&DA, grp);
                              v13 = v18;
                              if ( !v18 )
                              {
                                v13 = mbedtls_mpi_mul_mpi(&CB, &C, &B);
                                if ( !v13 )
                                {
                                  v13 = ecp_modp(&CB, grp);
                                  if ( !v13 )
                                  {
                                    v13 = mbedtls_mpi_add_mpi(&S->X, &DA, &CB);
                                    if ( !v13 )
                                    {
                                      v13 = ecp_modp(&S->X, grp);
                                      if ( !v13 )
                                      {
                                        v13 = mbedtls_mpi_mul_mpi(&S->X, &S->X, &S->X);
                                        if ( !v13 )
                                        {
                                          v13 = ecp_modp(&S->X, grp);
                                          if ( !v13 )
                                          {
                                            for ( m = mbedtls_mpi_sub_mpi(&S->Z, &DA, &CB);
                                                  ;
                                                  m = mbedtls_mpi_add_mpi(&S->Z, &S->Z, &grp->P) )
                                            {
                                              v13 = m;
                                              if ( m )
                                                break;
                                              if ( S->Z.s >= 0 || !mbedtls_mpi_cmp_int(&S->Z, 0) )
                                              {
                                                v13 = mbedtls_mpi_mul_mpi(&S->Z, &S->Z, &S->Z);
                                                if ( !v13 )
                                                {
                                                  v13 = ecp_modp(&S->Z, grp);
                                                  if ( !v13 )
                                                  {
                                                    v13 = mbedtls_mpi_mul_mpi(&S->Z, d, &S->Z);
                                                    if ( !v13 )
                                                    {
                                                      v13 = ecp_modp(&S->Z, grp);
                                                      if ( !v13 )
                                                      {
                                                        v13 = mbedtls_mpi_mul_mpi(&R->X, &AA, &BB);
                                                        if ( !v13 )
                                                        {
                                                          v13 = ecp_modp(&R->X, grp);
                                                          if ( !v13 )
                                                          {
                                                            v13 = mbedtls_mpi_mul_mpi(&R->Z, &grp->A, &E);
                                                            if ( !v13 )
                                                            {
                                                              v13 = ecp_modp(&R->Z, grp);
                                                              if ( !v13 )
                                                              {
                                                                for ( n = mbedtls_mpi_add_mpi(&R->Z, &BB, &R->Z);
                                                                      ;
                                                                      n = mbedtls_mpi_sub_abs(&R->Z, &R->Z, &grp->P) )
                                                                {
                                                                  v13 = n;
                                                                  if ( n )
                                                                    break;
                                                                  if ( mbedtls_mpi_cmp_mpi(&R->Z, &grp->P) < 0 )
                                                                  {
                                                                    v13 = mbedtls_mpi_mul_mpi(&R->Z, &E, &R->Z);
                                                                    if ( !v13 )
                                                                      v13 = ecp_modp(&R->Z, grp);
                                                                    goto LABEL_60;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                                goto LABEL_60;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            goto LABEL_60;
                          }
                        }
                        goto LABEL_60;
                      }
                    }
                    goto LABEL_4;
                  }
                }
              }
            }
            goto LABEL_4;
          }
        }
      }
    }
  }
LABEL_60:
  mbedtls_mpi_free(&A);
  mbedtls_mpi_free(&AA);
  mbedtls_mpi_free(&B);
  mbedtls_mpi_free(&BB);
  mbedtls_mpi_free(&E);
  mbedtls_mpi_free(&C);
  mbedtls_mpi_free(&X);
  mbedtls_mpi_free(&DA);
  mbedtls_mpi_free(&CB);
  return v13;
}

//----- (080028D4) --------------------------------------------------------
int __fastcall ecp_double_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *P)
{
  bool v6; // zf
  int v7; // r4
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int i; // r0
  int j; // r0
  int k; // r0
  int l; // r0
  int m; // r0
  int n; // r0
  int ii; // r0
  int jj; // r0
  int v19; // r0
  int kk; // r0
  int ll; // r0
  mbedtls_mpi_0 S; // [sp+0h] [bp-50h] BYREF
  mbedtls_mpi_0 T; // [sp+Ch] [bp-44h] BYREF
  mbedtls_mpi_0 U; // [sp+18h] [bp-38h] BYREF
  mbedtls_mpi_0 M; // [sp+24h] [bp-2Ch] BYREF

  mbedtls_mpi_init(&M);
  mbedtls_mpi_init(&S);
  mbedtls_mpi_init(&T);
  mbedtls_mpi_init(&U);
  if ( !grp->A.p )
  {
    v7 = mbedtls_mpi_mul_mpi(&S, &P->Z, &P->Z);
    v6 = v7 == 0;
    goto LABEL_7;
  }
  v7 = mbedtls_mpi_mul_mpi(&S, &P->X, &P->X);
  v6 = v7 == 0;
LABEL_3:
  while ( v6 )
  {
    v7 = ecp_modp(&S, grp);
    v6 = v7 == 0;
LABEL_38:
    if ( v6 )
    {
      for ( i = mbedtls_mpi_mul_int(&M, &S, 3u); ; i = mbedtls_mpi_sub_abs(&M, &M, &grp->P) )
      {
        v7 = i;
        v6 = i == 0;
LABEL_43:
        if ( !v6 )
          goto LABEL_3;
        if ( mbedtls_mpi_cmp_mpi(&M, &grp->P) < 0 )
          break;
      }
      if ( mbedtls_mpi_cmp_int(&grp->A, 0) )
      {
        v7 = mbedtls_mpi_mul_mpi(&S, &P->Z, &P->Z);
        v6 = v7 == 0;
        if ( v7 )
        {
LABEL_7:
          if ( !v6 )
            goto LABEL_3;
          v7 = ecp_modp(&S, grp);
          v6 = v7 == 0;
        }
        else
        {
          v7 = ecp_modp(&S, grp);
          v6 = v7 == 0;
          if ( !v7 )
          {
            v7 = mbedtls_mpi_mul_mpi(&T, &S, &S);
            v6 = v7 == 0;
            if ( v7 || (v7 = ecp_modp(&T, grp), v6 = v7 == 0, v7) )
            {
              while ( 1 )
              {
                if ( !v6 )
                  goto LABEL_3;
                if ( mbedtls_mpi_cmp_mpi(&T, &grp->P) < 0 )
                {
                  v9 = mbedtls_mpi_sub_mpi(&U, &P->X, &S);
                  goto LABEL_20;
                }
                v8 = mbedtls_mpi_sub_abs(&T, &T, &grp->P);
LABEL_14:
                v7 = v8;
                v6 = v8 == 0;
              }
            }
            v7 = mbedtls_mpi_mul_mpi(&S, &T, &grp->A);
            v6 = v7 == 0;
            if ( v7 || (v7 = ecp_modp(&S, grp), v6 = v7 == 0, v7) )
            {
              while ( 1 )
              {
                if ( !v6 )
                  goto LABEL_3;
                if ( U.s >= 0 || !mbedtls_mpi_cmp_int(&U, 0) )
                  break;
                v9 = mbedtls_mpi_add_mpi(&U, &U, &grp->P);
LABEL_20:
                v7 = v9;
                v6 = v9 == 0;
              }
              v7 = mbedtls_mpi_mul_mpi(&S, &T, &U);
              v6 = v7 == 0;
            }
            else
            {
              for ( j = mbedtls_mpi_add_mpi(&M, &M, &S); ; j = mbedtls_mpi_sub_abs(&M, &M, &grp->P) )
              {
                v7 = j;
                v6 = j == 0;
                if ( j )
                  break;
                if ( mbedtls_mpi_cmp_mpi(&M, &grp->P) < 0 )
                  goto LABEL_58;
              }
            }
            if ( !v6 )
              goto LABEL_3;
            v7 = ecp_modp(&S, grp);
            v6 = v7 == 0;
LABEL_29:
            if ( v6 )
            {
              v10 = mbedtls_mpi_mul_int(&M, &S, 3u);
LABEL_33:
              v7 = v10;
              v6 = v10 == 0;
              goto LABEL_34;
            }
            goto LABEL_3;
          }
        }
        if ( !v6 )
          goto LABEL_3;
        v8 = mbedtls_mpi_add_mpi(&T, &P->X, &S);
        goto LABEL_14;
      }
LABEL_58:
      while ( 1 )
      {
        v7 = mbedtls_mpi_mul_mpi(&T, &P->Y, &P->Y);
        v6 = v7 == 0;
        if ( v7 )
          goto LABEL_29;
        v7 = ecp_modp(&T, grp);
        v6 = v7 == 0;
        if ( !v7 )
        {
          for ( k = mbedtls_mpi_shift_l(&T, 1u); ; k = mbedtls_mpi_sub_abs(&T, &T, &grp->P) )
          {
            v7 = k;
            v6 = k == 0;
            if ( k )
              break;
            if ( mbedtls_mpi_cmp_mpi(&T, &grp->P) < 0 )
            {
              v7 = mbedtls_mpi_mul_mpi(&S, &P->X, &T);
              v6 = v7 == 0;
              if ( v7 )
                goto LABEL_43;
              v7 = ecp_modp(&S, grp);
              v6 = v7 == 0;
              if ( v7 )
                goto LABEL_43;
              for ( l = mbedtls_mpi_shift_l(&S, 1u); ; l = mbedtls_mpi_sub_abs(&S, &S, &grp->P) )
              {
                v7 = l;
                if ( l )
                  break;
                if ( mbedtls_mpi_cmp_mpi(&S, &grp->P) < 0 )
                {
                  v7 = mbedtls_mpi_mul_mpi(&U, &T, &T);
                  if ( !v7 )
                  {
                    v7 = ecp_modp(&U, grp);
                    if ( !v7 )
                    {
                      for ( m = mbedtls_mpi_shift_l(&U, 1u); ; m = mbedtls_mpi_sub_abs(&U, &U, &grp->P) )
                      {
                        v7 = m;
                        if ( m )
                          break;
                        if ( mbedtls_mpi_cmp_mpi(&U, &grp->P) < 0 )
                        {
                          v7 = mbedtls_mpi_mul_mpi(&T, &M, &M);
                          if ( !v7 )
                          {
                            v7 = ecp_modp(&T, grp);
                            if ( !v7 )
                            {
                              for ( n = mbedtls_mpi_sub_mpi(&T, &T, &S); ; n = mbedtls_mpi_add_mpi(&T, &T, &grp->P) )
                              {
                                v7 = n;
                                if ( n )
                                  break;
                                if ( T.s >= 0 || !mbedtls_mpi_cmp_int(&T, 0) )
                                {
                                  for ( ii = mbedtls_mpi_sub_mpi(&T, &T, &S); ; ii = mbedtls_mpi_add_mpi(
                                                                                       &T,
                                                                                       &T,
                                                                                       &grp->P) )
                                  {
                                    v7 = ii;
                                    if ( ii )
                                      break;
                                    if ( T.s >= 0 || !mbedtls_mpi_cmp_int(&T, 0) )
                                    {
                                      for ( jj = mbedtls_mpi_sub_mpi(&S, &S, &T);
                                            ;
                                            jj = mbedtls_mpi_add_mpi(&S, &S, &grp->P) )
                                      {
                                        v7 = jj;
                                        if ( jj )
                                          break;
                                        if ( S.s >= 0 || !mbedtls_mpi_cmp_int(&S, 0) )
                                        {
                                          v7 = mbedtls_mpi_mul_mpi(&S, &S, &M);
                                          if ( !v7 )
                                          {
                                            v19 = ecp_modp(&S, grp);
                                            v7 = v19;
                                            if ( !v19 )
                                            {
                                              for ( kk = mbedtls_mpi_sub_mpi(&S, &S, &U);
                                                    ;
                                                    kk = mbedtls_mpi_add_mpi(&S, &S, &grp->P) )
                                              {
                                                v7 = kk;
                                                if ( kk )
                                                  break;
                                                if ( S.s >= 0 || !mbedtls_mpi_cmp_int(&S, 0) )
                                                {
                                                  v7 = mbedtls_mpi_mul_mpi(&U, &P->Y, &P->Z);
                                                  if ( !v7 )
                                                  {
                                                    v7 = ecp_modp(&U, grp);
                                                    if ( !v7 )
                                                    {
                                                      for ( ll = mbedtls_mpi_shift_l(&U, 1u);
                                                            ;
                                                            ll = mbedtls_mpi_sub_abs(&U, &U, &grp->P) )
                                                      {
                                                        v7 = ll;
                                                        if ( ll )
                                                          break;
                                                        if ( mbedtls_mpi_cmp_mpi(&U, &grp->P) < 0 )
                                                        {
                                                          v7 = mbedtls_mpi_copy(&R->X, &T);
                                                          if ( !v7 )
                                                          {
                                                            v7 = mbedtls_mpi_copy(&R->Y, &S);
                                                            if ( !v7 )
                                                              v7 = mbedtls_mpi_copy(&R->Z, &U);
                                                          }
                                                          goto LABEL_111;
                                                        }
                                                      }
                                                    }
                                                  }
                                                  goto LABEL_111;
                                                }
                                              }
                                            }
                                          }
                                          goto LABEL_111;
                                        }
                                      }
                                      goto LABEL_111;
                                    }
                                  }
                                  goto LABEL_111;
                                }
                              }
                            }
                          }
                          goto LABEL_111;
                        }
                      }
                    }
                  }
                  goto LABEL_111;
                }
              }
              goto LABEL_111;
            }
          }
          goto LABEL_38;
        }
LABEL_34:
        if ( !v6 )
          goto LABEL_3;
        if ( mbedtls_mpi_cmp_mpi(&M, &grp->P) >= 0 )
        {
          v10 = mbedtls_mpi_sub_abs(&M, &M, &grp->P);
          goto LABEL_33;
        }
      }
    }
  }
LABEL_111:
  mbedtls_mpi_free(&M);
  mbedtls_mpi_free(&S);
  mbedtls_mpi_free(&T);
  mbedtls_mpi_free(&U);
  return v7;
}

//----- (08002CA4) --------------------------------------------------------
int __fastcall ecp_group_load(mbedtls_ecp_group_0 *grp, const mbedtls_mpi_uint *p, size_t plen, const mbedtls_mpi_uint *a, size_t alen, const mbedtls_mpi_uint *b, size_t blen, const mbedtls_mpi_uint *gx, size_t gxlen, const mbedtls_mpi_uint *gy, size_t gylen, const mbedtls_mpi_uint *n, size_t nlen)
{
  ecp_mpi_load(&grp->P, p, plen);
  if ( a )
    ecp_mpi_load(&grp->A, a, alen);
  ecp_mpi_load(&grp->B, b, blen);
  ecp_mpi_load(&grp->N, n, nlen);
  ecp_mpi_load(&grp->G.X, gx, gxlen);
  ecp_mpi_load(&grp->G.Y, gy, gylen);
  grp->G.Z.s = 1;
  grp->G.Z.n = 1;
  grp->G.Z.p = (mbedtls_mpi_uint *)&one;
  grp->pbits = mbedtls_mpi_bitlen(&grp->P);
  grp->nbits = mbedtls_mpi_bitlen(&grp->N);
  grp->h = 1;
  return 0;
}

//----- (08002D28) --------------------------------------------------------
int __fastcall ecp_mod_koblitz(mbedtls_mpi_0 *N, mbedtls_mpi_uint *Rp, size_t p_limbs, size_t adjust, size_t shift, mbedtls_mpi_uint mask)
{
  size_t v7; // r4
  int result; // r0
  size_t v10; // r11
  size_t v11; // r8
  bool v12; // zf
  int v13; // r6
  size_t i; // r0
  mbedtls_mpi_0 R; // [sp+4h] [bp-74h] BYREF
  mbedtls_mpi_uint Mp[11]; // [sp+10h] [bp-68h] BYREF
  mbedtls_mpi_0 M; // [sp+44h] [bp-34h] BYREF

  v7 = p_limbs;
  if ( N->n < p_limbs )
    return 0;
  R.p = Rp;
  R.s = 1;
  R.n = 2;
  M.s = 1;
  M.p = Mp;
  v10 = p_limbs - adjust;
  v11 = p_limbs + adjust;
  M.n = N->n - (p_limbs - adjust);
  if ( M.n > p_limbs + adjust )
    M.n = p_limbs + adjust;
  _rt_memclr_w(Mp, 44);
  _rt_memcpy_w((int *)Mp, (int *)&N->p[v7 - adjust], 4 * M.n);
  if ( !shift )
    goto LABEL_10;
  result = mbedtls_mpi_shift_r(&M, shift);
  v12 = result == 0;
  while ( v12 )
  {
LABEL_10:
    v13 = 4 * v7 - 4;
    M.n += R.n;
    if ( mask )
      *(mbedtls_mpi_uint *)((char *)N->p + v13) &= mask;
    for ( i = v7; N->n > i; ++i )
      N->p[i] = 0;
    result = mbedtls_mpi_mul_mpi(&M, &M, &R);
    if ( result )
      return result;
    result = mbedtls_mpi_add_abs(N, N, &M);
    if ( result )
      return result;
    M.n = N->n - v10;
    if ( M.n > v11 )
      M.n = v11;
    _rt_memclr_w(Mp, 44);
    _rt_memcpy_w((int *)Mp, (int *)&N->p[v7 - adjust], 4 * M.n);
    if ( shift )
    {
      result = mbedtls_mpi_shift_r(&M, shift);
      if ( result )
        return result;
    }
    M.n += R.n;
    if ( mask )
      *(mbedtls_mpi_uint *)((char *)N->p + v13) &= mask;
    while ( N->n > v7 )
      N->p[v7++] = 0;
    result = mbedtls_mpi_mul_mpi(&M, &M, &R);
    v12 = result == 0;
    if ( !result )
      return mbedtls_mpi_add_abs(N, N, &M);
  }
  return result;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08002E6E) --------------------------------------------------------
int __fastcall ecp_mod_p192(mbedtls_mpi_0 *N)
{
  int v2; // r8
  mbedtls_mpi_uint *v3; // r4
  mbedtls_mpi_uint *v4; // r7
  _DWORD *i; // r4
  mbedtls_mpi_uint c[8]; // [sp+0h] [bp-20h] BYREF

  c[0] = 0;
  v2 = mbedtls_mpi_grow(N, 0xCu);
  if ( !v2 )
  {
    v3 = N->p;
    v4 = &v3[N->n];
    add64(v3, v3 + 6, c);
    add64(v3, N->p + 10, c);
    v3 += 2;
    carry64(v3, c);
    add64(v3, N->p + 6, c);
    add64(v3, N->p + 8, c);
    add64(v3, N->p + 10, c);
    v3 += 2;
    carry64(v3, c);
    add64(v3, N->p + 8, c);
    add64(v3, N->p + 10, c);
    v3[2] = c[0];
    for ( i = v3 + 2; ++i < v4; *i = 0 )
      ;
  }
  return v2;
}

//----- (08002F0A) --------------------------------------------------------
int __fastcall ecp_mod_p224(mbedtls_mpi_0 *N)
{
  int v2; // r6
  signed int v3; // r1
  signed int v4; // r1
  signed int v5; // r1
  signed int v6; // r1
  signed int v7; // r1
  signed int v8; // r1
  mbedtls_mpi_uint v9; // r1
  int v10; // r0
  uint32_t cur; // [sp+0h] [bp-58h] BYREF
  char c[8]; // [sp+4h] [bp-54h] BYREF
  mbedtls_mpi_0 C; // [sp+Ch] [bp-4Ch] BYREF
  mbedtls_mpi_uint Cp[8]; // [sp+18h] [bp-40h] BYREF

  C.s = 1;
  C.n = 8;
  c[0] = 0;
  C.p = Cp;
  _rt_memclr_w(Cp, 32);
  v2 = mbedtls_mpi_grow(N, 0xEu);
  if ( !v2 )
  {
    cur = *N->p;
    sub32(&cur, N->p[7], c);
    sub32(&cur, N->p[11], c);
    *N->p = cur;
    v3 = c[0];
    cur = N->p[1];
    c[0] = 0;
    if ( v3 >= 0 )
      add32(&cur, v3, c);
    else
      sub32(&cur, -v3, c);
    sub32(&cur, N->p[8], c);
    sub32(&cur, N->p[12], c);
    N->p[1] = cur;
    v4 = c[0];
    cur = N->p[2];
    c[0] = 0;
    if ( v4 >= 0 )
      add32(&cur, v4, c);
    else
      sub32(&cur, -v4, c);
    sub32(&cur, N->p[9], c);
    sub32(&cur, N->p[13], c);
    N->p[2] = cur;
    v5 = c[0];
    cur = N->p[3];
    c[0] = 0;
    if ( v5 >= 0 )
      add32(&cur, v5, c);
    else
      sub32(&cur, -v5, c);
    sub32(&cur, N->p[10], c);
    add32(&cur, N->p[7], c);
    add32(&cur, N->p[11], c);
    N->p[3] = cur;
    v6 = c[0];
    cur = N->p[4];
    c[0] = 0;
    if ( v6 >= 0 )
      add32(&cur, v6, c);
    else
      sub32(&cur, -v6, c);
    sub32(&cur, N->p[11], c);
    add32(&cur, N->p[8], c);
    add32(&cur, N->p[12], c);
    N->p[4] = cur;
    v7 = c[0];
    cur = N->p[5];
    c[0] = 0;
    if ( v7 >= 0 )
      add32(&cur, v7, c);
    else
      sub32(&cur, -v7, c);
    sub32(&cur, N->p[12], c);
    add32(&cur, N->p[9], c);
    add32(&cur, N->p[13], c);
    N->p[5] = cur;
    v8 = c[0];
    cur = N->p[6];
    c[0] = 0;
    if ( v8 >= 0 )
      add32(&cur, v8, c);
    else
      sub32(&cur, -v8, c);
    sub32(&cur, N->p[13], c);
    add32(&cur, N->p[10], c);
    N->p[6] = cur;
    v9 = c[0];
    v10 = 7;
    if ( c[0] <= 0 )
      v9 = 0;
    N->p[7] = v9;
    for ( cur = 0; ++v10 < N->n; N->p[v10] = cur )
      ;
    if ( c[0] < 0 )
      fix_negative(N, c[0], &C, 0xE0u);
  }
  return v2;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (0800314C) --------------------------------------------------------
int __fastcall ecp_mod_p255(mbedtls_mpi_0 *N)
{
  int result; // r0
  size_t i; // r0
  mbedtls_mpi_uint Mp[10]; // [sp+0h] [bp-40h] BYREF
  mbedtls_mpi_0 M; // [sp+28h] [bp-18h] BYREF

  if ( N->n < 8 )
    return 0;
  M.s = 1;
  M.n = N->n - 7;
  if ( M.n > 9 )
    return -20352;
  M.p = Mp;
  _rt_memclr_w(Mp, 40);
  _rt_memcpy_w((int *)Mp, (int *)N->p + 7, 4 * M.n);
  result = mbedtls_mpi_shift_r(&M, 0x1Fu);
  if ( !result )
  {
    ++M.n;
    result = mbedtls_mpi_set_bit(N, 0xFFu, 0);
    if ( !result )
    {
      for ( i = 8; N->n > i; ++i )
        N->p[i] = 0;
      result = mbedtls_mpi_mul_int(&M, &M, 0x13u);
      if ( !result )
        result = mbedtls_mpi_add_abs(N, N, &M);
    }
  }
  return result;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (080031DC) --------------------------------------------------------
int __fastcall ecp_mod_p256(mbedtls_mpi_0 *N)
{
  int v2; // r6
  signed int v3; // r1
  signed int v4; // r1
  signed int v5; // r1
  signed int v6; // r1
  signed int v7; // r1
  signed int v8; // r1
  signed int v9; // r1
  mbedtls_mpi_uint v10; // r1
  int v11; // r0
  uint32_t cur; // [sp+0h] [bp-58h] BYREF
  char c[8]; // [sp+4h] [bp-54h] BYREF
  mbedtls_mpi_0 C; // [sp+Ch] [bp-4Ch] BYREF
  mbedtls_mpi_uint Cp[9]; // [sp+18h] [bp-40h] BYREF

  C.s = 1;
  C.n = 9;
  c[0] = 0;
  C.p = Cp;
  _rt_memclr_w(Cp, 36);
  v2 = mbedtls_mpi_grow(N, 0x10u);
  if ( !v2 )
  {
    cur = *N->p;
    add32(&cur, N->p[8], c);
    add32(&cur, N->p[9], c);
    sub32(&cur, N->p[11], c);
    sub32(&cur, N->p[12], c);
    sub32(&cur, N->p[13], c);
    sub32(&cur, N->p[14], c);
    *N->p = cur;
    v3 = c[0];
    cur = N->p[1];
    c[0] = 0;
    if ( v3 >= 0 )
      add32(&cur, v3, c);
    else
      sub32(&cur, -v3, c);
    add32(&cur, N->p[9], c);
    add32(&cur, N->p[10], c);
    sub32(&cur, N->p[12], c);
    sub32(&cur, N->p[13], c);
    sub32(&cur, N->p[14], c);
    sub32(&cur, N->p[15], c);
    N->p[1] = cur;
    v4 = c[0];
    cur = N->p[2];
    c[0] = 0;
    if ( v4 >= 0 )
      add32(&cur, v4, c);
    else
      sub32(&cur, -v4, c);
    add32(&cur, N->p[10], c);
    add32(&cur, N->p[11], c);
    sub32(&cur, N->p[13], c);
    sub32(&cur, N->p[14], c);
    sub32(&cur, N->p[15], c);
    N->p[2] = cur;
    v5 = c[0];
    cur = N->p[3];
    c[0] = 0;
    if ( v5 >= 0 )
      add32(&cur, v5, c);
    else
      sub32(&cur, -v5, c);
    add32(&cur, N->p[11], c);
    add32(&cur, N->p[11], c);
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[13], c);
    sub32(&cur, N->p[15], c);
    sub32(&cur, N->p[8], c);
    sub32(&cur, N->p[9], c);
    N->p[3] = cur;
    v6 = c[0];
    cur = N->p[4];
    c[0] = 0;
    if ( v6 >= 0 )
      add32(&cur, v6, c);
    else
      sub32(&cur, -v6, c);
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[14], c);
    sub32(&cur, N->p[9], c);
    sub32(&cur, N->p[10], c);
    N->p[4] = cur;
    v7 = c[0];
    cur = N->p[5];
    c[0] = 0;
    if ( v7 >= 0 )
      add32(&cur, v7, c);
    else
      sub32(&cur, -v7, c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[15], c);
    sub32(&cur, N->p[10], c);
    sub32(&cur, N->p[11], c);
    N->p[5] = cur;
    v8 = c[0];
    cur = N->p[6];
    c[0] = 0;
    if ( v8 >= 0 )
      add32(&cur, v8, c);
    else
      sub32(&cur, -v8, c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[13], c);
    sub32(&cur, N->p[8], c);
    sub32(&cur, N->p[9], c);
    N->p[6] = cur;
    v9 = c[0];
    cur = N->p[7];
    c[0] = 0;
    if ( v9 >= 0 )
      add32(&cur, v9, c);
    else
      sub32(&cur, -v9, c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[8], c);
    sub32(&cur, N->p[10], c);
    sub32(&cur, N->p[11], c);
    sub32(&cur, N->p[12], c);
    sub32(&cur, N->p[13], c);
    N->p[7] = cur;
    v10 = c[0];
    v11 = 8;
    if ( c[0] <= 0 )
      v10 = 0;
    N->p[8] = v10;
    for ( cur = 0; ++v11 < N->n; N->p[v11] = cur )
      ;
    if ( c[0] < 0 )
      fix_negative(N, c[0], &C, 0x100u);
  }
  return v2;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08003610) --------------------------------------------------------
int __fastcall ecp_mod_p256k1(mbedtls_mpi_0 *N)
{
  return ecp_mod_koblitz(N, Rp_1, 8u, 0, 0, 0);
}

//----- (08003628) --------------------------------------------------------
int __fastcall ecp_mod_p384(mbedtls_mpi_0 *N)
{
  int v2; // r6
  signed int v3; // r1
  signed int v4; // r1
  signed int v5; // r1
  signed int v6; // r1
  signed int v7; // r1
  signed int v8; // r1
  signed int v9; // r1
  signed int v10; // r1
  signed int v11; // r1
  signed int v12; // r1
  signed int v13; // r1
  mbedtls_mpi_uint v14; // r1
  int v15; // r0
  uint32_t cur; // [sp+0h] [bp-68h] BYREF
  char c[8]; // [sp+4h] [bp-64h] BYREF
  mbedtls_mpi_0 C; // [sp+Ch] [bp-5Ch] BYREF
  mbedtls_mpi_uint Cp[13]; // [sp+18h] [bp-50h] BYREF

  C.s = 1;
  C.n = 13;
  c[0] = 0;
  C.p = Cp;
  _rt_memclr_w(Cp, 52);
  v2 = mbedtls_mpi_grow(N, 0x18u);
  if ( !v2 )
  {
    cur = *N->p;
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[21], c);
    add32(&cur, N->p[20], c);
    sub32(&cur, N->p[23], c);
    *N->p = cur;
    v3 = c[0];
    cur = N->p[1];
    c[0] = 0;
    if ( v3 >= 0 )
      add32(&cur, v3, c);
    else
      sub32(&cur, -v3, c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[22], c);
    add32(&cur, N->p[23], c);
    sub32(&cur, N->p[12], c);
    sub32(&cur, N->p[20], c);
    N->p[1] = cur;
    v4 = c[0];
    cur = N->p[2];
    c[0] = 0;
    if ( v4 >= 0 )
      add32(&cur, v4, c);
    else
      sub32(&cur, -v4, c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[23], c);
    sub32(&cur, N->p[13], c);
    sub32(&cur, N->p[21], c);
    N->p[2] = cur;
    v5 = c[0];
    cur = N->p[3];
    c[0] = 0;
    if ( v5 >= 0 )
      add32(&cur, v5, c);
    else
      sub32(&cur, -v5, c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[20], c);
    add32(&cur, N->p[21], c);
    sub32(&cur, N->p[14], c);
    sub32(&cur, N->p[22], c);
    sub32(&cur, N->p[23], c);
    N->p[3] = cur;
    v6 = c[0];
    cur = N->p[4];
    c[0] = 0;
    if ( v6 >= 0 )
      add32(&cur, v6, c);
    else
      sub32(&cur, -v6, c);
    add32(&cur, N->p[21], c);
    add32(&cur, N->p[21], c);
    add32(&cur, N->p[16], c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[12], c);
    add32(&cur, N->p[20], c);
    add32(&cur, N->p[22], c);
    sub32(&cur, N->p[15], c);
    sub32(&cur, N->p[23], c);
    sub32(&cur, N->p[23], c);
    N->p[4] = cur;
    v7 = c[0];
    cur = N->p[5];
    c[0] = 0;
    if ( v7 >= 0 )
      add32(&cur, v7, c);
    else
      sub32(&cur, -v7, c);
    add32(&cur, N->p[22], c);
    add32(&cur, N->p[22], c);
    add32(&cur, N->p[17], c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[13], c);
    add32(&cur, N->p[21], c);
    add32(&cur, N->p[23], c);
    sub32(&cur, N->p[16], c);
    N->p[5] = cur;
    v8 = c[0];
    cur = N->p[6];
    c[0] = 0;
    if ( v8 >= 0 )
      add32(&cur, v8, c);
    else
      sub32(&cur, -v8, c);
    add32(&cur, N->p[23], c);
    add32(&cur, N->p[23], c);
    add32(&cur, N->p[18], c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[14], c);
    add32(&cur, N->p[22], c);
    sub32(&cur, N->p[17], c);
    N->p[6] = cur;
    v9 = c[0];
    cur = N->p[7];
    c[0] = 0;
    if ( v9 >= 0 )
      add32(&cur, v9, c);
    else
      sub32(&cur, -v9, c);
    add32(&cur, N->p[19], c);
    add32(&cur, N->p[16], c);
    add32(&cur, N->p[15], c);
    add32(&cur, N->p[23], c);
    sub32(&cur, N->p[18], c);
    N->p[7] = cur;
    v10 = c[0];
    cur = N->p[8];
    c[0] = 0;
    if ( v10 >= 0 )
      add32(&cur, v10, c);
    else
      sub32(&cur, -v10, c);
    add32(&cur, N->p[20], c);
    add32(&cur, N->p[17], c);
    add32(&cur, N->p[16], c);
    sub32(&cur, N->p[19], c);
    N->p[8] = cur;
    v11 = c[0];
    cur = N->p[9];
    c[0] = 0;
    if ( v11 >= 0 )
      add32(&cur, v11, c);
    else
      sub32(&cur, -v11, c);
    add32(&cur, N->p[21], c);
    add32(&cur, N->p[18], c);
    add32(&cur, N->p[17], c);
    sub32(&cur, N->p[20], c);
    N->p[9] = cur;
    v12 = c[0];
    cur = N->p[10];
    c[0] = 0;
    if ( v12 >= 0 )
      add32(&cur, v12, c);
    else
      sub32(&cur, -v12, c);
    add32(&cur, N->p[22], c);
    add32(&cur, N->p[19], c);
    add32(&cur, N->p[18], c);
    sub32(&cur, N->p[21], c);
    N->p[10] = cur;
    v13 = c[0];
    cur = N->p[11];
    c[0] = 0;
    if ( v13 >= 0 )
      add32(&cur, v13, c);
    else
      sub32(&cur, -v13, c);
    add32(&cur, N->p[23], c);
    add32(&cur, N->p[20], c);
    add32(&cur, N->p[19], c);
    sub32(&cur, N->p[22], c);
    N->p[11] = cur;
    v14 = c[0];
    v15 = 12;
    if ( c[0] <= 0 )
      v14 = 0;
    N->p[12] = v14;
    for ( cur = 0; ++v15 < N->n; N->p[v15] = cur )
      ;
    if ( c[0] < 0 )
      fix_negative(N, c[0], &C, 0x180u);
  }
  return v2;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08003B88) --------------------------------------------------------
int __fastcall ecp_mod_p448(mbedtls_mpi_0 *N)
{
  int result; // r0
  size_t i; // r0
  size_t j; // r0
  mbedtls_mpi_0 M; // [sp+8h] [bp-A0h] BYREF
  mbedtls_mpi_uint Mp[15]; // [sp+14h] [bp-94h] BYREF
  mbedtls_mpi_0 Q; // [sp+50h] [bp-58h] BYREF
  mbedtls_mpi_uint Qp[14]; // [sp+5Ch] [bp-4Ch] BYREF

  if ( N->n <= 0xE )
    return 0;
  M.s = 1;
  M.n = N->n - 14;
  if ( M.n > 0xE )
    return -20352;
  M.p = Mp;
  _rt_memclr_w(Mp, 60);
  _rt_memcpy_w((int *)Mp, (int *)N->p + 14, 4 * M.n);
  for ( i = 14; N->n > i; ++i )
    N->p[i] = 0;
  result = mbedtls_mpi_add_mpi(N, N, &M);
  if ( !result )
  {
    Q.s = M.s;
    Q.n = M.n;
    Q.p = Qp;
    _rt_memcpy_w((int *)Qp, (int *)Mp, 0x38u);
    result = mbedtls_mpi_shift_r(&Q, 0xE0u);
    if ( !result )
    {
      result = mbedtls_mpi_add_mpi(N, N, &Q);
      if ( !result )
      {
        for ( j = 7; M.n > j; ++j )
          Mp[j] = 0;
        result = mbedtls_mpi_add_mpi(&M, &M, &Q);
        if ( !result )
        {
          M.n = 15;
          result = mbedtls_mpi_shift_l(&M, 0xE0u);
          if ( !result )
            result = mbedtls_mpi_add_mpi(N, N, &M);
        }
      }
    }
  }
  return result;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08003C58) --------------------------------------------------------
int __fastcall ecp_mod_p521(mbedtls_mpi_0 *N)
{
  int result; // r0
  size_t i; // r0
  mbedtls_mpi_uint Mp[18]; // [sp+0h] [bp-60h] BYREF
  mbedtls_mpi_0 M; // [sp+48h] [bp-18h] BYREF

  if ( N->n < 0x11 )
    return 0;
  M.s = 1;
  M.n = N->n - 16;
  if ( M.n > 0x12 )
    M.n = 18;
  M.p = Mp;
  _rt_memcpy_w((int *)Mp, (int *)N->p + 16, 4 * M.n);
  result = mbedtls_mpi_shift_r(&M, 9u);
  if ( !result )
  {
    N->p[16] &= 0x1FF;
    for ( i = 17; N->n > i; ++i )
      N->p[i] = 0;
    result = mbedtls_mpi_add_abs(N, N, &M);
  }
  return result;
}

//----- (08003CC8) --------------------------------------------------------
int __fastcall ecp_modp(mbedtls_mpi_0 *N, const mbedtls_ecp_group_0 *grp)
{
  int i; // r0
  int v6; // r6

  if ( !grp->modp )
    return mbedtls_mpi_mod_mpi(N, N, &grp->P);
  if ( N->s < 0 && mbedtls_mpi_cmp_int(N, 0) || mbedtls_mpi_bitlen(N) > 2 * grp->pbits )
    return -20352;
  for ( i = grp->modp(N); ; i = mbedtls_mpi_add_mpi(N, N, &grp->P) )
  {
    v6 = i;
    if ( i )
      break;
    if ( N->s >= 0 || !mbedtls_mpi_cmp_int(N, 0) )
    {
      do
      {
        if ( mbedtls_mpi_cmp_mpi(N, &grp->P) < 0 )
          break;
        v6 = mbedtls_mpi_sub_abs(N, N, &grp->P);
      }
      while ( !v6 );
      return v6;
    }
  }
  return v6;
}

//----- (08003D50) --------------------------------------------------------
int __fastcall ecp_mul_comb(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng, mbedtls_ecp_restart_ctx *rs_ctx)
{
  _BOOL4 v8; // r1
  size_t v9; // r2
  _BOOL4 v10; // r9
  unsigned int v11; // r0
  unsigned int v12; // r8
  unsigned int v13; // r0
  size_t v14; // r6
  unsigned int v15; // r10
  mbedtls_ecp_point_0 *v16; // r4
  size_t i; // r7
  int v18; // r7
  mbedtls_ecp_point_0 *v19; // r11
  int v20; // r0
  size_t j; // r5
  unsigned __int8 k[264]; // [sp+14h] [bp-144h] BYREF
  unsigned __int8 inv[8]; // [sp+11Ch] [bp-3Ch] BYREF
  mbedtls_ecp_group_0 *v25; // [sp+124h] [bp-34h]
  mbedtls_ecp_point_0 *Ra; // [sp+128h] [bp-30h]
  const mbedtls_mpi_0 *ma; // [sp+12Ch] [bp-2Ch]
  const mbedtls_ecp_point_0 *Pa; // [sp+130h] [bp-28h]

  v25 = grp;
  Ra = R;
  ma = m;
  Pa = P;
  v8 = !mbedtls_mpi_cmp_mpi(&P->Y, &grp->G.Y) && !mbedtls_mpi_cmp_mpi(&Pa->X, &grp->G.X);
  v9 = grp->nbits;
  v10 = v8;
  if ( v9 < 0x180 )
    v11 = 4;
  else
    v11 = 5;
  if ( v8 )
    ++v11;
  if ( v11 > 6 )
    v11 = 6;
  if ( v9 <= v11 )
    v11 = 2;
  v12 = v11;
  v13 = v11 - 1;
  v14 = (unsigned __int8)(1 << v13);
  v15 = (v9 + v13) / v12;
  if ( v8 )
  {
    v16 = grp->T;
    if ( v16 )
      goto LABEL_24;
  }
  v16 = (mbedtls_ecp_point_0 *)calloc((unsigned __int8)(1 << v13), 0x24u);
  if ( !v16 )
  {
    v18 = -19840;
    goto LABEL_29;
  }
  for ( i = 0; i < v14; i = (unsigned __int8)(i + 1) )
    mbedtls_ecp_point_init(&v16[i]);
  v18 = ecp_precompute_comb(grp, v16, Pa, v12, v15, rs_ctx);
  if ( !v18 )
  {
    if ( v10 )
    {
      grp->T = v16;
      grp->T_size = v14;
    }
LABEL_24:
    v19 = Ra;
    v20 = ecp_comb_recode_scalar(grp, ma, k, v15, v12, inv);
    if ( !v20 )
    {
      v20 = ecp_mul_comb_core(grp, v19, v16, v14, k, v15, f_rng, p_rng, rs_ctx);
      if ( !v20 )
      {
        v20 = ecp_safe_invert_jac(grp, v19, inv[0]);
        if ( !v20 )
          v20 = ecp_normalize_jac(grp, v19);
      }
    }
    v18 = v20;
  }
LABEL_29:
  if ( grp->T != v16 && v16 )
  {
    for ( j = 0; j < v14; j = (unsigned __int8)(j + 1) )
      mbedtls_ecp_point_free(&v16[j]);
    free((int)v16);
  }
  if ( v18 )
    mbedtls_ecp_point_free(Ra);
  return v18;
}

//----- (08003E94) --------------------------------------------------------
int __fastcall ecp_mul_comb_core(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *T, unsigned int T_size, const unsigned __int8 *x, size_t d, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng, mbedtls_ecp_restart_ctx *rs_ctx)
{
  size_t v11; // r4
  int v13; // r5
  int i; // r0
  mbedtls_ecp_point_0 Txi; // [sp+4h] [bp-5Ch] BYREF
  const mbedtls_ecp_group_0 *grpa; // [sp+2Ch] [bp-34h]
  mbedtls_ecp_point_0 *v18; // [sp+30h] [bp-30h]
  const mbedtls_ecp_point_0 *v19; // [sp+34h] [bp-2Ch]
  unsigned int v20; // [sp+38h] [bp-28h]

  grpa = grp;
  v18 = R;
  v19 = T;
  v20 = T_size;
  v11 = d;
  mbedtls_ecp_point_init(&Txi);
  v13 = ecp_select_comb(grpa, R, T, T_size, x[d]);
  if ( !v13 )
  {
    v13 = mbedtls_mpi_lset(&R->Z, 1);
    if ( !v13 )
    {
      if ( !f_rng )
        goto LABEL_9;
      for ( i = ecp_randomize_jac(grpa, R, f_rng, p_rng); ; i = ecp_add_mixed(grpa, R, R, &Txi) )
      {
        v13 = i;
        if ( i )
          break;
LABEL_9:
        if ( v11 )
        {
          --v11;
          v13 = ecp_double_jac(grpa, R, R);
          if ( !v13 )
          {
            v13 = ecp_select_comb(grpa, &Txi, T, T_size, x[v11]);
            if ( !v13 )
              continue;
          }
        }
        break;
      }
    }
  }
  mbedtls_ecp_point_free(&Txi);
  return v13;
}

//----- (08003F2A) --------------------------------------------------------
int __fastcall ecp_mul_mxz(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng)
{
  int v10; // r4
  mbedtls_mpi_0 *v11; // r11
  size_t v12; // r7
  unsigned int v13; // r9
  int v15; // r0
  mbedtls_ecp_point_0 RP; // [sp+8h] [bp-58h] BYREF
  mbedtls_mpi_0 PX; // [sp+2Ch] [bp-34h] BYREF

  mbedtls_ecp_point_init(&RP);
  mbedtls_mpi_init(&PX);
  v10 = mbedtls_mpi_copy(&PX, &P->X);
  if ( !v10 )
  {
    v10 = mbedtls_ecp_copy(&RP, P);
    if ( !v10 )
    {
      v10 = mbedtls_mpi_lset(&R->X, 1);
      if ( !v10 )
      {
        v11 = &R->Z;
        v10 = mbedtls_mpi_lset(&R->Z, 0);
        if ( !v10 )
        {
          mbedtls_mpi_free(&R->Y);
          while ( mbedtls_mpi_cmp_mpi(&RP.X, &grp->P) >= 0 )
          {
            v10 = mbedtls_mpi_sub_abs(&RP.X, &RP.X, &grp->P);
            if ( v10 )
              goto LABEL_22;
          }
          if ( !f_rng || (v10 = ecp_randomize_mxz(grp, &RP, f_rng, p_rng)) == 0 )
          {
            v12 = mbedtls_mpi_bitlen(m);
            while ( v12-- != 0 )
            {
              v13 = (unsigned __int8)mbedtls_mpi_get_bit(m, v12);
              v10 = mbedtls_mpi_safe_cond_swap(&R->X, &RP.X, v13);
              if ( !v10 )
              {
                v10 = mbedtls_mpi_safe_cond_swap(&R->Z, &RP.Z, v13);
                if ( !v10 )
                {
                  v10 = ecp_double_add_mxz(grp, R, &RP, R, &RP, &PX);
                  if ( !v10 )
                  {
                    v10 = mbedtls_mpi_safe_cond_swap(&R->X, &RP.X, v13);
                    if ( !v10 )
                    {
                      v10 = mbedtls_mpi_safe_cond_swap(&R->Z, &RP.Z, v13);
                      if ( !v10 )
                        continue;
                    }
                  }
                }
              }
              goto LABEL_22;
            }
            v15 = mbedtls_mpi_inv_mod(&R->Z, &R->Z, &grp->P);
            if ( !v15 )
            {
              v15 = mbedtls_mpi_mul_mpi(&R->X, &R->X, v11);
              if ( !v15 )
              {
                v15 = ecp_modp(&R->X, grp);
                if ( !v15 )
                  v15 = mbedtls_mpi_lset(v11, 1);
              }
            }
            v10 = v15;
          }
        }
      }
    }
  }
LABEL_22:
  mbedtls_ecp_point_free(&RP);
  mbedtls_mpi_free(&PX);
  return v10;
}

//----- (08004062) --------------------------------------------------------
int __fastcall ecp_normalize_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *pt)
{
  mbedtls_mpi_0 *v4; // r7
  int result; // r0
  int v6; // r4
  mbedtls_mpi_0 *v7; // r5
  mbedtls_mpi_0 Zi; // [sp+0h] [bp-30h] BYREF
  mbedtls_mpi_0 ZZi; // [sp+Ch] [bp-24h] BYREF

  v4 = &pt->Z;
  result = mbedtls_mpi_cmp_int(&pt->Z, 0);
  if ( result )
  {
    mbedtls_mpi_init(&Zi);
    mbedtls_mpi_init(&ZZi);
    v6 = mbedtls_mpi_inv_mod(&Zi, v4, &grp->P);
    if ( !v6 )
    {
      v6 = mbedtls_mpi_mul_mpi(&ZZi, &Zi, &Zi);
      if ( !v6 )
      {
        v6 = ecp_modp(&ZZi, grp);
        if ( !v6 )
        {
          v6 = mbedtls_mpi_mul_mpi(&pt->X, &pt->X, &ZZi);
          if ( !v6 )
          {
            v6 = ecp_modp(&pt->X, grp);
            if ( !v6 )
            {
              v7 = &pt->Y;
              v6 = mbedtls_mpi_mul_mpi(v7, v7, &ZZi);
              if ( !v6 )
              {
                v6 = ecp_modp(v7, grp);
                if ( !v6 )
                {
                  v6 = mbedtls_mpi_mul_mpi(v7, v7, &Zi);
                  if ( !v6 )
                  {
                    v6 = ecp_modp(v7, grp);
                    if ( !v6 )
                      v6 = mbedtls_mpi_lset(v4, 1);
                  }
                }
              }
            }
          }
        }
      }
    }
    mbedtls_mpi_free(&Zi);
    mbedtls_mpi_free(&ZZi);
    result = v6;
  }
  return result;
}

//----- (0800411C) --------------------------------------------------------
int __fastcall ecp_normalize_jac_many(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 **T, size_t T_size)
{
  mbedtls_mpi_0 *v7; // r7
  size_t i; // r4
  int v9; // r4
  size_t j; // r5
  mbedtls_mpi_0 *v11; // r10
  size_t k; // r5
  int v13; // r0
  int v14; // r0
  int v15; // r0
  size_t l; // r5
  mbedtls_mpi_0 u; // [sp+8h] [bp-50h] BYREF
  mbedtls_mpi_0 ZZi; // [sp+14h] [bp-44h] BYREF
  mbedtls_mpi_0 Zi; // [sp+24h] [bp-34h] BYREF

  if ( T_size < 2 )
    return ecp_normalize_jac(grp, *T);
  v7 = (mbedtls_mpi_0 *)calloc(T_size, 0xCu);
  if ( !v7 )
    return -19840;
  for ( i = 0; i < T_size; ++i )
    mbedtls_mpi_init(&v7[i]);
  mbedtls_mpi_init(&u);
  mbedtls_mpi_init(&Zi);
  mbedtls_mpi_init(&ZZi);
  v9 = mbedtls_mpi_copy(v7, &(*T)->Z);
  if ( !v9 )
  {
    for ( j = 1; j < T_size; ++j )
    {
      v11 = &v7[j];
      v9 = mbedtls_mpi_mul_mpi(v11, v11 - 1, &T[j]->Z);
      if ( v9 )
        goto LABEL_39;
      v9 = ecp_modp(v11, grp);
      if ( v9 )
        goto LABEL_39;
    }
    v9 = mbedtls_mpi_inv_mod(&u, &v7[T_size - 1], &grp->P);
    if ( !v9 )
    {
      for ( k = T_size - 1; ; --k )
      {
        if ( k )
        {
          v9 = mbedtls_mpi_mul_mpi(&Zi, &u, &v7[k - 1]);
          if ( v9 )
            break;
          v14 = ecp_modp(&Zi, grp);
          v9 = v14;
          if ( v14 )
            break;
          v9 = mbedtls_mpi_mul_mpi(&u, &u, &T[k]->Z);
          if ( v9 )
            break;
          v13 = ecp_modp(&u, grp);
        }
        else
        {
          v13 = mbedtls_mpi_copy(&Zi, &u);
        }
        v9 = v13;
        if ( v13 )
          break;
        v9 = mbedtls_mpi_mul_mpi(&ZZi, &Zi, &Zi);
        if ( v9 )
          break;
        v9 = ecp_modp(&ZZi, grp);
        if ( v9 )
          break;
        v9 = mbedtls_mpi_mul_mpi(&T[k]->X, &T[k]->X, &ZZi);
        if ( v9 )
          break;
        v9 = ecp_modp(&T[k]->X, grp);
        if ( v9 )
          break;
        v9 = mbedtls_mpi_mul_mpi(&T[k]->Y, &T[k]->Y, &ZZi);
        if ( v9 )
          break;
        v9 = ecp_modp(&T[k]->Y, grp);
        if ( v9 )
          break;
        v15 = mbedtls_mpi_mul_mpi(&T[k]->Y, &T[k]->Y, &Zi);
        v9 = v15;
        if ( v15 )
          break;
        v9 = ecp_modp(&T[k]->Y, grp);
        if ( v9 )
          break;
        v9 = mbedtls_mpi_shrink(&T[k]->X, grp->P.n);
        if ( v9 )
          break;
        v9 = mbedtls_mpi_shrink(&T[k]->Y, grp->P.n);
        if ( v9 )
          break;
        mbedtls_mpi_free(&T[k]->Z);
        if ( !k )
          break;
      }
    }
  }
LABEL_39:
  mbedtls_mpi_free(&u);
  mbedtls_mpi_free(&Zi);
  mbedtls_mpi_free(&ZZi);
  for ( l = 0; l < T_size; ++l )
    mbedtls_mpi_free(&v7[l]);
  free((int)v7);
  return v9;
}

//----- (08004308) --------------------------------------------------------
int __fastcall ecp_precompute_comb(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *T, const mbedtls_ecp_point_0 *P, int w, size_t d, mbedtls_ecp_restart_ctx *rs_ctx)
{
  int v7; // r8
  unsigned int v9; // r7
  size_t v10; // r5
  int result; // r0
  size_t v12; // r8
  unsigned int v13; // r0
  mbedtls_ecp_point_0 *v14; // r10
  size_t v15; // r2
  unsigned int v16; // r0
  unsigned int i; // r6
  unsigned int v18; // r5
  size_t j; // r2
  mbedtls_ecp_point_0 *TT[31]; // [sp+0h] [bp-A0h] BYREF

  v7 = w - 1;
  v9 = (unsigned __int8)(1 << (w - 1));
  v10 = 0;
  result = mbedtls_ecp_copy(T, P);
  if ( !result )
  {
    v12 = v7 * d;
    while ( v12 > v10 )
    {
      v13 = (unsigned __int8)(1 << (v10 / d));
      v14 = &T[v13];
      if ( v10 == d * (v10 / d) )
      {
        result = mbedtls_ecp_copy(v14, &T[v13 >> 1]);
        if ( result )
          return result;
      }
      result = ecp_double_jac(grp, v14, v14);
      if ( result )
        return result;
      ++v10;
    }
    v15 = 0;
    v16 = 1;
    while ( v16 < v9 )
    {
      TT[v15] = &T[v16];
      v16 = (unsigned __int8)(2 * v16);
      ++v15;
    }
    result = ecp_normalize_jac_many(grp, TT, v15);
    if ( !result )
    {
      for ( i = 1; i < v9; i = (unsigned __int8)(2 * i) )
      {
        v18 = i;
        while ( v18-- != 0 )
        {
          result = ecp_add_mixed(grp, &T[i + v18], &T[v18], &T[i]);
          if ( result )
            return result;
        }
      }
      for ( j = 0; j + 1 < v9; ++j )
        TT[j] = &T[j + 1];
      result = ecp_normalize_jac_many(grp, TT, j);
    }
  }
  return result;
}

//----- (08004410) --------------------------------------------------------
int __fastcall ecp_randomize_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *pt, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng)
{
  size_t v5; // r8
  int v9; // r6
  int i; // r0
  int v11; // r4
  int v12; // r0
  mbedtls_mpi_0 l; // [sp+0h] [bp-38h] BYREF
  mbedtls_mpi_0 ll; // [sp+Ch] [bp-2Ch] BYREF

  v5 = (grp->pbits + 7) >> 3;
  v9 = 0;
  mbedtls_mpi_init(&l);
  mbedtls_mpi_init(&ll);
LABEL_2:
  for ( i = mbedtls_mpi_fill_random(&l, v5, f_rng, p_rng); ; i = mbedtls_mpi_shift_r(&l, 1u) )
  {
    v11 = i;
    if ( i )
      break;
    if ( mbedtls_mpi_cmp_mpi(&l, &grp->P) < 0 )
    {
      v12 = v9++;
      if ( v12 > 10 )
        return -19712;
      if ( mbedtls_mpi_cmp_int(&l, 1) > 0 )
      {
        v11 = mbedtls_mpi_mul_mpi(&pt->Z, &pt->Z, &l);
        if ( !v11 )
        {
          v11 = ecp_modp(&pt->Z, grp);
          if ( !v11 )
          {
            v11 = mbedtls_mpi_mul_mpi(&ll, &l, &l);
            if ( !v11 )
            {
              v11 = ecp_modp(&ll, grp);
              if ( !v11 )
              {
                v11 = mbedtls_mpi_mul_mpi(&pt->X, &pt->X, &ll);
                if ( !v11 )
                {
                  v11 = ecp_modp(&pt->X, grp);
                  if ( !v11 )
                  {
                    v11 = mbedtls_mpi_mul_mpi(&ll, &ll, &l);
                    if ( !v11 )
                    {
                      v11 = ecp_modp(&ll, grp);
                      if ( !v11 )
                      {
                        v11 = mbedtls_mpi_mul_mpi(&pt->Y, &pt->Y, &ll);
                        if ( !v11 )
                          v11 = ecp_modp(&pt->Y, grp);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;
      }
      goto LABEL_2;
    }
  }
  mbedtls_mpi_free(&l);
  mbedtls_mpi_free(&ll);
  return v11;
}

//----- (08004514) --------------------------------------------------------
int __fastcall ecp_randomize_mxz(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng)
{
  size_t v6; // r8
  int v9; // r6
  int i; // r0
  int v11; // r4
  int v12; // r0
  mbedtls_mpi_0 l; // [sp+0h] [bp-30h] BYREF

  l.s = (int)P;
  l.n = (size_t)f_rng;
  l.p = (mbedtls_mpi_uint *)p_rng;
  v6 = (grp->pbits + 7) >> 3;
  v9 = 0;
  mbedtls_mpi_init(&l);
LABEL_2:
  for ( i = mbedtls_mpi_fill_random(&l, v6, f_rng, p_rng); ; i = mbedtls_mpi_shift_r(&l, 1u) )
  {
    v11 = i;
    if ( i )
      break;
    if ( mbedtls_mpi_cmp_mpi(&l, &grp->P) < 0 )
    {
      v12 = v9++;
      if ( v12 > 10 )
        return -19712;
      if ( mbedtls_mpi_cmp_int(&l, 1) > 0 )
      {
        v11 = mbedtls_mpi_mul_mpi(&P->X, &P->X, &l);
        if ( !v11 )
        {
          v11 = ecp_modp(&P->X, grp);
          if ( !v11 )
          {
            v11 = mbedtls_mpi_mul_mpi(&P->Z, &P->Z, &l);
            if ( !v11 )
              v11 = ecp_modp(&P->Z, grp);
          }
        }
        break;
      }
      goto LABEL_2;
    }
  }
  mbedtls_mpi_free(&l);
  return v11;
}

//----- (080045B4) --------------------------------------------------------
int __fastcall ecp_safe_invert_jac(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *Q, unsigned __int8 inv)
{
  int v4; // r6
  mbedtls_mpi_0 *v6; // r5
  int v7; // r4
  _BOOL4 v8; // r0
  mbedtls_mpi_0 mQY; // [sp+0h] [bp-20h] BYREF

  mQY.s = (int)Q;
  mQY.n = inv;
  v4 = inv;
  mbedtls_mpi_init(&mQY);
  v6 = &Q->Y;
  v7 = mbedtls_mpi_sub_mpi(&mQY, &grp->P, v6);
  if ( !v7 )
  {
    v8 = mbedtls_mpi_cmp_int(v6, 0) != 0;
    v7 = mbedtls_mpi_safe_cond_assign(v6, &mQY, v4 & v8);
  }
  mbedtls_mpi_free(&mQY);
  return v7;
}

//----- (080045F8) --------------------------------------------------------
int __fastcall ecp_select_comb(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_ecp_point_0 *T, unsigned int T_size, unsigned int i)
{
  int v9; // r5
  unsigned int j; // r4
  int result; // r0

  v9 = (i >> 1) & 0x3F;
  for ( j = 0; j < T_size; j = (unsigned __int8)(j + 1) )
  {
    result = mbedtls_mpi_safe_cond_assign(&R->X, &T[j].X, j == v9);
    if ( result )
      return result;
    result = mbedtls_mpi_safe_cond_assign(&R->Y, &T[j].Y, j == v9);
    if ( result )
      return result;
  }
  return ecp_safe_invert_jac(grp, R, i >> 7);
}

//----- (08004660) --------------------------------------------------------
int __fastcall ecp_use_curve25519(mbedtls_ecp_group_0 *grp)
{
  int v2; // r5

  v2 = mbedtls_mpi_read_string(&grp->A, 16, "01DB42");
  if ( v2 )
    goto LABEL_9;
  v2 = mbedtls_mpi_lset(&grp->P, 1);
  if ( v2
    || (v2 = mbedtls_mpi_shift_l(&grp->P, 0xFFu)) != 0
    || (v2 = mbedtls_mpi_sub_int(&grp->P, &grp->P, 19)) != 0
    || (grp->pbits = mbedtls_mpi_bitlen(&grp->P),
        (v2 = mbedtls_mpi_read_string(&grp->N, 16, "14DEF9DEA2F79CD65812631A5CF5D3ED")) != 0)
    || (v2 = mbedtls_mpi_set_bit(&grp->N, 0xFCu, 1u)) != 0
    || (v2 = mbedtls_mpi_lset(&grp->G.X, 9)) != 0
    || (v2 = mbedtls_mpi_lset(&grp->G.Z, 1)) != 0 )
  {
LABEL_9:
    mbedtls_ecp_group_free(grp);
  }
  else
  {
    mbedtls_mpi_free(&grp->G.Y);
    grp->nbits = 254;
  }
  return v2;
}

//----- (08004720) --------------------------------------------------------
int __fastcall ecp_use_curve448(mbedtls_ecp_group_0 *grp)
{
  int v2; // r5
  mbedtls_mpi_0 Ns; // [sp+0h] [bp-20h] BYREF

  mbedtls_mpi_init(&Ns);
  v2 = mbedtls_mpi_read_string(&grp->A, 16, "98AA");
  if ( !v2 )
  {
    v2 = mbedtls_mpi_lset(&grp->P, 1);
    if ( !v2 )
    {
      v2 = mbedtls_mpi_shift_l(&grp->P, 0xE0u);
      if ( !v2 )
      {
        v2 = mbedtls_mpi_sub_int(&grp->P, &grp->P, 1);
        if ( !v2 )
        {
          v2 = mbedtls_mpi_shift_l(&grp->P, 0xE0u);
          if ( !v2 )
          {
            v2 = mbedtls_mpi_sub_int(&grp->P, &grp->P, 1);
            if ( !v2 )
            {
              grp->pbits = mbedtls_mpi_bitlen(&grp->P);
              v2 = mbedtls_mpi_lset(&grp->G.X, 5);
              if ( !v2 )
              {
                v2 = mbedtls_mpi_lset(&grp->G.Z, 1);
                if ( !v2 )
                {
                  mbedtls_mpi_free(&grp->G.Y);
                  v2 = mbedtls_mpi_set_bit(&grp->N, 0x1BEu, 1u);
                  if ( !v2 )
                  {
                    v2 = mbedtls_mpi_read_string(&Ns, 16, "8335DC163BB124B65129C96FDE933D8D723A70AADC873D6D54A7BB0D");
                    if ( !v2 )
                    {
                      v2 = mbedtls_mpi_sub_mpi(&grp->N, &grp->N, &Ns);
                      if ( !v2 )
                        grp->nbits = 447;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  mbedtls_mpi_free(&Ns);
  if ( v2 )
    mbedtls_ecp_group_free(grp);
  return v2;
}

//----- (08004834) --------------------------------------------------------
int __fastcall encrypt_g(uint16_t g, uint8_t k, uint8_t *key)
{
  char v3; // r4
  char v4; // r5
  uint8_t v6; // r6
  uint8_t v7; // r5
  uint16_t ga; // [sp+0h] [bp-20h]

  v3 = 4 * k;
  v4 = g;
  v6 = encrypt_sub_g(g, 4 * k, key) ^ HIBYTE(g);
  v7 = encrypt_sub_g(v6, v3 + 1, key) ^ v4;
  HIBYTE(ga) = encrypt_sub_g(v7, v3 + 2, key) ^ v6;
  LOBYTE(ga) = encrypt_sub_g(HIBYTE(ga), v3 + 3, key) ^ v7;
  return ga;
}

//----- (0800488A) --------------------------------------------------------
int __fastcall encrypt_g_inv(uint16_t g, uint8_t k, uint8_t *key)
{
  uint8_t v3; // r4
  char v4; // r5
  uint8_t v6; // r6
  uint8_t v7; // r5
  uint16_t ga; // [sp+0h] [bp-20h]

  v3 = 4 * k;
  v4 = HIBYTE(g);
  v6 = encrypt_sub_g(HIBYTE(g), 4 * k + 3, key) ^ g;
  v7 = encrypt_sub_g(v6, v3 + 2, key) ^ v4;
  LOBYTE(ga) = encrypt_sub_g(v7, v3 + 1, key) ^ v6;
  HIBYTE(ga) = encrypt_sub_g(ga, v3, key) ^ v7;
  return ga;
}

//----- (080048E0) --------------------------------------------------------
uint16_t __fastcall encrypt_sub_g(uint8_t g, uint8_t k, uint8_t *key)
{
  return m_ptable[key[7 - (k & 7)] ^ g];
}

//----- (080048F8) --------------------------------------------------------
int __fastcall fix_negative(mbedtls_mpi_0 *N, int c, mbedtls_mpi_0 *C, size_t bits)
{
  int result; // r0

  C->p[C->n - 1] = -c;
  result = mbedtls_mpi_sub_abs(N, C, N);
  if ( !result )
    N->s = -1;
  return result;
}

//----- (08004924) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  GPIO_InitTypeDef v3; // [sp+0h] [bp-18h] BYREF
  int v4; // [sp+10h] [bp-8h]

  HAL_Init();
  SystemClock_Config();
  MEMORY[0x40021018] |= 0x10u;
  MEMORY[0x40021018] |= 4u;
  v4 = MEMORY[0x40021018] & 4;
  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000, 0x2000u, GPIO_PIN_SET);
  v3.Pin = 0x2000;
  v3.Mode = 1;
  v3.Pull = 0;
  v3.Speed = 2;
  HAL_GPIO_Init((GPIO_TypeDef *)0x40011000, &v3);
  hcrc.Instance = (CRC_TypeDef *)1073885184;
  if ( HAL_CRC_Init(&hcrc) )
  {
    __disable_irq();
    while ( 1 )
      ;
  }
  huart1.Instance = (USART_TypeDef *)1073821696;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = 0;
  huart1.Init.StopBits = 0;
  huart1.Init.Parity = 0;
  huart1.Init.Mode = 12;
  huart1.Init.HwFlowCtl = 0;
  huart1.Init.OverSampling = 0;
  if ( HAL_UART_Init(&huart1) )
  {
    __disable_irq();
    while ( 1 )
      ;
  }
  while ( 1 )
    advance_software_protect_samples();
}

//----- (080049D0) --------------------------------------------------------
int __fastcall mbedtls_asn1_get_len(unsigned __int8 **p, const unsigned __int8 *end, size_t *len)
{
  unsigned __int8 *v3; // r3
  int v4; // r4
  int v5; // r5
  unsigned __int8 *v7; // r3

  v3 = *p;
  v4 = end - *p;
  if ( v4 < 1 )
    return -96;
  if ( (*v3 & 0x80) == 0 )
  {
    *p = v3 + 1;
    *len = *v3;
    goto LABEL_18;
  }
  v5 = *v3 & 0x7F;
  switch ( v5 )
  {
    case 1:
      if ( v4 < 2 )
        return -96;
      *len = v3[1];
      v7 = *p + 2;
      break;
    case 2:
      if ( v4 < 3 )
        return -96;
      *len = __rev16(*(unsigned __int16 *)(v3 + 1));
      v7 = *p + 3;
      break;
    case 3:
      if ( v4 >= 4 )
      {
        *len = (v3[1] << 16) | (v3[2] << 8) | v3[3];
        v7 = *p + 4;
        break;
      }
      return -96;
    case 4:
      if ( v4 < 5 )
        return -96;
      *len = bswap32(*(_DWORD *)(v3 + 1)) & 0xFFFFFF00 | v3[4];
      v7 = *p + 5;
      break;
    default:
      return -100;
  }
  *p = v7;
LABEL_18:
  if ( *len > end - *p )
    return -96;
  return 0;
}

//----- (08004A6E) --------------------------------------------------------
int __fastcall mbedtls_asn1_get_mpi(unsigned __int8 **p, const unsigned __int8 *end, mbedtls_mpi_0 *X)
{
  int result; // r0
  size_t len; // [sp+0h] [bp-10h] BYREF

  result = mbedtls_asn1_get_tag(p, end, &len, 2);
  if ( !result )
  {
    result = mbedtls_mpi_read_binary(X, *p, len);
    *p += len;
  }
  return result;
}

//----- (08004A94) --------------------------------------------------------
int __fastcall mbedtls_asn1_get_tag(unsigned __int8 **p, const unsigned __int8 *end, size_t *len, int tag)
{
  unsigned __int8 *v4; // r4

  v4 = *p;
  if ( end - *p < 1 )
    return -96;
  if ( *v4 != tag )
    return -98;
  *p = v4 + 1;
  return mbedtls_asn1_get_len(p, end, len);
}

//----- (08004ABC) --------------------------------------------------------
void __fastcall mbedtls_ecdsa_free(mbedtls_ecdsa_context *ctx)
{
  if ( ctx )
    mbedtls_ecp_keypair_free(ctx);
}

//----- (08004AC6) --------------------------------------------------------
int __fastcall mbedtls_ecdsa_read_signature(mbedtls_ecdsa_context *ctx, const unsigned __int8 *hash, size_t hlen, const unsigned __int8 *sig, size_t slen)
{
  return mbedtls_ecdsa_read_signature_restartable(ctx, hash, hlen, sig, slen, 0);
}

//----- (08004AD8) --------------------------------------------------------
int __fastcall mbedtls_ecdsa_read_signature_restartable(mbedtls_ecdsa_context *ctx, const unsigned __int8 *hash, size_t hlen, const unsigned __int8 *sig, size_t slen, mbedtls_ecdsa_restart_ctx *rs_ctx)
{
  const unsigned __int8 *v7; // r5
  int v10; // r0
  int v11; // r4
  unsigned __int8 *p; // [sp+Ch] [bp-3Ch] BYREF
  size_t len; // [sp+10h] [bp-38h] BYREF
  mbedtls_mpi_0 r; // [sp+14h] [bp-34h] BYREF
  mbedtls_mpi_0 s; // [sp+20h] [bp-28h] BYREF

  v7 = &sig[slen];
  p = (unsigned __int8 *)sig;
  mbedtls_mpi_init(&r);
  mbedtls_mpi_init(&s);
  v10 = mbedtls_asn1_get_tag(&p, v7, &len, 48);
  if ( v10 )
    goto LABEL_6;
  if ( &p[len] != v7 )
  {
    v11 = -20454;
    goto LABEL_10;
  }
  v10 = mbedtls_asn1_get_mpi(&p, v7, &r);
  if ( v10 || (v10 = mbedtls_asn1_get_mpi(&p, v7, &s)) != 0 )
  {
LABEL_6:
    v11 = v10 - 20352;
    goto LABEL_10;
  }
  v11 = ecdsa_verify_restartable(&ctx->grp, hash, hlen, &ctx->Q, &r, &s, rs_ctx);
  if ( !v11 && p != v7 )
    v11 = -19456;
LABEL_10:
  mbedtls_mpi_free(&r);
  mbedtls_mpi_free(&s);
  return v11;
}

//----- (08004B74) --------------------------------------------------------
int __fastcall mbedtls_ecp_check_privkey(const mbedtls_ecp_group_0 *grp, const mbedtls_mpi_0 *d)
{
  size_t v5; // r0
  size_t v6; // r1

  if ( mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY )
  {
    if ( mbedtls_mpi_get_bit(d, 0) )
      return -19584;
    if ( mbedtls_mpi_get_bit(d, 1u) )
      return -19584;
    v5 = mbedtls_mpi_bitlen(d);
    v6 = grp->nbits;
    if ( v5 - 1 != v6 || v6 == 254 && mbedtls_mpi_get_bit(d, 2u) )
      return -19584;
  }
  else
  {
    if ( mbedtls_ecp_get_type(grp) != MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
      return -20352;
    if ( mbedtls_mpi_cmp_int(d, 1) < 0 || mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0 )
      return -19584;
  }
  return 0;
}

//----- (08004BF0) --------------------------------------------------------
int __fastcall mbedtls_ecp_check_pubkey(const mbedtls_ecp_group_0 *grp, const mbedtls_ecp_point_0 *pt)
{
  int result; // r0

  if ( mbedtls_mpi_cmp_int(&pt->Z, 1) )
    return -19584;
  if ( mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY )
  {
    if ( mbedtls_mpi_size(&pt->X) <= (grp->nbits + 7) >> 3 )
      return 0;
    return -19584;
  }
  if ( mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
    result = ecp_check_pubkey_sw(grp, pt);
  else
    result = -20352;
  return result;
}

//----- (08004C48) --------------------------------------------------------
int __fastcall mbedtls_ecp_copy(mbedtls_ecp_point_0 *P, const mbedtls_ecp_point_0 *Q)
{
  int result; // r0

  result = mbedtls_mpi_copy(&P->X, &Q->X);
  if ( !result )
  {
    result = mbedtls_mpi_copy(&P->Y, &Q->Y);
    if ( !result )
      result = mbedtls_mpi_copy(&P->Z, &Q->Z);
  }
  return result;
}

//----- (08004C78) --------------------------------------------------------
const mbedtls_ecp_curve_info_0 *__fastcall mbedtls_ecp_curve_info_from_tls_id(uint16_t tls_id)
{
  int v1; // r1
  const mbedtls_ecp_curve_info_0 *result; // r0

  v1 = tls_id;
  for ( result = ecp_supported_curves; result->grp_id; ++result )
  {
    if ( result->tls_id == v1 )
      return result;
  }
  return 0;
}

//----- (08004C94) --------------------------------------------------------
mbedtls_ecp_curve_type __fastcall mbedtls_ecp_get_type(const mbedtls_ecp_group_0 *grp)
{
  if ( !grp->G.X.p )
    return 0;
  if ( grp->G.Y.p )
    return 1;
  return 2;
}

//----- (08004CA8) --------------------------------------------------------
void __fastcall mbedtls_ecp_group_free(mbedtls_ecp_group_0 *grp)
{
  size_t i; // r5
  mbedtls_ecp_point_0 *v3; // r0

  if ( grp )
  {
    if ( grp->h != 1 )
    {
      mbedtls_mpi_free(&grp->P);
      mbedtls_mpi_free(&grp->A);
      mbedtls_mpi_free(&grp->B);
      mbedtls_ecp_point_free(&grp->G);
      mbedtls_mpi_free(&grp->N);
    }
    if ( grp->T )
    {
      for ( i = 0; ; ++i )
      {
        v3 = grp->T;
        if ( grp->T_size <= i )
          break;
        mbedtls_ecp_point_free(&v3[i]);
      }
      free((int)v3);
    }
    mbedtls_platform_zeroize(grp, 0x7Cu);
  }
}

//----- (08004D0C) --------------------------------------------------------
void __fastcall mbedtls_ecp_group_init(mbedtls_ecp_group_0 *grp)
{
  grp->id = MBEDTLS_ECP_DP_NONE;
  mbedtls_mpi_init(&grp->P);
  mbedtls_mpi_init(&grp->A);
  mbedtls_mpi_init(&grp->B);
  mbedtls_ecp_point_init(&grp->G);
  mbedtls_mpi_init(&grp->N);
  grp->pbits = 0;
  grp->nbits = 0;
  grp->h = 0;
  grp->modp = 0;
  grp->t_pre = 0;
  grp->t_post = 0;
  grp->t_data = 0;
  grp->T = 0;
  grp->T_size = 0;
}

//----- (08004D50) --------------------------------------------------------
int __fastcall mbedtls_ecp_group_load(mbedtls_ecp_group_0 *grp, mbedtls_ecp_group_id id)
{
  int v2; // r5
  int result; // r0

  v2 = id;
  mbedtls_ecp_group_free(grp);
  grp->id = v2;
  switch ( v2 )
  {
    case 1:
      grp->modp = ecp_mod_p192;
      result = ecp_group_load(
                 grp,
                 secp192r1_p,
                 0x18u,
                 0,
                 0,
                 secp192r1_b,
                 0x18u,
                 secp192r1_gx,
                 0x18u,
                 secp192r1_gy,
                 0x18u,
                 secp192r1_n,
                 0x18u);
      break;
    case 2:
      grp->modp = ecp_mod_p224;
      result = ecp_group_load(
                 grp,
                 secp224r1_p,
                 0x20u,
                 0,
                 0,
                 secp224r1_b,
                 0x1Cu,
                 secp224r1_gx,
                 0x1Cu,
                 secp224r1_gy,
                 0x1Cu,
                 secp224r1_n,
                 0x1Cu);
      break;
    case 3:
      grp->modp = ecp_mod_p256;
      result = ecp_group_load(
                 grp,
                 secp256r1_p,
                 0x20u,
                 0,
                 0,
                 secp256r1_b,
                 0x20u,
                 secp256r1_gx,
                 0x20u,
                 secp256r1_gy,
                 0x20u,
                 secp256r1_n,
                 0x20u);
      break;
    case 4:
      grp->modp = ecp_mod_p384;
      result = ecp_group_load(
                 grp,
                 secp384r1_p,
                 0x30u,
                 0,
                 0,
                 secp384r1_b,
                 0x30u,
                 secp384r1_gx,
                 0x30u,
                 secp384r1_gy,
                 0x30u,
                 secp384r1_n,
                 0x30u);
      break;
    case 5:
      grp->modp = ecp_mod_p521;
      result = ecp_group_load(
                 grp,
                 secp521r1_p,
                 0x44u,
                 0,
                 0,
                 secp521r1_b,
                 0x44u,
                 secp521r1_gx,
                 0x44u,
                 secp521r1_gy,
                 0x44u,
                 secp521r1_n,
                 0x44u);
      break;
    case 6:
      result = ecp_group_load(
                 grp,
                 brainpoolP256r1_p,
                 0x20u,
                 brainpoolP256r1_a,
                 0x20u,
                 brainpoolP256r1_b,
                 0x20u,
                 brainpoolP256r1_gx,
                 0x20u,
                 brainpoolP256r1_gy,
                 0x20u,
                 brainpoolP256r1_n,
                 0x20u);
      break;
    case 7:
      result = ecp_group_load(
                 grp,
                 brainpoolP384r1_p,
                 0x30u,
                 brainpoolP384r1_a,
                 0x30u,
                 brainpoolP384r1_b,
                 0x30u,
                 brainpoolP384r1_gx,
                 0x30u,
                 brainpoolP384r1_gy,
                 0x30u,
                 brainpoolP384r1_n,
                 0x30u);
      break;
    case 8:
      result = ecp_group_load(
                 grp,
                 brainpoolP512r1_p,
                 0x40u,
                 brainpoolP512r1_a,
                 0x40u,
                 brainpoolP512r1_b,
                 0x40u,
                 brainpoolP512r1_gx,
                 0x40u,
                 brainpoolP512r1_gy,
                 0x40u,
                 brainpoolP512r1_n,
                 0x40u);
      break;
    case 9:
      grp->modp = ecp_mod_p255;
      result = ecp_use_curve25519(grp);
      break;
    case 10:
      grp->modp = ecp_mod_p192k1;
      result = ecp_group_load(
                 grp,
                 secp192k1_p,
                 0x18u,
                 secp192k1_a,
                 4u,
                 secp192k1_b,
                 4u,
                 secp192k1_gx,
                 0x18u,
                 secp192k1_gy,
                 0x18u,
                 secp192k1_n,
                 0x18u);
      break;
    case 11:
      grp->modp = ecp_mod_p224k1;
      result = ecp_group_load(
                 grp,
                 secp224k1_p,
                 0x1Cu,
                 secp224k1_a,
                 4u,
                 secp224k1_b,
                 4u,
                 secp224k1_gx,
                 0x1Cu,
                 secp224k1_gy,
                 0x1Cu,
                 secp224k1_n,
                 0x20u);
      break;
    case 12:
      grp->modp = ecp_mod_p256k1;
      result = ecp_group_load(
                 grp,
                 secp256k1_p,
                 0x20u,
                 secp256k1_a,
                 4u,
                 secp256k1_b,
                 4u,
                 secp256k1_gx,
                 0x20u,
                 secp256k1_gy,
                 0x20u,
                 secp256k1_n,
                 0x20u);
      break;
    case 13:
      grp->modp = ecp_mod_p448;
      result = ecp_use_curve448(grp);
      break;
    default:
      mbedtls_ecp_group_free(grp);
      result = -20096;
      break;
  }
  return result;
}

//----- (08004FC8) --------------------------------------------------------
int __fastcall mbedtls_ecp_is_zero(mbedtls_ecp_point_0 *pt)
{
  return mbedtls_mpi_cmp_int(&pt->Z, 0) == 0;
}

//----- (08004FDC) --------------------------------------------------------
void __fastcall mbedtls_ecp_keypair_free(mbedtls_ecp_keypair_0 *key)
{
  if ( key )
  {
    mbedtls_ecp_group_free(&key->grp);
    mbedtls_mpi_free(&key->d);
    mbedtls_ecp_point_free(&key->Q);
  }
}

//----- (08004FFC) --------------------------------------------------------
void __fastcall mbedtls_ecp_keypair_init(mbedtls_ecp_keypair_0 *key)
{
  mbedtls_ecp_group_init(&key->grp);
  mbedtls_mpi_init(&key->d);
  mbedtls_ecp_point_init(&key->Q);
}

//----- (08005018) --------------------------------------------------------
int __fastcall mbedtls_ecp_mul_restartable(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng, mbedtls_ecp_restart_ctx *rs_ctx)
{
  int v11; // r2

  v11 = mbedtls_ecp_check_privkey(grp, m);
  if ( !v11 )
  {
    v11 = mbedtls_ecp_check_pubkey(grp, P);
    if ( !v11
      && (mbedtls_ecp_get_type(grp) != MBEDTLS_ECP_TYPE_MONTGOMERY
       || (v11 = ecp_mul_mxz(grp, R, m, P, f_rng, p_rng)) == 0)
      && mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
    {
      v11 = ecp_mul_comb(grp, R, m, P, f_rng, p_rng, rs_ctx);
    }
  }
  return v11;
}
// 8005080: variable 'v11' is possibly undefined

//----- (0800508C) --------------------------------------------------------
int __fastcall mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, mbedtls_ecp_restart_ctx *rs_ctx)
{
  int v10; // r4
  mbedtls_mpi_0 *v11; // r5

  if ( !mbedtls_mpi_cmp_int(m, 1) )
    return mbedtls_ecp_copy(R, P);
  if ( mbedtls_mpi_cmp_int(m, -1) )
    return mbedtls_ecp_mul_restartable(grp, R, m, P, 0, 0, rs_ctx);
  v10 = mbedtls_ecp_copy(R, P);
  if ( !v10 )
  {
    v11 = &R->Y;
    if ( mbedtls_mpi_cmp_int(v11, 0) )
      return mbedtls_mpi_sub_mpi(v11, &grp->P, v11);
  }
  return v10;
}

//----- (080050FC) --------------------------------------------------------
int __fastcall mbedtls_ecp_muladd_restartable(mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *R, const mbedtls_mpi_0 *m, const mbedtls_ecp_point_0 *P, const mbedtls_mpi_0 *n, const mbedtls_ecp_point_0 *Q, mbedtls_ecp_restart_ctx *rs_ctx)
{
  int v12; // r4
  mbedtls_ecp_point_0 mP; // [sp+4h] [bp-4Ch] BYREF

  if ( mbedtls_ecp_get_type(grp) != MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
    return -20096;
  mbedtls_ecp_point_init(&mP);
  v12 = mbedtls_ecp_mul_shortcuts(grp, &mP, m, P, rs_ctx);
  if ( !v12 )
  {
    v12 = mbedtls_ecp_mul_shortcuts(grp, R, n, Q, rs_ctx);
    if ( !v12 )
    {
      v12 = ecp_add_mixed(grp, R, &mP, R);
      if ( !v12 )
        v12 = ecp_normalize_jac(grp, R);
    }
  }
  mbedtls_ecp_point_free(&mP);
  return v12;
}

//----- (08005178) --------------------------------------------------------
void __fastcall mbedtls_ecp_point_free(mbedtls_ecp_point_0 *pt)
{
  if ( pt )
  {
    mbedtls_mpi_free(&pt->X);
    mbedtls_mpi_free(&pt->Y);
    mbedtls_mpi_free(&pt->Z);
  }
}

//----- (08005198) --------------------------------------------------------
void __fastcall mbedtls_ecp_point_init(mbedtls_ecp_point_0 *pt)
{
  mbedtls_mpi_init(&pt->X);
  mbedtls_mpi_init(&pt->Y);
  mbedtls_mpi_init(&pt->Z);
}

//----- (080051B4) --------------------------------------------------------
int __fastcall mbedtls_ecp_point_read_binary(const mbedtls_ecp_group_0 *grp, mbedtls_ecp_point_0 *pt, const unsigned __int8 *buf, size_t ilen)
{
  int v8; // r11
  size_t v9; // r5
  mbedtls_mpi_0 *v11; // [sp+0h] [bp-30h]
  mbedtls_mpi_0 *X; // [sp+4h] [bp-2Ch]

  v8 = -20096;
  if ( !ilen )
    return -20352;
  v9 = mbedtls_mpi_size(&grp->P);
  X = &pt->Y;
  v11 = &pt->Z;
  if ( mbedtls_ecp_get_type(grp) != MBEDTLS_ECP_TYPE_MONTGOMERY )
    goto LABEL_8;
  if ( v9 != ilen )
    return -20352;
  v8 = mbedtls_mpi_read_binary_le(&pt->X, buf, v9);
  if ( !v8 )
  {
    mbedtls_mpi_free(X);
    if ( grp->id != MBEDTLS_ECP_DP_CURVE25519 || (v8 = mbedtls_mpi_set_bit(&pt->X, 8 * v9 - 1, 0)) == 0 )
    {
      v8 = mbedtls_mpi_lset(v11, 1);
      if ( !v8 )
      {
LABEL_8:
        if ( mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
        {
          if ( !*buf )
          {
            if ( ilen == 1 )
              return mbedtls_ecp_set_zero(pt);
            return -20352;
          }
          if ( *buf != 4 )
            return -20096;
          if ( 2 * v9 + 1 != ilen )
            return -20352;
          v8 = mbedtls_mpi_read_binary(&pt->X, buf + 1, v9);
          if ( !v8 )
          {
            v8 = mbedtls_mpi_read_binary(X, &buf[v9 + 1], v9);
            if ( !v8 )
              v8 = mbedtls_mpi_lset(v11, 1);
          }
        }
      }
    }
  }
  return v8;
}

//----- (080052A0) --------------------------------------------------------
int __fastcall mbedtls_ecp_set_zero(mbedtls_ecp_point_0 *pt)
{
  int result; // r0

  result = mbedtls_mpi_lset(&pt->X, 1);
  if ( !result )
  {
    result = mbedtls_mpi_lset(&pt->Y, 1);
    if ( !result )
      result = mbedtls_mpi_lset(&pt->Z, 0);
  }
  return result;
}

//----- (080052CC) --------------------------------------------------------
int __fastcall mbedtls_ecp_tls_read_group(mbedtls_ecp_group_0 *grp, const unsigned __int8 **buf, size_t len)
{
  int result; // r0
  mbedtls_ecp_group_id grp_id; // [sp+0h] [bp-10h] BYREF

  result = mbedtls_ecp_tls_read_group_id(&grp_id, buf, len);
  if ( !result )
    result = mbedtls_ecp_group_load(grp, grp_id);
  return result;
}

//----- (080052E8) --------------------------------------------------------
int __fastcall mbedtls_ecp_tls_read_group_id(mbedtls_ecp_group_id *grp, const unsigned __int8 **buf, size_t len)
{
  const unsigned __int8 *v4; // r0
  const unsigned __int8 *v5; // r3
  __int16 v7; // r0
  const mbedtls_ecp_curve_info_0 *v8; // r0

  if ( len < 3 )
    return -20352;
  v4 = *buf;
  v5 = *buf + 1;
  *buf = v5;
  if ( *v4 != 3 )
    return -20352;
  *buf = v5 + 1;
  v7 = *v5 << 8;
  *buf = v5 + 2;
  v8 = mbedtls_ecp_curve_info_from_tls_id(v7 | v5[1]);
  if ( !v8 )
    return -20096;
  *grp = v8->grp_id;
  return 0;
}

//----- (08005334) --------------------------------------------------------
int __fastcall mbedtls_internal_sha256_process(mbedtls_sha256_context_0 *ctx, const unsigned __int8 *data)
{
  unsigned int i; // r0
  unsigned int j; // r0
  unsigned int v5; // r0
  uint32_t v6; // r1
  uint32_t v7; // r5
  int v8; // r1
  const uint32_t *v9; // r2
  uint32_t v10; // r5
  uint32_t *v11; // r1
  uint32_t v12; // r5
  uint32_t v13; // r5
  uint32_t v14; // r7
  int v15; // r5
  uint32_t v16; // r5
  uint32_t v17; // r7
  int v18; // r5
  uint32_t v19; // r5
  uint32_t v20; // r7
  int v21; // r5
  uint32_t v22; // r5
  uint32_t v23; // r7
  int v24; // r5
  uint32_t v25; // r5
  uint32_t v26; // r7
  int v27; // r5
  uint32_t v28; // r1
  unsigned int v29; // r1
  const uint32_t *v30; // r2
  uint32_t v31; // r4
  uint32_t *v32; // r0
  unsigned int v33; // r5
  int v34; // r3
  int v35; // r9
  int v36; // r7
  int v37; // t1
  uint32_t v38; // r3
  uint32_t v39; // r4
  uint32_t v40; // r7
  int v41; // r4
  uint32_t v42; // r10
  uint32_t v43; // r4
  uint32_t v44; // r6
  unsigned int v45; // r5
  uint32_t v46; // r4
  uint32_t v47; // r12
  int v48; // r4
  uint32_t v49; // r7
  uint32_t v50; // r4
  unsigned int v51; // r6
  uint32_t v52; // r7
  int v53; // r12
  uint32_t v54; // r5
  unsigned int v55; // r4
  int v56; // r12
  uint32_t v57; // r6
  unsigned int v58; // r5
  uint32_t v59; // r11
  int v60; // r12
  uint32_t v61; // r4
  unsigned int v62; // r6
  uint32_t v63; // r9
  uint32_t v64; // r7
  int v65; // r12
  uint32_t v66; // r5
  int v67; // r4
  uint32_t v68; // r4
  uint32_t v69; // r12
  int v70; // r4
  uint32_t v71; // r2
  int v72; // r3
  unsigned int k; // r0
  uint32_t *v74; // r2
  uint32_t v75; // r4
  uint32_t A[8]; // [sp+0h] [bp-144h]
  uint32_t W[64]; // [sp+20h] [bp-124h] BYREF

  for ( i = 0; i < 8; ++i )
    A[i] = ctx->state[i];
  for ( j = 0; j < 0x10; ++j )
    W[j] = bswap32(*(_DWORD *)&data[4 * j]) & 0xFFFFFF00 | data[4 * j + 3];
  v5 = 0;
  do
  {
    v6 = A[7]
       + K[v5]
       + (__ROR4__(A[4], 6) ^ __ROR4__(A[4], 11) ^ __ROR4__(A[4], 25))
       + ((A[5] ^ A[6]) & A[4] ^ A[6])
       + W[v5];
    v7 = A[3] + v6;
    A[7] = v6 + (A[0] & A[1] | (A[0] | A[1]) & A[2]) + (__ROR4__(A[0], 2) ^ __ROR4__(A[0], 13) ^ __ROR4__(A[0], 22));
    v8 = __ROR4__(A[3] + v6, 6) ^ __ROR4__(A[3] + v6, 11);
    A[3] = v7;
    v9 = &K[v5];
    v10 = A[6] + v9[1] + ((A[4] ^ A[5]) & v7 ^ A[5]) + (v8 ^ __ROR4__(v7, 25));
    v11 = &W[v5];
    v12 = v10 + v11[1];
    A[6] = v12 + (A[7] & A[0] | (A[7] | A[0]) & A[1]) + (__ROR4__(A[7], 2) ^ __ROR4__(A[7], 13) ^ __ROR4__(A[7], 22));
    A[2] += v12;
    v13 = ((A[3] ^ A[4]) & A[2] ^ A[4])
        + (__ROR4__(A[2], 6) ^ __ROR4__(A[2], 11) ^ __ROR4__(A[2], 25))
        + A[5]
        + v9[2]
        + v11[2];
    v14 = A[1] + v13;
    A[5] = v13 + (A[6] & A[7] | (A[6] | A[7]) & A[0]) + (__ROR4__(A[6], 2) ^ __ROR4__(A[6], 13) ^ __ROR4__(A[6], 22));
    v15 = __ROR4__(A[1] + v13, 6) ^ __ROR4__(A[1] + v13, 11);
    A[1] = v14;
    v16 = ((A[2] ^ A[3]) & v14 ^ A[3]) + (v15 ^ __ROR4__(v14, 25)) + A[4] + v9[3] + v11[3];
    v17 = A[0] + v16;
    A[4] = v16 + (A[5] & A[6] | (A[5] | A[6]) & A[7]) + (__ROR4__(A[5], 2) ^ __ROR4__(A[5], 13) ^ __ROR4__(A[5], 22));
    v18 = __ROR4__(A[0] + v16, 6) ^ __ROR4__(A[0] + v16, 11);
    A[0] = v17;
    v19 = ((A[1] ^ A[2]) & v17 ^ A[2]) + (v18 ^ __ROR4__(v17, 25)) + A[3] + v9[4] + v11[4];
    v20 = A[7] + v19;
    A[3] = v19 + (A[4] & A[5] | (A[4] | A[5]) & A[6]) + (__ROR4__(A[4], 2) ^ __ROR4__(A[4], 13) ^ __ROR4__(A[4], 22));
    v21 = __ROR4__(A[7] + v19, 6) ^ __ROR4__(A[7] + v19, 11);
    A[7] = v20;
    v22 = ((A[0] ^ A[1]) & v20 ^ A[1]) + (v21 ^ __ROR4__(v20, 25)) + A[2] + v9[5] + v11[5];
    v23 = A[6] + v22;
    A[2] = v22 + (A[3] & A[4] | (A[3] | A[4]) & A[5]) + (__ROR4__(A[3], 2) ^ __ROR4__(A[3], 13) ^ __ROR4__(A[3], 22));
    v24 = __ROR4__(A[6] + v22, 6) ^ __ROR4__(A[6] + v22, 11);
    A[6] = v23;
    v25 = ((A[7] ^ A[0]) & v23 ^ A[0]) + (v24 ^ __ROR4__(v23, 25)) + A[1] + v9[6] + v11[6];
    v5 += 8;
    v26 = A[5] + v25;
    A[1] = v25 + (A[2] & A[3] | (A[2] | A[3]) & A[4]) + (__ROR4__(A[2], 2) ^ __ROR4__(A[2], 13) ^ __ROR4__(A[2], 22));
    v27 = __ROR4__(A[5] + v25, 6) ^ __ROR4__(A[5] + v25, 11);
    A[5] = v26;
    v28 = v11[7] + v9[7] + A[0] + ((A[6] ^ A[7]) & v26 ^ A[7]) + (v27 ^ __ROR4__(v26, 25));
    A[4] += v28;
    A[0] = v28 + (__ROR4__(A[1], 2) ^ __ROR4__(A[1], 13) ^ __ROR4__(A[1], 22)) + (A[1] & A[2] | (A[1] | A[2]) & A[3]);
  }
  while ( v5 < 0x10 );
  v29 = 16;
  do
  {
    v30 = &K[v29];
    v31 = (__ROR4__(A[4], 6) ^ __ROR4__(A[4], 11) ^ __ROR4__(A[4], 25)) + ((A[5] ^ A[6]) & A[4] ^ A[6]) + A[7] + *v30;
    v32 = &W[v29];
    v33 = *(v32 - 15);
    v34 = (__ROR4__(*(v32 - 2), 17) ^ __ROR4__(*(v32 - 2), 19) ^ (*(v32 - 2) >> 10))
        + (__ROR4__(v33, 7) ^ __ROR4__(v33, 18) ^ (v33 >> 3));
    v35 = *(v32 - 2);
    v36 = *(v32 - 7);
    v37 = *(v32 - 16);
    v32 -= 16;
    v38 = v34 + v36 + v37;
    W[v29] = v38;
    v39 = v31 + v38;
    v40 = A[3] + v39;
    A[7] = v39 + (A[0] & A[1] | (A[0] | A[1]) & A[2]) + (__ROR4__(A[0], 2) ^ __ROR4__(A[0], 13) ^ __ROR4__(A[0], 22));
    v41 = __ROR4__(A[3] + v39, 6) ^ __ROR4__(A[3] + v39, 11);
    A[3] = v40;
    v42 = v32[15];
    v43 = ((A[4] ^ A[5]) & v40 ^ A[5]) + (v41 ^ __ROR4__(v40, 25)) + A[6] + v30[1];
    v44 = v32[2];
    v45 = v33
        + v32[10]
        + (__ROR4__(v42, 17) ^ __ROR4__(v42, 19) ^ (v42 >> 10))
        + (__ROR4__(v44, 7) ^ __ROR4__(v44, 18) ^ (v44 >> 3));
    v32[17] = v45;
    v46 = v43 + v45;
    v47 = A[2] + v46;
    A[6] = v46 + (A[7] & A[0] | (A[7] | A[0]) & A[1]) + (__ROR4__(A[7], 2) ^ __ROR4__(A[7], 13) ^ __ROR4__(A[7], 22));
    v48 = __ROR4__(A[2] + v46, 6) ^ __ROR4__(A[2] + v46, 11);
    A[2] = v47;
    v49 = (v48 ^ __ROR4__(v47, 25)) + ((A[3] ^ A[4]) & v47 ^ A[4]) + A[5] + v30[2];
    v50 = v32[3];
    v51 = v44
        + v32[11]
        + (__ROR4__(v38, 17) ^ __ROR4__(v38, 19) ^ (v38 >> 10))
        + (__ROR4__(v50, 7) ^ __ROR4__(v50, 18) ^ (v50 >> 3));
    v32[18] = v51;
    A[1] += v49 + v51;
    A[5] = v49
         + v51
         + (__ROR4__(A[6], 2) ^ __ROR4__(A[6], 13) ^ __ROR4__(A[6], 22))
         + (A[6] & A[7] | (A[6] | A[7]) & A[0]);
    v52 = ((A[2] ^ A[3]) & A[1] ^ A[3]) + (__ROR4__(A[1], 6) ^ __ROR4__(A[1], 11) ^ __ROR4__(A[1], 25)) + A[4] + v30[3];
    v53 = __ROR4__(v45, 17) ^ __ROR4__(v45, 19) ^ (v45 >> 10);
    v54 = v32[4];
    v55 = v50 + v32[12] + v53 + (__ROR4__(v54, 7) ^ __ROR4__(v54, 18) ^ (v54 >> 3));
    v32[19] = v55;
    A[0] += v52 + v55;
    A[4] = v52
         + v55
         + (__ROR4__(A[5], 2) ^ __ROR4__(A[5], 13) ^ __ROR4__(A[5], 22))
         + (A[5] & A[6] | (A[5] | A[6]) & A[7]);
    v56 = __ROR4__(v51, 17) ^ __ROR4__(v51, 19) ^ (v51 >> 10);
    v57 = v32[5];
    v58 = v54 + v32[13] + v56 + (__ROR4__(v57, 7) ^ __ROR4__(v57, 18) ^ (v57 >> 3));
    v59 = ((A[1] ^ A[2]) & A[0] ^ A[2])
        + (__ROR4__(A[0], 6) ^ __ROR4__(A[0], 11) ^ __ROR4__(A[0], 25))
        + A[3]
        + v30[4]
        + v58;
    v32[20] = v58;
    A[7] += v59;
    A[3] = v59 + (__ROR4__(A[4], 2) ^ __ROR4__(A[4], 13) ^ __ROR4__(A[4], 22)) + (A[4] & A[5] | (A[4] | A[5]) & A[6]);
    v60 = __ROR4__(v55, 17) ^ __ROR4__(v55, 19) ^ (v55 >> 10);
    v61 = v32[6];
    v62 = v57 + v35 + (__ROR4__(v61, 7) ^ __ROR4__(v61, 18) ^ (v61 >> 3)) + v60;
    v63 = ((A[0] ^ A[1]) & A[7] ^ A[1])
        + (__ROR4__(A[7], 6) ^ __ROR4__(A[7], 11) ^ __ROR4__(A[7], 25))
        + A[2]
        + v30[5]
        + v62;
    v32[21] = v62;
    A[6] += v63;
    A[2] = v63 + (__ROR4__(A[3], 2) ^ __ROR4__(A[3], 13) ^ __ROR4__(A[3], 22)) + (A[3] & A[4] | (A[3] | A[4]) & A[5]);
    v64 = ((A[7] ^ A[0]) & A[6] ^ A[0]) + (__ROR4__(A[6], 6) ^ __ROR4__(A[6], 11) ^ __ROR4__(A[6], 25)) + A[1] + v30[6];
    v65 = __ROR4__(v58, 17) ^ __ROR4__(v58, 19) ^ (v58 >> 10);
    v66 = v32[7];
    v67 = v61 + v42 + (__ROR4__(v66, 7) ^ __ROR4__(v66, 18) ^ (v66 >> 3)) + v65;
    v32[22] = v67;
    v68 = v67 + v64;
    v29 += 8;
    v69 = A[5] + v68;
    A[1] = v68 + (A[2] & A[3] | (A[2] | A[3]) & A[4]) + (__ROR4__(A[2], 2) ^ __ROR4__(A[2], 13) ^ __ROR4__(A[2], 22));
    v70 = __ROR4__(A[5] + v68, 6) ^ __ROR4__(A[5] + v68, 11);
    A[5] = v69;
    v71 = v30[7] + A[0] + ((A[6] ^ A[7]) & v69 ^ A[7]) + (v70 ^ __ROR4__(v69, 25));
    v72 = v38
        + v66
        + (__ROR4__(v32[8], 7) ^ __ROR4__(v32[8], 18) ^ (v32[8] >> 3))
        + (__ROR4__(v62, 17) ^ __ROR4__(v62, 19) ^ (v62 >> 10));
    v32[23] = v72;
    A[4] += v71 + v72;
    A[0] = v71
         + v72
         + (A[1] & A[2] | (A[1] | A[2]) & A[3])
         + (__ROR4__(A[1], 2) ^ __ROR4__(A[1], 13) ^ __ROR4__(A[1], 22));
  }
  while ( v29 < 0x40 );
  for ( k = 0; k < 8; ++k )
  {
    v74 = &ctx->total[k];
    v75 = A[k];
    v74[2] += v75;
  }
  return 0;
}

//----- (08005B70) --------------------------------------------------------
int __fastcall mbedtls_mpi_add_abs(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  const mbedtls_mpi_0 *v3; // r5
  int v5; // r1
  size_t i; // r6
  mbedtls_mpi_uint *v7; // r2
  unsigned int v8; // r7
  size_t v9; // r5
  mbedtls_mpi_uint *v10; // r0
  mbedtls_mpi_uint v11; // r12
  mbedtls_mpi_uint v12; // r3
  _BOOL4 v13; // r7
  mbedtls_mpi_uint v14; // r3
  mbedtls_mpi_uint v15; // r2

  v3 = B;
  if ( X == B )
  {
    v3 = A;
    A = X;
  }
  if ( X == A || (v5 = mbedtls_mpi_copy(X, A)) == 0 )
  {
    X->s = 1;
    for ( i = v3->n; i; --i )
    {
      if ( v3->p[i - 1] )
        break;
    }
    v5 = mbedtls_mpi_grow(X, i);
    if ( !v5 )
    {
      v7 = v3->p;
      v8 = 0;
      v9 = 0;
      v10 = X->p;
      while ( v9 < i )
      {
        v11 = *v7;
        v12 = *v10 + v8;
        *v10 = v12;
        v13 = v12 < v8;
        v14 = v12 + v11;
        *v10++ = v14;
        ++v7;
        v8 = v13 + (v14 < v11);
        ++v9;
      }
      while ( v8 )
      {
        if ( X->n <= v9 )
        {
          v5 = mbedtls_mpi_grow(X, v9 + 1);
          if ( v5 )
            return v5;
          v10 = &X->p[v9];
        }
        v15 = *v10 + v8;
        *v10 = v15;
        v8 = v15 < v8;
        ++v10;
        ++v9;
      }
    }
  }
  return v5;
}

//----- (08005C28) --------------------------------------------------------
int __fastcall mbedtls_mpi_add_int(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, mbedtls_mpi_sint b)
{
  bool v3; // nf
  int v4; // r2
  mbedtls_mpi_0 _B; // [sp+0h] [bp-18h] BYREF
  mbedtls_mpi_uint p[1]; // [sp+Ch] [bp-Ch] BYREF

  _B.s = (int)X;
  _B.n = (size_t)A;
  _B.p = (mbedtls_mpi_uint *)b;
  v3 = b < 0;
  if ( b < 0 )
    b = -b;
  p[0] = b;
  if ( v3 )
    v4 = -1;
  else
    v4 = 1;
  _B.s = v4;
  _B.n = 1;
  _B.p = p;
  return mbedtls_mpi_add_mpi(X, A, &_B);
}

//----- (08005C58) --------------------------------------------------------
int __fastcall mbedtls_mpi_add_mpi(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  int v4; // r4
  int result; // r0

  v4 = A->s;
  if ( B->s * A->s >= 0 )
  {
    result = mbedtls_mpi_add_abs(X, A, B);
LABEL_4:
    if ( !result )
      X->s = v4;
    return result;
  }
  if ( mbedtls_mpi_cmp_abs(A, B) >= 0 )
  {
    result = mbedtls_mpi_sub_abs(X, A, B);
    goto LABEL_4;
  }
  result = mbedtls_mpi_sub_abs(X, B, A);
  if ( !result )
    X->s = -v4;
  return result;
}

//----- (08005CA6) --------------------------------------------------------
size_t __fastcall mbedtls_mpi_bitlen(const mbedtls_mpi_0 *X)
{
  size_t v1; // r1
  size_t i; // r1
  unsigned int v4; // r2
  mbedtls_mpi_uint v5; // r3
  unsigned int j; // r0

  v1 = X->n;
  if ( !v1 )
    return 0;
  for ( i = v1 - 1; i; --i )
  {
    if ( X->p[i] )
      break;
  }
  v4 = 0x80000000;
  v5 = X->p[i];
  for ( j = 0; j < 0x20; ++j )
  {
    if ( (v5 & v4) != 0 )
      break;
    v4 >>= 1;
  }
  return 32 - j + 32 * i;
}

//----- (08005CE4) --------------------------------------------------------
int __fastcall mbedtls_mpi_cmp_abs(const mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y)
{
  __int64 v2; // r2
  mbedtls_mpi_uint *v3; // r1
  int v4; // r0
  unsigned int v5; // r6
  unsigned int v6; // r0

  for ( LODWORD(v2) = X->n; (_DWORD)v2; LODWORD(v2) = v2 - 1 )
  {
    if ( X->p[v2 - 1] )
      break;
  }
  for ( HIDWORD(v2) = Y->n; HIDWORD(v2); --HIDWORD(v2) )
  {
    if ( Y->p[HIDWORD(v2) - 1] )
      break;
  }
  if ( v2 )
  {
    if ( (unsigned int)v2 > HIDWORD(v2) )
      return 1;
    if ( HIDWORD(v2) > (unsigned int)v2 )
      return -1;
    if ( (_DWORD)v2 )
    {
      HIDWORD(v2) = X->p;
      v3 = Y->p;
      while ( 1 )
      {
        v4 = 4 * v2 - 4;
        v5 = *(_DWORD *)(HIDWORD(v2) + v4);
        v6 = *(mbedtls_mpi_uint *)((char *)v3 + v4);
        if ( v5 > v6 )
          break;
        if ( v5 < v6 )
          return -1;
        LODWORD(v2) = v2 - 1;
        if ( !(_DWORD)v2 )
          return 0;
      }
      return 1;
    }
  }
  return 0;
}

//----- (08005D48) --------------------------------------------------------
int __fastcall mbedtls_mpi_cmp_int(const mbedtls_mpi_0 *X, mbedtls_mpi_sint z)
{
  bool v2; // nf
  int v3; // r1
  mbedtls_mpi_0 Y; // [sp+0h] [bp-14h] BYREF
  mbedtls_mpi_uint p[1]; // [sp+Ch] [bp-8h] BYREF

  Y.s = (int)X;
  Y.n = z;
  v2 = z < 0;
  if ( z < 0 )
    z = -z;
  p[0] = z;
  if ( v2 )
    v3 = -1;
  else
    v3 = 1;
  Y.s = v3;
  Y.n = 1;
  Y.p = p;
  return mbedtls_mpi_cmp_mpi(X, &Y);
}

//----- (08005D78) --------------------------------------------------------
int __fastcall mbedtls_mpi_cmp_mpi(const mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y)
{
  __int64 v2; // r2
  int v4; // r3
  mbedtls_mpi_uint *v5; // r5
  mbedtls_mpi_uint *v6; // r0
  int v7; // r1
  unsigned int v8; // r6
  unsigned int v9; // r1

  for ( LODWORD(v2) = X->n; (_DWORD)v2; LODWORD(v2) = v2 - 1 )
  {
    if ( X->p[v2 - 1] )
      break;
  }
  for ( HIDWORD(v2) = Y->n; HIDWORD(v2); --HIDWORD(v2) )
  {
    if ( Y->p[HIDWORD(v2) - 1] )
      break;
  }
  if ( !v2 )
    return 0;
  if ( (unsigned int)v2 > HIDWORD(v2) )
    return X->s;
  if ( HIDWORD(v2) > (unsigned int)v2 )
    return -Y->s;
  v4 = X->s;
  if ( X->s > 0 && Y->s < 0 )
    return 1;
  if ( Y->s > 0 && v4 < 0 )
    return -1;
  if ( !(_DWORD)v2 )
    return 0;
  v5 = X->p;
  v6 = Y->p;
  while ( 1 )
  {
    v7 = 4 * v2 - 4;
    v8 = *(mbedtls_mpi_uint *)((char *)v5 + v7);
    v9 = *(mbedtls_mpi_uint *)((char *)v6 + v7);
    if ( v8 > v9 )
      return v4;
    if ( v8 < v9 )
      break;
    LODWORD(v2) = v2 - 1;
    if ( !(_DWORD)v2 )
      return 0;
  }
  return -v4;
}

//----- (08005E04) --------------------------------------------------------
int __fastcall mbedtls_mpi_copy(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y)
{
  int v3; // r7
  mbedtls_mpi_uint *v6; // r0
  size_t v7; // r4
  size_t v8; // r1
  size_t v9; // r4

  v3 = 0;
  if ( X == Y )
    return 0;
  v6 = Y->p;
  if ( !v6 )
  {
    mbedtls_mpi_free(X);
    return 0;
  }
  v7 = Y->n;
  do
    --v7;
  while ( v7 && !v6[v7] );
  X->s = Y->s;
  v8 = X->n;
  v9 = v7 + 1;
  if ( v8 >= v9 )
  {
    _rt_memclr_w(&X->p[v9], 4 * (v8 - v9));
LABEL_12:
    _rt_memcpy_w((int *)X->p, (int *)Y->p, 4 * v9);
    return v3;
  }
  v3 = mbedtls_mpi_grow(X, v9);
  if ( !v3 )
    goto LABEL_12;
  return v3;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08005E68) --------------------------------------------------------
int __fastcall mbedtls_mpi_div_mpi(mbedtls_mpi_0 *Q, mbedtls_mpi_0 *R, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  bool v7; // zf
  int v8; // r4
  size_t v10; // r0
  size_t v11; // r5
  size_t v12; // r6
  size_t v13; // r7
  size_t v14; // r8
  int i; // r0
  unsigned __int64 v16; // r0
  mbedtls_mpi_uint v17; // r2
  int v18; // r0
  int v19; // r1
  int v20; // r7
  mbedtls_mpi_uint v21; // r0
  int v22; // r0
  mbedtls_mpi_uint v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // [sp+0h] [bp-90h]
  mbedtls_mpi_0 X; // [sp+10h] [bp-80h] BYREF
  mbedtls_mpi_0 Y; // [sp+1Ch] [bp-74h] BYREF
  mbedtls_mpi_0 Z; // [sp+28h] [bp-68h] BYREF
  mbedtls_mpi_0 T1; // [sp+34h] [bp-5Ch] BYREF
  mbedtls_mpi_0 T2; // [sp+40h] [bp-50h] BYREF
  size_t v32; // [sp+50h] [bp-40h]
  size_t count; // [sp+54h] [bp-3Ch]
  mbedtls_mpi_0 *v34; // [sp+5Ch] [bp-34h]
  mbedtls_mpi_0 *v35; // [sp+60h] [bp-30h]
  const mbedtls_mpi_0 *v36; // [sp+64h] [bp-2Ch]
  const mbedtls_mpi_0 *Ba; // [sp+68h] [bp-28h]

  v34 = Q;
  v35 = R;
  v36 = A;
  Ba = B;
  if ( !mbedtls_mpi_cmp_int(B, 0) )
    return -12;
  mbedtls_mpi_init(&X);
  mbedtls_mpi_init(&Y);
  mbedtls_mpi_init(&Z);
  mbedtls_mpi_init(&T1);
  mbedtls_mpi_init(&T2);
  if ( mbedtls_mpi_cmp_abs(A, Ba) < 0 )
  {
    if ( !Q )
      goto LABEL_9;
    v8 = mbedtls_mpi_lset(Q, 0);
    v7 = v8 == 0;
    goto LABEL_5;
  }
  v8 = mbedtls_mpi_copy(&X, A);
  v7 = v8 == 0;
  if ( v8 )
    goto LABEL_5;
  v8 = mbedtls_mpi_copy(&Y, Ba);
  v7 = v8 == 0;
  if ( v8 )
    goto LABEL_5;
  Y.s = 1;
  X.s = 1;
  v8 = mbedtls_mpi_grow(&Z, A->n + 2);
  v7 = v8 == 0;
  if ( v8 )
    goto LABEL_5;
  v8 = mbedtls_mpi_lset(&Z, 0);
  v7 = v8 == 0;
  if ( v8 )
    goto LABEL_5;
  v8 = mbedtls_mpi_grow(&T1, 2u);
  v7 = v8 == 0;
  if ( v8 )
    goto LABEL_5;
  v8 = mbedtls_mpi_grow(&T2, 3u);
  v7 = v8 == 0;
  if ( v8 )
    goto LABEL_5;
  v10 = mbedtls_mpi_bitlen(&Y) & 0x1F;
  if ( v10 >= 0x1F )
  {
    count = 0;
  }
  else
  {
    count = 31 - v10;
    v8 = mbedtls_mpi_shift_l(&X, 31 - v10);
    v7 = v8 == 0;
    if ( v8 )
      goto LABEL_5;
    v8 = mbedtls_mpi_shift_l(&Y, count);
    v7 = v8 == 0;
    if ( v8 )
      goto LABEL_5;
  }
  v11 = X.n - 1;
  v12 = Y.n - 1;
  v13 = X.n - Y.n;
  v14 = 32 * (X.n - Y.n);
  for ( i = mbedtls_mpi_shift_l(&Y, v14); ; i = mbedtls_mpi_sub_mpi(&X, &X, &Y) )
  {
    v8 = i;
    v7 = i == 0;
    if ( i )
      goto LABEL_5;
    if ( mbedtls_mpi_cmp_mpi(&X, &Y) < 0 )
      break;
    ++Z.p[v13];
  }
  v8 = mbedtls_mpi_shift_r(&Y, v14);
  v7 = v8 == 0;
  if ( v8 )
  {
LABEL_5:
    while ( v7 )
    {
LABEL_9:
      if ( R )
      {
        v8 = mbedtls_mpi_copy(R, A);
        v7 = v8 == 0;
        if ( v8 )
          continue;
      }
      return 0;
    }
    goto LABEL_71;
  }
  while ( 2 )
  {
    if ( v11 > v12 )
    {
      HIDWORD(v16) = X.p[v11];
      v17 = Y.p[v12];
      if ( HIDWORD(v16) < v17 )
      {
        if ( !v17 || HIDWORD(v16) >= v17 || (LODWORD(v16) = X.p[v11 - 1], v18 = ll_udiv(v16, v17), v19) )
          v18 = -1;
        Z.p[v11 - v12 - 1] = v18;
      }
      else
      {
        Z.p[v11 - v12 - 1] = -1;
      }
      v20 = 4 * (v11 - v12) - 4;
      v32 = v11 - v12;
      ++*(mbedtls_mpi_uint *)((char *)Z.p + v20);
      do
      {
        --*(mbedtls_mpi_uint *)((char *)Z.p + v20);
        v8 = mbedtls_mpi_lset(&T1, 0);
        if ( v8 )
          goto LABEL_71;
        v21 = v12 ? Y.p[v12 - 1] : 0;
        *T1.p = v21;
        T1.p[1] = Y.p[v12];
        v8 = mbedtls_mpi_mul_int(&T1, &T1, *(mbedtls_mpi_uint *)((char *)Z.p + v20));
        if ( v8 )
          goto LABEL_71;
        v22 = mbedtls_mpi_lset(&T2, 0);
        v8 = v22;
        if ( v22 )
          goto LABEL_71;
        if ( v11 >= 2 )
          v22 = X.p[v11 - 2];
        *T2.p = v22;
        if ( v11 )
          v23 = X.p[v11 - 1];
        else
          v23 = 0;
        T2.p[1] = v23;
        T2.p[2] = X.p[v11];
      }
      while ( mbedtls_mpi_cmp_mpi(&T1, &T2) > 0 );
      v8 = mbedtls_mpi_mul_int(&T1, &Y, *(mbedtls_mpi_uint *)((char *)Z.p + v20));
      if ( v8 )
        goto LABEL_71;
      v26 = 32 * v32 - 32;
      v24 = mbedtls_mpi_shift_l(&T1, v26);
      v8 = v24;
      if ( v24 )
        goto LABEL_71;
      v8 = mbedtls_mpi_sub_mpi(&X, &X, &T1);
      if ( v8 )
        goto LABEL_71;
      if ( mbedtls_mpi_cmp_int(&X, 0) < 0 )
      {
        v8 = mbedtls_mpi_copy(&T1, &Y);
        if ( v8 )
          goto LABEL_71;
        v8 = mbedtls_mpi_shift_l(&T1, v26);
        if ( v8 )
          goto LABEL_71;
        v8 = mbedtls_mpi_add_mpi(&X, &X, &T1);
        if ( v8 )
          goto LABEL_71;
        --*(mbedtls_mpi_uint *)((char *)Z.p + v20);
      }
      --v11;
      continue;
    }
    break;
  }
  if ( !Q )
  {
LABEL_66:
    if ( R )
    {
      v8 = mbedtls_mpi_shift_r(&X, count);
      if ( !v8 )
      {
        X.s = A->s;
        v8 = mbedtls_mpi_copy(R, &X);
        if ( !v8 && !mbedtls_mpi_cmp_int(R, 0) )
          R->s = 1;
      }
    }
    goto LABEL_71;
  }
  v25 = mbedtls_mpi_copy(Q, &Z);
  v8 = v25;
  if ( !v25 )
  {
    Q->s = A->s * Ba->s;
    goto LABEL_66;
  }
LABEL_71:
  mbedtls_mpi_free(&X);
  mbedtls_mpi_free(&Y);
  mbedtls_mpi_free(&Z);
  mbedtls_mpi_free(&T1);
  mbedtls_mpi_free(&T2);
  return v8;
}
// 8005FEA: variable 'v19' is possibly undefined

//----- (08006186) --------------------------------------------------------
int __fastcall mbedtls_mpi_fill_random(mbedtls_mpi_0 *X, size_t size, int (*f_rng)(void *, unsigned __int8 *, size_t), void *p_rng)
{
  size_t v8; // r0
  size_t v9; // r5
  int v10; // r7

  v8 = size << 30;
  if ( size << 30 )
    v8 = 1;
  v9 = v8 + (size >> 2);
  if ( X->n == v9 || (mbedtls_mpi_free(X), mbedtls_mpi_init(X), (v10 = mbedtls_mpi_grow(X, v9)) == 0) )
  {
    v10 = mbedtls_mpi_lset(X, 0);
    if ( !v10 )
    {
      f_rng(p_rng, (unsigned __int8 *)X->p + 4 * v9 - size, size);
      mpi_bigendian_to_host(X->p, v9);
    }
  }
  return v10;
}

//----- (080061E6) --------------------------------------------------------
void __fastcall mbedtls_mpi_free(mbedtls_mpi_0 *X)
{
  mbedtls_mpi_uint *v2; // r0

  if ( X )
  {
    v2 = X->p;
    if ( v2 )
    {
      mbedtls_mpi_zeroize(v2, X->n);
      free((int)X->p);
    }
    X->s = 1;
    X->n = 0;
    X->p = 0;
  }
}

//----- (08006208) --------------------------------------------------------
int __fastcall mbedtls_mpi_gcd(mbedtls_mpi_0 *G, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  const mbedtls_mpi_0 *v5; // r2
  int v6; // r4
  size_t v7; // r5
  size_t v8; // r0
  size_t v9; // r0
  size_t v10; // r0
  mbedtls_mpi_0 *v11; // r0
  mbedtls_mpi_0 TB; // [sp+0h] [bp-38h] BYREF
  mbedtls_mpi_0 TA; // [sp+Ch] [bp-2Ch] BYREF
  mbedtls_mpi_0 TG; // [sp+18h] [bp-20h] BYREF

  mbedtls_mpi_init(&TG);
  mbedtls_mpi_init(&TA);
  mbedtls_mpi_init(&TB);
  v6 = mbedtls_mpi_copy(&TA, v5);
  if ( !v6 )
  {
    v6 = mbedtls_mpi_copy(&TB, B);
    if ( !v6 )
    {
      v7 = mbedtls_mpi_lsb(&TA);
      v8 = mbedtls_mpi_lsb(&TB);
      if ( v8 < v7 )
        v7 = v8;
      v6 = mbedtls_mpi_shift_r(&TA, v7);
      if ( !v6 )
      {
        v6 = mbedtls_mpi_shift_r(&TB, v7);
        if ( !v6 )
        {
          TB.s = 1;
          TA.s = 1;
          while ( mbedtls_mpi_cmp_int(&TA, 0) )
          {
            v9 = mbedtls_mpi_lsb(&TA);
            v6 = mbedtls_mpi_shift_r(&TA, v9);
            if ( !v6 )
            {
              v10 = mbedtls_mpi_lsb(&TB);
              v6 = mbedtls_mpi_shift_r(&TB, v10);
              if ( !v6 )
              {
                if ( mbedtls_mpi_cmp_mpi(&TA, &TB) < 0 )
                {
                  v6 = mbedtls_mpi_sub_abs(&TB, &TB, &TA);
                  if ( v6 )
                    goto LABEL_19;
                  v11 = &TB;
                }
                else
                {
                  v6 = mbedtls_mpi_sub_abs(&TA, &TA, &TB);
                  if ( v6 )
                    goto LABEL_19;
                  v11 = &TA;
                }
                v6 = mbedtls_mpi_shift_r(v11, 1u);
                if ( !v6 )
                  continue;
              }
            }
            goto LABEL_19;
          }
          v6 = mbedtls_mpi_shift_l(&TB, v7);
          if ( !v6 )
            v6 = mbedtls_mpi_copy(G, &TB);
        }
      }
    }
  }
LABEL_19:
  mbedtls_mpi_free(&TG);
  mbedtls_mpi_free(&TA);
  mbedtls_mpi_free(&TB);
  return v6;
}
// 8006228: variable 'v5' is possibly undefined

//----- (08006308) --------------------------------------------------------
int __fastcall mbedtls_mpi_get_bit(const mbedtls_mpi_0 *X, size_t pos)
{
  int result; // r0

  if ( pos < 32 * X->n )
    result = (X->p[pos >> 5] >> (pos & 0x1F)) & 1;
  else
    result = 0;
  return result;
}

//----- (08006328) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall mbedtls_mpi_grow(mbedtls_mpi_0 *X, size_t nblimbs)
{
  int *v4; // r6 OVERLAPPED
  int *v5; // r1

  if ( nblimbs <= 0x2710 )
  {
    if ( X->n >= nblimbs )
      return 0;
    v4 = (int *)calloc(nblimbs, 4u);
    if ( v4 )
    {
      v5 = (int *)X->p;
      if ( v5 )
      {
        _rt_memcpy_w(v4, v5, 4 * X->n);
        mbedtls_mpi_zeroize(X->p, X->n);
        free((int)X->p);
      }
      *(_QWORD *)&X->n = *(_QWORD *)&nblimbs;
      return 0;
    }
  }
  return -16;
}
// 8006328: variables would overlap: r5.4 and r5.8
// 8006328: variables would overlap: r6.4 and r5.8

//----- (08006378) --------------------------------------------------------
void __fastcall mbedtls_mpi_init(mbedtls_mpi_0 *X)
{
  X->s = 1;
  X->n = 0;
  X->p = 0;
}

//----- (08006384) --------------------------------------------------------
int __fastcall mbedtls_mpi_inv_mod(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *N)
{
  int v7; // r4
  int v8; // r0
  mbedtls_mpi_0 *v9; // r2
  mbedtls_mpi_0 *v10; // r1
  int v11; // r0
  mbedtls_mpi_0 V1; // [sp+0h] [bp-80h] BYREF
  mbedtls_mpi_0 TU; // [sp+Ch] [bp-74h] BYREF
  mbedtls_mpi_0 U1; // [sp+18h] [bp-68h] BYREF
  mbedtls_mpi_0 U2; // [sp+24h] [bp-5Ch] BYREF
  mbedtls_mpi_0 V2; // [sp+30h] [bp-50h] BYREF
  mbedtls_mpi_0 TV; // [sp+3Ch] [bp-44h] BYREF
  mbedtls_mpi_0 TA; // [sp+48h] [bp-38h] BYREF
  mbedtls_mpi_0 TB; // [sp+54h] [bp-2Ch] BYREF
  mbedtls_mpi_0 G; // [sp+60h] [bp-20h] BYREF

  if ( mbedtls_mpi_cmp_int(N, 1) <= 0 )
    return -4;
  mbedtls_mpi_init(&TA);
  mbedtls_mpi_init(&TU);
  mbedtls_mpi_init(&U1);
  mbedtls_mpi_init(&U2);
  mbedtls_mpi_init(&G);
  mbedtls_mpi_init(&TB);
  mbedtls_mpi_init(&TV);
  mbedtls_mpi_init(&V1);
  mbedtls_mpi_init(&V2);
  v7 = mbedtls_mpi_gcd(&G, A, N);
  if ( !v7 )
  {
    if ( mbedtls_mpi_cmp_int(&G, 1) )
    {
      v7 = -14;
    }
    else
    {
      v7 = mbedtls_mpi_mod_mpi(&TA, A, N);
      if ( !v7 )
      {
        v7 = mbedtls_mpi_copy(&TU, &TA);
        if ( !v7 )
        {
          v7 = mbedtls_mpi_copy(&TB, N);
          if ( !v7 )
          {
            v7 = mbedtls_mpi_copy(&TV, N);
            if ( !v7 )
            {
              v7 = mbedtls_mpi_lset(&U1, 1);
              if ( !v7 )
              {
                v7 = mbedtls_mpi_lset(&U2, 0);
                if ( !v7 )
                {
                  v7 = mbedtls_mpi_lset(&V1, 0);
                  if ( !v7 )
                  {
                    v8 = mbedtls_mpi_lset(&V2, 1);
                    while ( 2 )
                    {
                      v7 = v8;
                      if ( !v8 )
                      {
                        while ( *(unsigned __int8 *)TU.p << 31 )
                        {
                          while ( !(*(unsigned __int8 *)TV.p << 31) )
                          {
                            v7 = mbedtls_mpi_shift_r(&TV, 1u);
                            if ( !v7
                              && (!(*(unsigned __int8 *)V1.p << 31) && !(*(unsigned __int8 *)V2.p << 31)
                               || (v7 = mbedtls_mpi_add_mpi(&V1, &V1, &TB)) == 0
                               && (v7 = mbedtls_mpi_sub_mpi(&V2, &V2, &TA)) == 0) )
                            {
                              v7 = mbedtls_mpi_shift_r(&V1, 1u);
                              if ( !v7 )
                              {
                                v7 = mbedtls_mpi_shift_r(&V2, 1u);
                                if ( !v7 )
                                  continue;
                              }
                            }
                            goto LABEL_51;
                          }
                          if ( mbedtls_mpi_cmp_mpi(&TU, &TV) < 0 )
                          {
                            v7 = mbedtls_mpi_sub_mpi(&TV, &TV, &TU);
                            if ( v7 )
                              goto LABEL_51;
                            v7 = mbedtls_mpi_sub_mpi(&V1, &V1, &U1);
                            if ( v7 )
                              goto LABEL_51;
                            v9 = &U2;
                            v10 = &V2;
                          }
                          else
                          {
                            v7 = mbedtls_mpi_sub_mpi(&TU, &TU, &TV);
                            if ( v7 )
                              goto LABEL_51;
                            v7 = mbedtls_mpi_sub_mpi(&U1, &U1, &V1);
                            if ( v7 )
                              goto LABEL_51;
                            v9 = &V2;
                            v10 = &U2;
                          }
                          v11 = mbedtls_mpi_sub_mpi(v10, v10, v9);
                          v7 = v11;
                          if ( v11 )
                            goto LABEL_51;
                          if ( !mbedtls_mpi_cmp_int(&TU, 0) )
                          {
                            while ( mbedtls_mpi_cmp_int(&V1, 0) < 0 )
                            {
                              v7 = mbedtls_mpi_add_mpi(&V1, &V1, N);
                              if ( v7 )
                                goto LABEL_51;
                            }
                            while ( mbedtls_mpi_cmp_mpi(&V1, N) >= 0 )
                            {
                              v7 = mbedtls_mpi_sub_mpi(&V1, &V1, N);
                              if ( v7 )
                                goto LABEL_51;
                            }
                            v7 = mbedtls_mpi_copy(X, &V1);
                            goto LABEL_51;
                          }
                        }
                        v7 = mbedtls_mpi_shift_r(&TU, 1u);
                        if ( !v7
                          && (!(*(unsigned __int8 *)U1.p << 31) && !(*(unsigned __int8 *)U2.p << 31)
                           || (v7 = mbedtls_mpi_add_mpi(&U1, &U1, &TB)) == 0
                           && (v7 = mbedtls_mpi_sub_mpi(&U2, &U2, &TA)) == 0) )
                        {
                          v7 = mbedtls_mpi_shift_r(&U1, 1u);
                          if ( !v7 )
                          {
                            v8 = mbedtls_mpi_shift_r(&U2, 1u);
                            continue;
                          }
                        }
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_51:
  mbedtls_mpi_free(&TA);
  mbedtls_mpi_free(&TU);
  mbedtls_mpi_free(&U1);
  mbedtls_mpi_free(&U2);
  mbedtls_mpi_free(&G);
  mbedtls_mpi_free(&TB);
  mbedtls_mpi_free(&TV);
  mbedtls_mpi_free(&V1);
  mbedtls_mpi_free(&V2);
  return v7;
}

//----- (080065EC) --------------------------------------------------------
size_t __fastcall mbedtls_mpi_lsb(const mbedtls_mpi_0 *X)
{
  size_t result; // r0
  size_t v3; // r2
  int v4; // r1

  result = 0;
  v3 = 0;
LABEL_6:
  if ( X->n <= v3 )
    return 0;
  v4 = 0;
  while ( !(X->p[v3] >> v4 << 31) )
  {
    ++result;
    if ( (unsigned int)++v4 >= 0x20 )
    {
      ++v3;
      goto LABEL_6;
    }
  }
  return result;
}

//----- (0800661C) --------------------------------------------------------
int __fastcall mbedtls_mpi_lset(mbedtls_mpi_0 *X, mbedtls_mpi_sint z)
{
  int v4; // r6
  bool v5; // nf
  int v6; // r0

  v4 = mbedtls_mpi_grow(X, 1u);
  if ( !v4 )
  {
    _rt_memclr_w(X->p, 4 * X->n);
    v5 = z < 0;
    if ( z < 0 )
      z = -z;
    *X->p = z;
    if ( v5 )
      v6 = -1;
    else
      v6 = 1;
    X->s = v6;
  }
  return v4;
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08006656) --------------------------------------------------------
int __fastcall mbedtls_mpi_mod_mpi(mbedtls_mpi_0 *R, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  int i; // r0
  int v8; // r4

  if ( mbedtls_mpi_cmp_int(B, 0) < 0 )
    return -10;
  for ( i = mbedtls_mpi_div_mpi(0, R, A, B); ; i = mbedtls_mpi_add_mpi(R, R, B) )
  {
    v8 = i;
    if ( i )
      break;
    if ( mbedtls_mpi_cmp_int(R, 0) >= 0 )
    {
      do
      {
        if ( mbedtls_mpi_cmp_mpi(R, B) < 0 )
          break;
        v8 = mbedtls_mpi_sub_mpi(R, R, B);
      }
      while ( !v8 );
      return v8;
    }
  }
  return v8;
}

//----- (080066B8) --------------------------------------------------------
int __fastcall mbedtls_mpi_mul_int(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, mbedtls_mpi_uint b)
{
  mbedtls_mpi_0 _B; // [sp+0h] [bp-18h] BYREF
  mbedtls_mpi_uint p[1]; // [sp+Ch] [bp-Ch] BYREF

  _B.s = 1;
  _B.n = 1;
  _B.p = p;
  p[0] = b;
  return mbedtls_mpi_mul_mpi(X, A, &_B);
}

//----- (080066D0) --------------------------------------------------------
int __fastcall mbedtls_mpi_mul_mpi(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  int v6; // r9
  size_t i; // r5
  size_t j; // r4
  mbedtls_mpi_0 TA; // [sp+0h] [bp-38h] BYREF
  mbedtls_mpi_0 TB; // [sp+Ch] [bp-2Ch] BYREF

  mbedtls_mpi_init(&TA);
  mbedtls_mpi_init(&TB);
  if ( X == A )
  {
    v6 = mbedtls_mpi_copy(&TA, A);
    if ( v6 )
      goto LABEL_18;
    A = &TA;
  }
  if ( X == B )
  {
    v6 = mbedtls_mpi_copy(&TB, B);
    if ( v6 )
      goto LABEL_18;
    B = &TB;
  }
  for ( i = A->n; i; --i )
  {
    if ( A->p[i - 1] )
      break;
  }
  for ( j = B->n; j; --j )
  {
    if ( B->p[j - 1] )
      break;
  }
  v6 = mbedtls_mpi_grow(X, i + j);
  if ( !v6 )
  {
    v6 = mbedtls_mpi_lset(X, 0);
    if ( !v6 )
    {
      while ( j )
      {
        mpi_mul_hlp(i, A->p, &X->p[j - 1], B->p[j - 1]);
        --j;
      }
      X->s = A->s * B->s;
    }
  }
LABEL_18:
  mbedtls_mpi_free(&TB);
  mbedtls_mpi_free(&TA);
  return v6;
}

//----- (08006792) --------------------------------------------------------
int __fastcall mbedtls_mpi_read_binary(mbedtls_mpi_0 *X, const unsigned __int8 *buf, size_t buflen)
{
  size_t v6; // r0
  size_t v7; // r4
  int v8; // r7
  int v9; // r3

  v6 = buflen << 30;
  if ( buflen << 30 )
    v6 = 1;
  v7 = v6 + (buflen >> 2);
  if ( X->n == v7 || (mbedtls_mpi_free(X), mbedtls_mpi_init(X), (v8 = mbedtls_mpi_grow(X, v7)) == 0) )
  {
    v8 = mbedtls_mpi_lset(X, 0);
    if ( !v8 && buf )
    {
      _rt_memcpy((_BYTE *)X->p + 4 * v7 - buflen, (char *)buf, buflen, v9);
      mpi_bigendian_to_host(X->p, v7);
    }
  }
  return v8;
}
// 80067E2: variable 'v9' is possibly undefined

//----- (080067F4) --------------------------------------------------------
int __fastcall mbedtls_mpi_read_binary_le(mbedtls_mpi_0 *X, const unsigned __int8 *buf, size_t buflen)
{
  size_t v6; // r0
  size_t v7; // r7
  int result; // r0
  size_t i; // r3

  v6 = buflen << 30;
  if ( buflen << 30 )
    v6 = 1;
  v7 = v6 + (buflen >> 2);
  if ( X->n == v7 || (mbedtls_mpi_free(X), mbedtls_mpi_init(X), (result = mbedtls_mpi_grow(X, v7)) == 0) )
  {
    result = mbedtls_mpi_lset(X, 0);
    if ( !result )
    {
      for ( i = 0; i < buflen; ++i )
        *(mbedtls_mpi_uint *)((char *)X->p + (i & 0xFFFFFFFC)) |= buf[i] << ((8 * i) & 0x1F);
    }
  }
  return result;
}

//----- (08006860) --------------------------------------------------------
int __fastcall mbedtls_mpi_read_string(mbedtls_mpi_0 *X, int radix, const unsigned __int8 *s)
{
  int v6; // r4
  unsigned int v7; // r0
  unsigned int v8; // r5
  int v10; // r0
  unsigned int v11; // r7
  int v12; // r7
  int v13; // r0
  int v14; // r0
  mbedtls_mpi_0 T; // [sp+0h] [bp-30h] BYREF
  mbedtls_mpi_uint d[9]; // [sp+Ch] [bp-24h] BYREF

  T.s = (int)X;
  T.n = radix;
  T.p = (mbedtls_mpi_uint *)s;
  v6 = -4;
  if ( (unsigned int)(radix - 2) < 0xF )
  {
    mbedtls_mpi_init(&T);
    v7 = (unsigned int)strlen((char *)s);
    v8 = v7;
    if ( radix != 16 )
    {
      v6 = mbedtls_mpi_lset(X, 0);
      if ( v6 || (v12 = 0, !v8) )
      {
LABEL_33:
        mbedtls_mpi_free(&T);
        return v6;
      }
      while ( *s != 45 )
      {
        do
        {
          v6 = mpi_get_digit(d, radix, s[v12]);
          if ( v6 )
            goto LABEL_33;
          v13 = mbedtls_mpi_mul_int(&T, X, radix);
          v6 = v13;
          if ( v13 )
            goto LABEL_33;
          v14 = X->s == 1 ? mbedtls_mpi_add_int(X, &T, d[0]) : mbedtls_mpi_sub_int(X, &T, d[0]);
          v6 = v14;
          if ( v14 )
            goto LABEL_33;
LABEL_32:
          if ( ++v12 >= v8 )
            goto LABEL_33;
        }
        while ( v12 );
      }
      X->s = -1;
      goto LABEL_32;
    }
    if ( v7 < 0x40000000 )
    {
      v10 = v7 << 29;
      if ( v8 << 29 )
        v10 = 1;
      v6 = mbedtls_mpi_grow(X, ((v8 >> 3) & 0x7FFFFFF) + v10);
      if ( !v6 )
      {
        v6 = mbedtls_mpi_lset(X, 0);
        if ( !v6 )
        {
          v11 = 0;
          while ( v8 )
          {
            if ( v8 == 1 && *s == 45 )
            {
              X->s = -1;
              goto LABEL_33;
            }
            v6 = mpi_get_digit(d, 16, s[v8 - 1]);
            if ( v6 )
              goto LABEL_33;
            --v8;
            X->p[(unsigned __int64)v11 >> 3] |= d[0] << ((4 * v11) & 0x1F);
            ++v11;
          }
        }
      }
      goto LABEL_33;
    }
  }
  return v6;
}

//----- (08006978) --------------------------------------------------------
int __fastcall mbedtls_mpi_safe_cond_assign(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *Y, unsigned int assign)
{
  unsigned int v5; // r6
  int v6; // r1
  unsigned int v7; // r0
  size_t i; // r2

  v5 = ((unsigned __int8)-(char)assign | assign) >> 7;
  v6 = mbedtls_mpi_grow(X, Y->n);
  if ( !v6 )
  {
    v7 = 1 - v5;
    X->s = X->s * (1 - v5) + Y->s * v5;
    for ( i = 0; Y->n > i; ++i )
      X->p[i] = X->p[i] * v7 + Y->p[i] * v5;
    while ( X->n > i )
      X->p[i++] *= v7;
  }
  return v6;
}

//----- (080069E4) --------------------------------------------------------
int __fastcall mbedtls_mpi_safe_cond_swap(mbedtls_mpi_0 *X, mbedtls_mpi_0 *Y, unsigned int swap)
{
  unsigned int v6; // r6
  int v7; // r3
  int v8; // r0
  unsigned int v9; // r1
  size_t i; // r0
  mbedtls_mpi_uint *v11; // r7
  mbedtls_mpi_uint v12; // r2

  if ( X == Y )
    return 0;
  v6 = ((unsigned __int8)-(char)swap | swap) >> 7;
  v7 = mbedtls_mpi_grow(X, Y->n);
  if ( !v7 )
  {
    v7 = mbedtls_mpi_grow(Y, X->n);
    if ( !v7 )
    {
      v8 = X->s;
      v9 = 1 - v6;
      X->s = X->s * (1 - v6) + Y->s * v6;
      Y->s = Y->s * (1 - v6) + v8 * v6;
      for ( i = 0; X->n > i; ++i )
      {
        v11 = X->p;
        v12 = v11[i];
        v11[i] = v12 * v9 + Y->p[i] * v6;
        Y->p[i] = Y->p[i] * v9 + v12 * v6;
      }
    }
  }
  return v7;
}

//----- (08006A6E) --------------------------------------------------------
int __fastcall mbedtls_mpi_set_bit(mbedtls_mpi_0 *X, size_t pos, unsigned __int8 val)
{
  int v4; // r5
  int result; // r0
  size_t v6; // r4
  char v7; // r7
  mbedtls_mpi_uint *v8; // r2
  int v9; // r1

  v4 = val;
  result = 0;
  v6 = pos >> 5;
  v7 = pos & 0x1F;
  if ( val && val != 1 )
    return -4;
  if ( pos < 32 * X->n )
    goto LABEL_8;
  if ( !val )
    return 0;
  result = mbedtls_mpi_grow(X, v6 + 1);
  if ( !result )
  {
LABEL_8:
    v8 = X->p;
    v9 = v8[v6] & ~(1 << v7);
    v8[v6] = v9;
    X->p[v6] = v9 | (v4 << v7);
  }
  return result;
}

//----- (08006AC4) --------------------------------------------------------
int __fastcall mbedtls_mpi_shift_l(mbedtls_mpi_0 *X, size_t count)
{
  mbedtls_mpi_uint v3; // r5
  size_t v4; // r4
  size_t v5; // r7
  size_t v6; // r0
  int v7; // r1
  int v8; // r2
  size_t i; // r0
  int v10; // r8
  mbedtls_mpi_uint *v11; // r3
  mbedtls_mpi_uint v12; // r1
  mbedtls_mpi_uint v13; // r0
  mbedtls_mpi_uint v14; // r1
  int v15; // r1

  v3 = 0;
  v4 = count >> 5;
  v5 = count & 0x1F;
  v6 = mbedtls_mpi_bitlen(X) + count;
  if ( v6 <= 32 * X->n )
    goto LABEL_5;
  v7 = v6 << 27;
  if ( v6 << 27 )
    v7 = 1;
  v8 = mbedtls_mpi_grow(X, v7 + (v6 >> 5));
  if ( !v8 )
  {
LABEL_5:
    v8 = 0;
    if ( v4 )
    {
      for ( i = X->n; i > v4; --i )
        X->p[i - 1] = X->p[i - v4 - 1];
      for ( ; i; *(mbedtls_mpi_uint *)((char *)X->p + v10) = 0 )
        v10 = 4 * i-- - 4;
    }
    if ( v5 )
    {
      while ( X->n > v4 )
      {
        v11 = X->p;
        v12 = v11[v4];
        v13 = v12 >> (32 - v5);
        v14 = v12 << v5;
        v11[v4] = v14;
        v15 = v14 | v3;
        v3 = v13;
        X->p[v4++] = v15;
      }
    }
  }
  return v8;
}

//----- (08006B64) --------------------------------------------------------
int __fastcall mbedtls_mpi_shift_r(mbedtls_mpi_0 *X, size_t count)
{
  size_t v2; // r2
  size_t v3; // r5
  size_t v4; // r1
  int v5; // r3
  size_t i; // r1
  size_t j; // r4
  mbedtls_mpi_uint *v9; // r7
  int v10; // r6
  unsigned int v11; // r2
  int v12; // r1
  mbedtls_mpi_uint v13; // r2
  int v14; // r2

  v2 = count >> 5;
  v3 = count & 0x1F;
  v4 = X->n;
  v5 = 0;
  if ( v4 < v2 || v4 == v2 && v3 )
    return mbedtls_mpi_lset(X, 0);
  if ( v2 )
  {
    for ( i = 0; X->n - v2 > i; ++i )
      X->p[i] = X->p[i + v2];
    while ( X->n > i )
      X->p[i++] = 0;
  }
  if ( v3 )
  {
    for ( j = X->n; j; *(mbedtls_mpi_uint *)((char *)X->p + v10) = v14 )
    {
      v9 = X->p;
      v10 = 4 * j - 4;
      v11 = *(mbedtls_mpi_uint *)((char *)v9 + v10);
      v12 = v11 << (32 - v3);
      v13 = v11 >> v3;
      *(mbedtls_mpi_uint *)((char *)v9 + v10) = v13;
      v14 = v13 | v5;
      v5 = v12;
      --j;
    }
  }
  return 0;
}

//----- (08006BE6) --------------------------------------------------------
int __fastcall mbedtls_mpi_shrink(mbedtls_mpi_0 *X, size_t nblimbs)
{
  size_t v3; // r4
  size_t i; // r4
  unsigned int v6; // r4
  int *v7; // r0
  mbedtls_mpi_uint *v8; // r7
  int *v9; // r1

  if ( nblimbs > 0x2710 )
    return -16;
  v3 = X->n;
  if ( v3 <= nblimbs )
    return mbedtls_mpi_grow(X, nblimbs);
  for ( i = v3 - 1; i; --i )
  {
    if ( X->p[i] )
      break;
  }
  v6 = i + 1;
  if ( v6 < nblimbs )
    v6 = nblimbs;
  v7 = (int *)calloc(v6, 4u);
  v8 = (mbedtls_mpi_uint *)v7;
  if ( !v7 )
    return -16;
  v9 = (int *)X->p;
  if ( v9 )
  {
    _rt_memcpy_w(v7, v9, 4 * v6);
    mbedtls_mpi_zeroize(X->p, X->n);
    free((int)X->p);
  }
  X->n = v6;
  X->p = v8;
  return 0;
}

//----- (08006C52) --------------------------------------------------------
size_t __fastcall mbedtls_mpi_size(const mbedtls_mpi_0 *X)
{
  return (mbedtls_mpi_bitlen(X) + 7) >> 3;
}

//----- (08006C5E) --------------------------------------------------------
int __fastcall mbedtls_mpi_sub_abs(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  const mbedtls_mpi_0 *v5; // r4
  int i; // r6
  size_t v8; // r0
  mbedtls_mpi_0 TB; // [sp+0h] [bp-20h] BYREF

  TB.s = (int)A;
  TB.n = (size_t)B;
  v5 = B;
  if ( mbedtls_mpi_cmp_abs(A, B) < 0 )
    return -10;
  mbedtls_mpi_init(&TB);
  if ( X != v5 )
    goto LABEL_6;
  i = mbedtls_mpi_copy(&TB, v5);
  if ( !i )
  {
    v5 = &TB;
LABEL_6:
    if ( X == A || (i = mbedtls_mpi_copy(X, A)) == 0 )
    {
      X->s = 1;
      v8 = v5->n;
      for ( i = 0; v8; --v8 )
      {
        if ( v5->p[v8 - 1] )
          break;
      }
      mpi_sub_hlp(v8, v5->p, X->p);
    }
  }
  mbedtls_mpi_free(&TB);
  return i;
}

//----- (08006CCC) --------------------------------------------------------
int __fastcall mbedtls_mpi_sub_int(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, mbedtls_mpi_sint b)
{
  bool v3; // nf
  int v4; // r2
  mbedtls_mpi_0 _B; // [sp+0h] [bp-18h] BYREF
  mbedtls_mpi_uint p[1]; // [sp+Ch] [bp-Ch] BYREF

  _B.s = (int)X;
  _B.n = (size_t)A;
  _B.p = (mbedtls_mpi_uint *)b;
  v3 = b < 0;
  if ( b < 0 )
    b = -b;
  p[0] = b;
  if ( v3 )
    v4 = -1;
  else
    v4 = 1;
  _B.s = v4;
  _B.n = 1;
  _B.p = p;
  return mbedtls_mpi_sub_mpi(X, A, &_B);
}

//----- (08006CFC) --------------------------------------------------------
int __fastcall mbedtls_mpi_sub_mpi(mbedtls_mpi_0 *X, const mbedtls_mpi_0 *A, const mbedtls_mpi_0 *B)
{
  int v4; // r4
  int result; // r0

  v4 = A->s;
  if ( B->s * A->s <= 0 )
  {
    result = mbedtls_mpi_add_abs(X, A, B);
LABEL_4:
    if ( !result )
      X->s = v4;
    return result;
  }
  if ( mbedtls_mpi_cmp_abs(A, B) >= 0 )
  {
    result = mbedtls_mpi_sub_abs(X, A, B);
    goto LABEL_4;
  }
  result = mbedtls_mpi_sub_abs(X, B, A);
  if ( !result )
    X->s = -v4;
  return result;
}

//----- (08006D4C) --------------------------------------------------------
void __fastcall mbedtls_platform_zeroize(void *buf, size_t len)
{
  memset_func(buf, 0, len);
}

//----- (08006D5C) --------------------------------------------------------
int __fastcall mbedtls_sha256_finish_ret(mbedtls_sha256_context_0 *ctx, unsigned __int8 *output)
{
  int v4; // r0
  char *v5; // r2
  unsigned int v6; // r0
  unsigned __int8 *v7; // r6
  int result; // r0
  unsigned __int8 *v9; // r4
  uint32_t v10; // t1
  int v11; // r0
  mbedtls_sha256_context_0 *v12; // r4

  v4 = ctx->total[0] & 0x3F;
  v5 = (char *)ctx + v4;
  v6 = v4 + 1;
  v5[40] = 0x80;
  v7 = ctx->buffer;
  if ( v6 > 0x38 )
  {
    _rt_memclr(&ctx->buffer[v6], 64 - v6);
    result = mbedtls_internal_sha256_process(ctx, ctx->buffer);
    if ( result )
      return result;
    _rt_memclr_w(ctx->buffer, 56);
  }
  else
  {
    _rt_memclr(&ctx->buffer[v6], 56 - v6);
  }
  v10 = ctx->total[0];
  v9 = &ctx->buffer[32];
  v11 = ((unsigned __int64)v10 >> 29) | (8 * *((_DWORD *)v9 - 17));
  v9[24] = HIBYTE(v11);
  v9[25] = BYTE2(v11);
  v9[26] = BYTE1(v11);
  v9[27] = v11;
  v9[28] = (8 * v10) >> 24;
  v9[29] = v10 >> 13;
  v9[30] = (unsigned __int16)v10 >> 5;
  v9[31] = 8 * v10;
  v12 = (mbedtls_sha256_context_0 *)(v9 - 72);
  result = mbedtls_internal_sha256_process(v12, v7);
  if ( !result )
  {
    *output = HIBYTE(v12->state[0]);
    output[1] = BYTE2(v12->state[0]);
    output[2] = HIBYTE(LOWORD(v12->state[0]));
    output[3] = v12->state[0];
    output[4] = HIBYTE(v12->state[1]);
    output[5] = BYTE2(v12->state[1]);
    output[6] = HIBYTE(LOWORD(v12->state[1]));
    output[7] = v12->state[1];
    output[8] = HIBYTE(v12->state[2]);
    output[9] = BYTE2(v12->state[2]);
    output[10] = HIBYTE(LOWORD(v12->state[2]));
    output[11] = v12->state[2];
    output[12] = HIBYTE(v12->state[3]);
    output[13] = BYTE2(v12->state[3]);
    output[14] = HIBYTE(LOWORD(v12->state[3]));
    output[15] = v12->state[3];
    output[16] = HIBYTE(v12->state[4]);
    output[17] = BYTE2(v12->state[4]);
    output[18] = HIBYTE(LOWORD(v12->state[4]));
    output[19] = v12->state[4];
    output[20] = HIBYTE(v12->state[5]);
    output[21] = BYTE2(v12->state[5]);
    output[22] = HIBYTE(LOWORD(v12->state[5]));
    output[23] = v12->state[5];
    output[24] = HIBYTE(v12->state[6]);
    output[25] = BYTE2(v12->state[6]);
    output[26] = HIBYTE(LOWORD(v12->state[6]));
    output[27] = v12->state[6];
    if ( !v12->is224 )
    {
      output[28] = HIBYTE(v12->state[7]);
      output[29] = BYTE2(v12->state[7]);
      output[30] = HIBYTE(LOWORD(v12->state[7]));
      output[31] = v12->state[7];
    }
    result = 0;
  }
  return result;
}
// 8000518: using guessed type int __fastcall _rt_memclr(_DWORD, _DWORD);
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08006EA2) --------------------------------------------------------
void __fastcall mbedtls_sha256_free(mbedtls_sha256_context_0 *ctx)
{
  if ( ctx )
    mbedtls_platform_zeroize(ctx, 0x6Cu);
}

//----- (08006EAE) --------------------------------------------------------
void __fastcall mbedtls_sha256_init(mbedtls_sha256_context_0 *ctx)
{
  _rt_memclr_w(ctx, 108);
}
// 800055C: using guessed type int __fastcall _rt_memclr_w(_DWORD, _DWORD);

//----- (08006EB4) --------------------------------------------------------
int __fastcall mbedtls_sha256_ret(const unsigned __int8 *input, size_t ilen, unsigned __int8 *output, int is224)
{
  int v8; // r4
  mbedtls_sha256_context_0 ctx; // [sp+0h] [bp-80h] BYREF

  mbedtls_sha256_init(&ctx);
  v8 = mbedtls_sha256_starts_ret(&ctx, is224);
  if ( !v8 )
  {
    v8 = mbedtls_sha256_update_ret(&ctx, input, ilen);
    if ( !v8 )
      v8 = mbedtls_sha256_finish_ret(&ctx, output);
  }
  mbedtls_sha256_free(&ctx);
  return v8;
}

//----- (08006EF8) --------------------------------------------------------
int __fastcall mbedtls_sha256_starts_ret(mbedtls_sha256_context_0 *ctx, int is224)
{
  uint32_t v2; // r2

  ctx->total[0] = 0;
  ctx->total[1] = 0;
  if ( is224 )
  {
    ctx->state[0] = -1056596264;
    ctx->state[1] = 914150663;
    ctx->state[2] = 812702999;
    ctx->state[3] = -150054599;
    ctx->state[4] = -4191439;
    ctx->state[5] = 1750603025;
    ctx->state[6] = 1694076839;
    v2 = -1090891868;
  }
  else
  {
    ctx->state[0] = 1779033703;
    ctx->state[1] = -1150833019;
    ctx->state[2] = 1013904242;
    ctx->state[3] = -1521486534;
    ctx->state[4] = 1359893119;
    ctx->state[5] = -1694144372;
    ctx->state[6] = 528734635;
    v2 = 1541459225;
  }
  ctx->state[7] = v2;
  ctx->is224 = is224;
  return 0;
}

//----- (08006F88) --------------------------------------------------------
int __fastcall mbedtls_sha256_update_ret(mbedtls_sha256_context_0 *ctx, const unsigned __int8 *input, size_t ilen)
{
  int v3; // r3
  unsigned int v4; // r4
  unsigned __int8 *v6; // r8
  uint32_t v7; // r6
  size_t v8; // r0
  size_t v9; // r7
  int result; // r0

  v4 = ilen;
  v6 = (unsigned __int8 *)input;
  if ( !ilen )
    return 0;
  v7 = ctx->total[0] & 0x3F;
  v8 = ctx->total[0] + ilen;
  v9 = 64 - v7;
  ctx->total[0] = v8;
  if ( v8 < ilen )
    ++ctx->total[1];
  if ( !v7 || ilen < v9 )
  {
LABEL_10:
    while ( v4 >= 0x40 )
    {
      result = mbedtls_internal_sha256_process(ctx, v6);
      if ( result )
        return result;
      v6 += 64;
      v4 -= 64;
    }
    if ( v4 )
      _rt_memcpy(&ctx->buffer[v7], (char *)v6, v4, v3);
    return 0;
  }
  _rt_memcpy(&ctx->buffer[v7], (char *)input, 64 - v7, v3);
  result = mbedtls_internal_sha256_process(ctx, ctx->buffer);
  if ( !result )
  {
    v4 -= v9;
    v6 += v9;
    v7 = 0;
    goto LABEL_10;
  }
  return result;
}
// 8006FB8: variable 'v3' is possibly undefined

//----- (08006FFC) --------------------------------------------------------
void __fastcall mpi_bigendian_to_host(mbedtls_mpi_uint *const p, size_t limbs)
{
  mbedtls_mpi_uint *v2; // r4
  mbedtls_mpi_uint *i; // r5
  mbedtls_mpi_uint v4; // r6

  if ( limbs )
  {
    v2 = p;
    for ( i = &p[limbs - 1]; v2 <= i; --i )
    {
      v4 = mpi_uint_bigendian_to_host(*v2);
      *v2++ = mpi_uint_bigendian_to_host(*i);
      *i = v4;
    }
  }
}

//----- (08007026) --------------------------------------------------------
int __fastcall mpi_get_digit(mbedtls_mpi_uint *d, int radix, unsigned __int8 c)
{
  int result; // r0

  *d = 255;
  if ( (unsigned int)(c - 48) <= 9 )
    *d = c - 48;
  if ( (unsigned int)(c - 65) <= 5 )
    *d = c - 55;
  if ( (unsigned int)(c - 97) <= 5 )
    *d = c - 87;
  if ( *d < radix )
    result = 0;
  else
    result = -6;
  return result;
}

//----- (0800705C) --------------------------------------------------------
void __fastcall mpi_mul_hlp(size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b)
{
  unsigned int v4; // r4
  mbedtls_mpi_uint *v5; // r1
  mbedtls_mpi_uint v6; // r5
  unsigned __int64 v7; // kr00_8
  int v8; // r6
  _BOOL4 v9; // r4
  int v10; // r5
  mbedtls_mpi_uint v11; // r4
  _BOOL4 v12; // r6
  mbedtls_mpi_uint *v13; // r2
  unsigned int *v14; // r1
  mbedtls_mpi_uint v15; // r4
  int v16; // r6
  bool v17; // cf
  unsigned __int64 v18; // r4
  int v19; // r6
  int v20; // r6
  mbedtls_mpi_uint v21; // r4
  int v22; // r5
  _DWORD *v23; // r2
  unsigned int *v24; // r1
  unsigned int v25; // r4
  int v26; // r6
  unsigned __int64 v27; // r4
  int v28; // r6
  int v29; // r5
  int v30; // r4
  int v31; // r6
  _DWORD *v32; // r2
  unsigned int *v33; // r1
  unsigned int v34; // r4
  int v35; // r6
  unsigned __int64 v36; // kr08_8
  int v37; // r5
  _BOOL4 v38; // r6
  int v39; // r6
  int v40; // r4
  _BOOL4 v41; // r5
  _DWORD *v42; // r2
  unsigned int *v43; // r1
  unsigned int v44; // r4
  int v45; // r6
  unsigned __int64 v46; // r4
  int v47; // r6
  int v48; // r6
  int v49; // r4
  int v50; // r5
  _DWORD *v51; // r2
  unsigned int *v52; // r1
  unsigned int v53; // r4
  int v54; // r6
  unsigned __int64 v55; // r4
  int v56; // r6
  int v57; // r6
  int v58; // r4
  int v59; // r5
  _DWORD *v60; // r2
  unsigned int *v61; // r1
  unsigned int v62; // r4
  int v63; // r6
  unsigned __int64 v64; // r4
  int v65; // r6
  int v66; // r6
  int v67; // r4
  int v68; // r5
  _DWORD *v69; // r2
  unsigned int *v70; // r1
  unsigned int v71; // r4
  int v72; // r6
  unsigned __int64 v73; // r4
  int v74; // r6
  int v75; // r6
  int v76; // r4
  int v77; // r5
  _DWORD *v78; // r2
  unsigned int *v79; // r1
  unsigned int v80; // r4
  int v81; // r6
  unsigned __int64 v82; // kr10_8
  int v83; // r5
  _BOOL4 v84; // r6
  int v85; // r7
  int v86; // r4
  _BOOL4 v87; // r5
  _DWORD *v88; // r2
  unsigned int *v89; // r1
  unsigned int v90; // r4
  unsigned __int64 v91; // kr18_8
  int v92; // r5
  int v93; // r6
  int v94; // r4
  _BOOL4 v95; // r5
  _DWORD *v96; // r2
  unsigned int *v97; // r1
  unsigned int v98; // r4
  int v99; // r6
  unsigned __int64 v100; // r4
  int v101; // r6
  int v102; // r6
  int v103; // r4
  int v104; // r5
  _DWORD *v105; // r2
  unsigned int *v106; // r1
  unsigned int v107; // r4
  int v108; // r6
  unsigned __int64 v109; // r4
  int v110; // r6
  int v111; // r6
  int v112; // r4
  int v113; // r5
  _DWORD *v114; // r2
  unsigned int *v115; // r1
  unsigned int v116; // r4
  int v117; // r6
  unsigned __int64 v118; // kr20_8
  int v119; // r5
  _BOOL4 v120; // r6
  int v121; // r4
  _BOOL4 v122; // r5
  _DWORD *v123; // r2
  unsigned int *v124; // r1
  unsigned int v125; // r4
  int v126; // r6
  unsigned __int64 v127; // r4
  int v128; // r6
  int v129; // r5
  int v130; // r4
  int v131; // r6
  _DWORD *v132; // r2
  unsigned int *v133; // r1
  unsigned int v134; // r4
  int v135; // r6
  unsigned __int64 v136; // kr28_8
  int v137; // r5
  _BOOL4 v138; // r6
  int v139; // r6
  int v140; // r4
  _BOOL4 v141; // r5
  _DWORD *v142; // r2
  unsigned int v143; // r4
  int v144; // r6
  unsigned __int64 v145; // r4
  int v146; // r6
  int v147; // r7
  mbedtls_mpi_uint *v148; // r1
  mbedtls_mpi_uint v149; // r5
  unsigned __int64 v150; // kr30_8
  int v151; // r6
  _BOOL4 v152; // r4
  int v153; // r7
  mbedtls_mpi_uint *v154; // r2
  unsigned int *v155; // r1
  mbedtls_mpi_uint v156; // r4
  unsigned __int64 v157; // r4
  int v158; // r6
  int v159; // r6
  mbedtls_mpi_uint v160; // r4
  int v161; // r5
  _DWORD *v162; // r2
  unsigned int *v163; // r1
  unsigned int v164; // r4
  int v165; // r6
  unsigned __int64 v166; // r4
  int v167; // r6
  int v168; // r6
  int v169; // r4
  int v170; // r5
  _DWORD *v171; // r2
  unsigned int *v172; // r1
  unsigned int v173; // r4
  int v174; // r6
  unsigned __int64 v175; // r4
  int v176; // r6
  int v177; // r6
  int v178; // r4
  int v179; // r5
  _DWORD *v180; // r2
  unsigned int *v181; // r1
  unsigned int v182; // r4
  int v183; // r6
  unsigned __int64 v184; // kr38_8
  int v185; // r5
  _BOOL4 v186; // r6
  int v187; // r7
  int v188; // r4
  _BOOL4 v189; // r5
  _DWORD *v190; // r2
  unsigned int *v191; // r1
  unsigned int v192; // r4
  unsigned __int64 v193; // kr40_8
  int v194; // r5
  int v195; // r6
  int v196; // r7
  int v197; // r4
  _BOOL4 v198; // r5
  _DWORD *v199; // r2
  unsigned int *v200; // r1
  unsigned int v201; // r4
  unsigned __int64 v202; // kr48_8
  int v203; // r5
  int v204; // r6
  int v205; // r4
  _BOOL4 v206; // r5
  _DWORD *v207; // r2
  unsigned int v208; // r4
  int v209; // r6
  unsigned __int64 v210; // r4
  int v211; // r6
  int v212; // r7
  unsigned int v213; // r5
  unsigned __int64 v214; // kr50_8
  int v215; // r6
  _BOOL4 v216; // r4
  int v217; // r7
  _BOOL4 v218; // r4
  mbedtls_mpi_uint v219; // r0

  v4 = 0;
  while ( i >= 0x10 )
  {
    v6 = *s;
    v5 = s + 1;
    v7 = v6 * (unsigned __int64)b;
    v8 = v7 + v4;
    v9 = __CFADD__((_DWORD)v7, v4);
    v10 = HIDWORD(v7) + v9;
    v11 = *d + v8;
    v12 = __CFADD__(*d, v8);
    *d = v11;
    v13 = d + 1;
    v15 = *v5;
    v14 = v5 + 1;
    v16 = v12 + v10;
    v18 = v15 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v18, v16);
    LODWORD(v18) = v18 + v16;
    v19 = v17;
    v20 = v19 + HIDWORD(v18);
    v17 = __CFADD__(*v13, (_DWORD)v18);
    v21 = *v13 + v18;
    v22 = v17;
    *v13 = v21;
    v23 = v13 + 1;
    v25 = *v14;
    v24 = v14 + 1;
    v26 = v20 + v22;
    v27 = v25 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v27, v26);
    LODWORD(v27) = v27 + v26;
    v28 = v17;
    HIDWORD(v27) += v28;
    v17 = __CFADD__(*v23, (_DWORD)v27);
    v30 = *v23 + v27;
    v31 = v17;
    *v23 = v30;
    v32 = v23 + 1;
    v34 = *v24;
    v33 = v24 + 1;
    v35 = v31 + v29;
    v36 = v34 * (unsigned __int64)b;
    v37 = v36 + v35;
    v38 = __CFADD__((_DWORD)v36, v35);
    v39 = v38 + HIDWORD(v36);
    v40 = *v32 + v37;
    v41 = __CFADD__(*v32, v37);
    *v32 = v40;
    v42 = v32 + 1;
    v44 = *v33;
    v43 = v33 + 1;
    v45 = v39 + v41;
    v46 = v44 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v46, v45);
    LODWORD(v46) = v46 + v45;
    v47 = v17;
    v48 = v47 + HIDWORD(v46);
    v17 = __CFADD__(*v42, (_DWORD)v46);
    v49 = *v42 + v46;
    v50 = v17;
    *v42 = v49;
    v51 = v42 + 1;
    v53 = *v43;
    v52 = v43 + 1;
    v54 = v48 + v50;
    v55 = v53 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v55, v54);
    LODWORD(v55) = v55 + v54;
    v56 = v17;
    v57 = v56 + HIDWORD(v55);
    v17 = __CFADD__(*v51, (_DWORD)v55);
    v58 = *v51 + v55;
    v59 = v17;
    *v51 = v58;
    v60 = v51 + 1;
    v62 = *v52;
    v61 = v52 + 1;
    v63 = v57 + v59;
    v64 = v62 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v64, v63);
    LODWORD(v64) = v64 + v63;
    v65 = v17;
    v66 = v65 + HIDWORD(v64);
    v17 = __CFADD__(*v60, (_DWORD)v64);
    v67 = *v60 + v64;
    v68 = v17;
    *v60 = v67;
    v69 = v60 + 1;
    v71 = *v61;
    v70 = v61 + 1;
    v72 = v66 + v68;
    v73 = v71 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v73, v72);
    LODWORD(v73) = v73 + v72;
    v74 = v17;
    v75 = v74 + HIDWORD(v73);
    v17 = __CFADD__(*v69, (_DWORD)v73);
    v76 = *v69 + v73;
    v77 = v17;
    *v69 = v76;
    v78 = v69 + 1;
    v80 = *v70;
    v79 = v70 + 1;
    v81 = v75 + v77;
    v82 = v80 * (unsigned __int64)b;
    v83 = v82 + v81;
    v84 = __CFADD__((_DWORD)v82, v81);
    v85 = v84 + HIDWORD(v82);
    v86 = *v78 + v83;
    v87 = __CFADD__(*v78, v83);
    *v78 = v86;
    v88 = v78 + 1;
    v90 = *v79;
    v89 = v79 + 1;
    v91 = v90 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v91, v87 + v85);
    v92 = v91 + v87 + v85;
    v93 = v17;
    v94 = *v88 + v92;
    v95 = __CFADD__(*v88, v92);
    *v88 = v94;
    v96 = v88 + 1;
    v98 = *v89;
    v97 = v89 + 1;
    v99 = v95 + v93 + HIDWORD(v91);
    v100 = v98 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v100, v99);
    LODWORD(v100) = v100 + v99;
    v101 = v17;
    v102 = v101 + HIDWORD(v100);
    v17 = __CFADD__(*v96, (_DWORD)v100);
    v103 = *v96 + v100;
    v104 = v17;
    *v96 = v103;
    v105 = v96 + 1;
    v107 = *v97;
    v106 = v97 + 1;
    v108 = v102 + v104;
    v109 = v107 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v109, v108);
    LODWORD(v109) = v109 + v108;
    v110 = v17;
    v111 = v110 + HIDWORD(v109);
    v17 = __CFADD__(*v105, (_DWORD)v109);
    v112 = *v105 + v109;
    v113 = v17;
    *v105 = v112;
    v114 = v105 + 1;
    v116 = *v106;
    v115 = v106 + 1;
    v117 = v111 + v113;
    v118 = v116 * (unsigned __int64)b;
    v119 = v118 + v117;
    v120 = __CFADD__((_DWORD)v118, v117);
    v121 = *v114 + v119;
    v122 = __CFADD__(*v114, v119);
    *v114 = v121;
    v123 = v114 + 1;
    v125 = *v115;
    v124 = v115 + 1;
    v126 = v122 + v120 + HIDWORD(v118);
    v127 = v125 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v127, v126);
    LODWORD(v127) = v127 + v126;
    v128 = v17;
    HIDWORD(v127) += v128;
    v17 = __CFADD__(*v123, (_DWORD)v127);
    v130 = *v123 + v127;
    v131 = v17;
    *v123 = v130;
    v132 = v123 + 1;
    v134 = *v124;
    v133 = v124 + 1;
    v135 = v131 + v129;
    v136 = v134 * (unsigned __int64)b;
    v137 = v136 + v135;
    v138 = __CFADD__((_DWORD)v136, v135);
    v139 = v138 + HIDWORD(v136);
    v140 = *v132 + v137;
    v141 = __CFADD__(*v132, v137);
    *v132 = v140;
    v142 = v132 + 1;
    v143 = *v133;
    s = v133 + 1;
    v144 = v139 + v141;
    v145 = v143 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v145, v144);
    LODWORD(v145) = v145 + v144;
    v146 = v17;
    v147 = v146 + HIDWORD(v145);
    HIDWORD(v145) = *v142 + v145;
    LODWORD(v145) = __CFADD__(*v142, (_DWORD)v145);
    *v142 = HIDWORD(v145);
    d = v142 + 1;
    v4 = v145 + v147;
    i -= 16;
  }
  while ( i >= 8 )
  {
    v149 = *s;
    v148 = s + 1;
    v150 = v149 * (unsigned __int64)b;
    v151 = v150 + v4;
    v152 = __CFADD__((_DWORD)v150, v4);
    v153 = v152 + HIDWORD(v150);
    *d += v151;
    v154 = d + 1;
    v156 = *v148;
    v155 = v148 + 1;
    v157 = v156 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v157, HIDWORD(v150) + v153);
    LODWORD(v157) = v157 + HIDWORD(v150) + v153;
    v158 = v17;
    v159 = v158 + HIDWORD(v157);
    v17 = __CFADD__(*v154, (_DWORD)v157);
    v160 = *v154 + v157;
    v161 = v17;
    *v154 = v160;
    v162 = v154 + 1;
    v164 = *v155;
    v163 = v155 + 1;
    v165 = v159 + v161;
    v166 = v164 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v166, v165);
    LODWORD(v166) = v166 + v165;
    v167 = v17;
    v168 = v167 + HIDWORD(v166);
    v17 = __CFADD__(*v162, (_DWORD)v166);
    v169 = *v162 + v166;
    v170 = v17;
    *v162 = v169;
    v171 = v162 + 1;
    v173 = *v163;
    v172 = v163 + 1;
    v174 = v168 + v170;
    v175 = v173 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v175, v174);
    LODWORD(v175) = v175 + v174;
    v176 = v17;
    v177 = v176 + HIDWORD(v175);
    v17 = __CFADD__(*v171, (_DWORD)v175);
    v178 = *v171 + v175;
    v179 = v17;
    *v171 = v178;
    v180 = v171 + 1;
    v182 = *v172;
    v181 = v172 + 1;
    v183 = v177 + v179;
    v184 = v182 * (unsigned __int64)b;
    v185 = v184 + v183;
    v186 = __CFADD__((_DWORD)v184, v183);
    v187 = v186 + HIDWORD(v184);
    v188 = *v180 + v185;
    v189 = __CFADD__(*v180, v185);
    *v180 = v188;
    v190 = v180 + 1;
    v192 = *v181;
    v191 = v181 + 1;
    v193 = v192 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v193, v189 + v187);
    v194 = v193 + v189 + v187;
    v195 = v17;
    v196 = v195 + HIDWORD(v193);
    v197 = *v190 + v194;
    v198 = __CFADD__(*v190, v194);
    *v190 = v197;
    v199 = v190 + 1;
    v201 = *v191;
    v200 = v191 + 1;
    v202 = v201 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v202, v198 + v196);
    v203 = v202 + v198 + v196;
    v204 = v17;
    v205 = *v199 + v203;
    v206 = __CFADD__(*v199, v203);
    *v199 = v205;
    v207 = v199 + 1;
    v208 = *v200;
    s = v200 + 1;
    v209 = v206 + v204 + HIDWORD(v202);
    v210 = v208 * (unsigned __int64)b;
    v17 = __CFADD__((_DWORD)v210, v209);
    LODWORD(v210) = v210 + v209;
    v211 = v17;
    v212 = v211 + HIDWORD(v210);
    HIDWORD(v210) = *v207 + v210;
    LODWORD(v210) = __CFADD__(*v207, (_DWORD)v210);
    *v207 = HIDWORD(v210);
    d = v207 + 1;
    v4 = v210 + v212;
    i -= 8;
  }
  while ( i )
  {
    v213 = *s++;
    v214 = v213 * (unsigned __int64)b;
    v215 = v214 + v4;
    v216 = __CFADD__((_DWORD)v214, v4);
    v217 = v216 + HIDWORD(v214);
    v218 = __CFADD__(*d, v215);
    *d++ += v215;
    v4 = v218 + v217;
    --i;
  }
  while ( 1 )
  {
    v219 = *d + v4;
    *d = v219;
    if ( v219 >= v4 )
      break;
    v4 = 1;
    ++d;
  }
}

//----- (080073DE) --------------------------------------------------------
void __fastcall mpi_sub_hlp(size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d)
{
  mbedtls_mpi_uint v3; // r3
  size_t i; // r4
  _BOOL4 v5; // r6
  mbedtls_mpi_uint v6; // r5
  _BOOL4 v7; // r3
  _BOOL4 v8; // r1

  v3 = 0;
  for ( i = 0; i < n; ++i )
  {
    v5 = *d < v3;
    v6 = *d - v3;
    *d = v6;
    v7 = v6 < *s;
    *d++ = v6 - *s++;
    v3 = v7 + v5;
  }
  while ( v3 )
  {
    v8 = *d < v3;
    *d++ -= v3;
    v3 = v8;
  }
}

//----- (0800742A) --------------------------------------------------------
mbedtls_mpi_uint __fastcall mpi_uint_bigendian_to_host(mbedtls_mpi_uint x)
{
  mbedtls_mpi_uint result; // r0
  unsigned int v3; // r1

  result = 0;
  LOBYTE(v3) = 0;
  do
  {
    result |= (unsigned __int8)x << (8 * (3 - v3));
    v3 = (unsigned __int8)(v3 + 1);
    x >>= 8;
  }
  while ( v3 < 4 );
  return result;
}

//----- (0800744A) --------------------------------------------------------
unsigned int __fastcall reflect(unsigned int data, unsigned __int8 nBits)
{
  unsigned int result; // r0
  unsigned int i; // r2

  result = 0;
  for ( i = 0; i < nBits; i = (unsigned __int8)(i + 1) )
  {
    if ( data << 31 )
      result |= 1 << (nBits - i - 1);
    data >>= 1;
  }
  return result;
}

//----- (08007470) --------------------------------------------------------
bool __fastcall sissdk_ecdsa_load_group(mbedtls_ecdsa_context *ctx)
{
  const uint8_t *group; // [sp+0h] [bp-8h] BYREF

  group = m_grp;
  return mbedtls_ecp_tls_read_group(&ctx->grp, &group, 3u) == 0;
}

//----- (0800748C) --------------------------------------------------------
bool __fastcall sissdk_ecdsa_load_publickey(const uint8_t *pubkey, mbedtls_ecdsa_context *ctx)
{
  _BOOL4 v4; // r0

  v4 = sissdk_ecdsa_load_group(ctx);
  if ( v4 )
  {
    if ( mbedtls_ecp_point_read_binary(&ctx->grp, &ctx->Q, pubkey, 0x31u) )
      LOBYTE(v4) = 0;
    else
      LOBYTE(v4) = 1;
  }
  return v4;
}

//----- (080074B4) --------------------------------------------------------
uint8_t *__fastcall sissdk_ecdsa_sha256(uint8_t *src, uint32_t size)
{
  if ( src )
  {
    if ( mbedtls_sha256_ret(src, size, m_hash, 0) )
    {
      src = 0;
    }
    else
    {
      util_dump_buf("[ok]: Hash = ", m_hash, 0x20u);
      src = m_hash;
    }
  }
  return src;
}

//----- (080074EC) --------------------------------------------------------
bool __fastcall sissdk_ecdsa_verify(const uint8_t *pubKey, const uint8_t *src, uint32_t src_size, const S_ECDSA_SIGN_0 *sig)
{
  uint8_t *v6; // r5
  mbedtls_ecdsa_context ctx_verify; // [sp+4h] [bp-BCh] BYREF

  v6 = sissdk_ecdsa_sha256(src, src_size);
  if ( v6 )
  {
    mbedtls_ecdsa_init(&ctx_verify);
    if ( sissdk_ecdsa_load_publickey(pubKey, &ctx_verify)
      && !mbedtls_ecdsa_read_signature(&ctx_verify, v6, 0x20u, sig->m_sign_data, sig->m_sign_size) )
    {
      mbedtls_ecdsa_free(&ctx_verify);
      return 1;
    }
    mbedtls_ecdsa_free(&ctx_verify);
  }
  return 0;
}

//----- (0800753A) --------------------------------------------------------
void __fastcall sub32(uint32_t *dst, uint32_t src, char *carry)
{
  *carry -= *dst < src;
  *dst -= src;
}

//----- (08007558) --------------------------------------------------------
void __fastcall util_dump_buf(const unsigned __int8 *title, unsigned __int8 *buf, size_t len)
{
  size_t i; // r0

  for ( i = 0; i < len; ++i )
    ;
}

//----- (20017000) --------------------------------------------------------
int advance_software_protect_flash_verify()
{
  int result; // r0
  S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_SKIP_0 *v1; // r5
  uint32_t i; // r1
  uint32_t j; // r0
  S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_SKIP_0 *v4; // r2
  void *v5; // r3
  void *v6; // r6
  uint32_t v7; // r7
  uint32_t k; // r0
  S_ADV_SOFTWARE_PROTECT_FLASH_VERIFY_SKIP_0 *v9; // r5
  uint32_t v10; // r0
  uint32_t l; // r6
  char *v12; // r1
  uint32_t v13; // r0

  result = _Ven_TT_L__advance_software_protect_flash_verify_init();
  if ( result )
  {
    if ( _Ven_TT_L__advance_software_protect_flash_verify_check() )
    {
      result = 1;
    }
    else
    {
      v1 = m_flash_verify_r.m_flash_verify_skip_items;
      if ( m_flash_verify_r.m_flash_verify_skip_count > 1 )
      {
        for ( i = 0; m_flash_verify_r.m_flash_verify_skip_count - 1 > i; ++i )
        {
          for ( j = 0; m_flash_verify_r.m_flash_verify_skip_count - i - 1 > j; ++j )
          {
            v4 = &v1[j];
            v5 = v4->m_skip_addr;
            v6 = v4[1].m_skip_addr;
            if ( v4->m_skip_addr > v6 )
            {
              v7 = v4[1].m_skip_size;
              v4[1].m_skip_size = v4->m_skip_size;
              v4->m_skip_addr = v6;
              v4->m_skip_size = v7;
              v4[1].m_skip_addr = v5;
            }
          }
        }
        for ( k = 0; m_flash_verify_r.m_flash_verify_skip_count - 1 > k; ++k )
        {
          if ( (void *)((unsigned int)m_flash_verify_r.m_flash_verify_skip_items[k].m_skip_addr
                      + m_flash_verify_r.m_flash_verify_skip_items[k].m_skip_size) > m_flash_verify_r.m_flash_verify_skip_items[k + 1].m_skip_addr )
            goto LABEL_21;
        }
      }
      if ( m_flash_verify_r.m_flash_verify_skip_count
        && (m_flash_verify_r.m_flash_verify_skip_items->m_skip_addr < (void *)m_flash_verify_r.m_flash_addr_start
         || (unsigned int)m_flash_verify_r.m_flash_verify_skip_items[m_flash_verify_r.m_flash_verify_skip_count - 1].m_skip_addr
          + m_flash_verify_r.m_flash_verify_skip_items[m_flash_verify_r.m_flash_verify_skip_count - 1].m_skip_size > m_flash_verify_r.m_flash_addr_end) )
      {
LABEL_21:
        result = 0;
      }
      else
      {
        if ( m_flash_verify_r.m_flash_verify_skip_count )
        {
          v9 = m_flash_verify_r.m_flash_verify_skip_items;
          v10 = _Ven_TT_L__crc32(
                  (const void *)m_flash_verify_r.m_flash_addr_start,
                  (int)m_flash_verify_r.m_flash_verify_skip_items->m_skip_addr - m_flash_verify_r.m_flash_addr_start);
          for ( l = 0; ; ++l )
          {
            v12 = (char *)v9->m_skip_addr + v9->m_skip_size;
            if ( m_flash_verify_r.m_flash_verify_skip_count - 1 <= l )
              break;
            v10 = _Ven_TT_L__crc32_continue(v10, v12, v9[1].m_skip_addr - (void *)v12);
            ++v9;
          }
          v13 = _Ven_TT_L__crc32_continue(v10, v12, m_flash_verify_r.m_flash_addr_end - (_DWORD)v12);
        }
        else
        {
          v13 = _Ven_TT_L__crc32(
                  (const void *)m_flash_verify_r.m_flash_addr_start,
                  m_flash_verify_r.m_flash_addr_end - m_flash_verify_r.m_flash_addr_start);
        }
        if ( m_flash_verify_r.m_total_crc32 == v13 )
          result = 3;
        else
          result = 2;
      }
    }
  }
  return result;
}

//----- (2001710C) --------------------------------------------------------
int _Ven_TT_L__advance_software_protect_flash_verify_init()
{
  return advance_software_protect_flash_verify_init();
}

//----- (20017116) --------------------------------------------------------
bool _Ven_TT_L__advance_software_protect_flash_verify_check()
{
  return advance_software_protect_flash_verify_check();
}

//----- (20017120) --------------------------------------------------------
uint32_t __fastcall _Ven_TT_L__crc32(const void *data, int nBytes)
{
  return crc32(data, nBytes);
}

//----- (2001712A) --------------------------------------------------------
uint32_t __fastcall _Ven_TT_L__crc32_continue(uint32_t prev_crc, const void *data, int nBytes)
{
  return crc32_continue(prev_crc, data, nBytes);
}

//----- (20017134) --------------------------------------------------------
int __fastcall _Ven_TT_L__encrypt_g(uint16_t g, uint8_t k, uint8_t *key)
{
  return encrypt_g(g, k, key);
}

//----- (2001713E) --------------------------------------------------------
int __fastcall _Ven_TT_L__encrypt_g_inv(uint16_t g, uint8_t k, uint8_t *key)
{
  return encrypt_g_inv(g, k, key);
}

//----- (20017148) --------------------------------------------------------
uint32_t __fastcall _Ven_TT_L__HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength)
{
  return HAL_CRC_Calculate(hcrc, pBuffer, BufferLength);
}

//----- (20017152) --------------------------------------------------------
uint32_t __fastcall _Ven_TT_L__HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t *pBuffer, uint32_t BufferLength)
{
  return HAL_CRC_Accumulate(hcrc, pBuffer, BufferLength);
}

//----- (2001715C) --------------------------------------------------------
void __fastcall _Ven_TT_L__HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
  HAL_FLASHEx_OBGetConfig(pOBInit);
}

//----- (20017166) --------------------------------------------------------
int _Ven_TT_L__HAL_FLASH_Unlock()
{
  return HAL_FLASH_Unlock();
}

//----- (20017170) --------------------------------------------------------
int _Ven_TT_L__HAL_FLASH_OB_Unlock()
{
  return HAL_FLASH_OB_Unlock();
}

//----- (2001717A) --------------------------------------------------------
int __fastcall _Ven_TT_L__HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
  return HAL_FLASHEx_OBProgram(pOBInit);
}

//----- (20017184) --------------------------------------------------------
int _Ven_TT_L__HAL_FLASH_OB_Lock()
{
  return HAL_FLASH_OB_Lock();
}

//----- (2001718E) --------------------------------------------------------
int _Ven_TT_L__HAL_FLASH_Lock()
{
  return HAL_FLASH_Lock();
}

//----- (20017198) --------------------------------------------------------
bool __fastcall _Ven_TT_L__sissdk_ecdsa_verify(const uint8_t *pubKey, const uint8_t *src, uint32_t src_size, const S_ECDSA_SIGN_0 *sig)
{
  return sissdk_ecdsa_verify(pubKey, src, src_size, sig);
}

//----- (20017200) --------------------------------------------------------
void __fastcall advance_software_protect_anti_debugger(AntiDebuggerCallback eventCallback)
{
  if ( m_anti_debugger_tag_r == (m_anti_debugger_tag_s ^ m_anti_debugger_tag_m) )
  {
    eventCallback(Development);
  }
  else
  {
    if ( !advance_software_protect_rdp_check() )
    {
      eventCallback(RDPDisabled);
      advance_software_protect_rdp_enable();
      eventCallback(RDPEnabled);
      eventCallback(SystemReset);
      advance_software_protect_system_reset();
    }
    eventCallback(RDPEnabled);
    eventCallback(DebuggerDisable);
    advance_software_protect_debugger_disable();
  }
}

//----- (20017300) --------------------------------------------------------
void __fastcall advance_software_protect_encrypt_process(void *data, size_t size, uint64_t key, int isEnc)
{
  int v5; // r9
  unsigned int *v6; // r11
  unsigned int v7; // r4
  unsigned int v8; // r5
  __int16 v9; // r6
  __int16 v10; // r7
  unsigned __int16 v11; // r0
  unsigned __int16 v12; // r5
  unsigned __int16 v13; // r0
  int v14; // r6
  int v15; // r8
  unsigned __int16 v16; // r0
  __int16 v17; // r7
  uint64_t keya[6]; // [sp+8h] [bp-30h] BYREF

  keya[0] = key;
  v5 = 0;
  while ( size >= 8 )
  {
    v6 = (unsigned int *)((char *)data + v5);
    v7 = *(_DWORD *)((char *)data + v5);
    v8 = *(_DWORD *)((char *)data + v5 + 4);
    if ( isEnc )
    {
      v9 = 0;
      do
      {
        v10 = v7;
        v7 = HIWORD(v7) | ((unsigned __int16)v8 << 16);
        v11 = _Ven_TT_L__encrypt_g(HIWORD(v8), v9++, (uint8_t *)keya);
        v12 = v11;
        v13 = v11 ^ v10 ^ v9;
        v9 = (unsigned __int8)v9;
        v8 = v12 | (v13 << 16);
      }
      while ( (unsigned __int8)v9 < 0x20u );
    }
    else
    {
      LOBYTE(v14) = 31;
      do
      {
        v15 = (unsigned __int16)v8 ^ HIWORD(v8);
        v16 = _Ven_TT_L__encrypt_g_inv(v8, v14, (uint8_t *)keya);
        v17 = (unsigned __int8)v14 + 1;
        v14 = (char)(v14 - 1);
        v8 = ((unsigned __int16)v8 | (v16 << 16)) & 0xFFFF0000 | HIWORD(v7);
        v7 = ((unsigned __int16)v7 | ((unsigned __int16)v7 << 16)) & 0xFFFF0000 | (unsigned __int16)(v15 ^ v17);
      }
      while ( v14 >= 0 );
    }
    *v6 = v7;
    v6[1] = v8;
    v5 += 8;
    size -= 8;
  }
}

//----- (20017500) --------------------------------------------------------
crc32_t __fastcall advance_software_protect_crc32(uint8_t *buffer, size_t size, int a3, uint32_t a4)
{
  size_t v5; // r4
  crc32_t result; // r0
  uint32_t val; // [sp+0h] [bp-18h] BYREF

  val = a4;
  v5 = size & 3;
  result = _Ven_TT_L__HAL_CRC_Calculate(&hcrc, (uint32_t *)buffer, size >> 2);
  if ( v5 )
  {
    val = *(_DWORD *)&buffer[size - v5] & ~(-1 << (8 * v5));
    result = _Ven_TT_L__HAL_CRC_Accumulate(&hcrc, &val, 1u);
  }
  return result;
}

//----- (20017600) --------------------------------------------------------
void __fastcall advance_software_protect_get_cid(uint32_t id_addr, uint8_t size, uint8_t *id_data)
{
  int i; // r3
  uint8_t v4; // t1

  for ( i = 0; i < size; ++i )
  {
    v4 = *(_BYTE *)id_addr++;
    id_data[i] = v4;
  }
}

//----- (20017700) --------------------------------------------------------
void __noreturn advance_software_protect_system_reset()
{
  __dsb(0xFu);
  MEMORY[0xE000ED0C] = MEMORY[0xE000ED0C] & 0x700 | 0x5FA0004;
  __dsb(0xFu);
  while ( 1 )
    ;
}

//----- (20017800) --------------------------------------------------------
void advance_software_protect_debugger_disable()
{
  MEMORY[0x40010004] = MEMORY[0x40010004] & 0xF8FFFFFF | 0x4000000;
}

//----- (20017900) --------------------------------------------------------
bool advance_software_protect_rdp_check()
{
  FLASH_OBProgramInitTypeDef m_cur_ob; // [sp+0h] [bp-20h] BYREF

  _Ven_TT_L__HAL_FLASHEx_OBGetConfig(&m_cur_ob);
  return m_cur_ob.RDPLevel != 165;
}

//----- (20017A00) --------------------------------------------------------
void advance_software_protect_rdp_enable()
{
  FLASH_OBProgramInitTypeDef m_cur_ob; // [sp+0h] [bp-20h] BYREF

  _Ven_TT_L__HAL_FLASHEx_OBGetConfig(&m_cur_ob);
  if ( !_Ven_TT_L__HAL_FLASH_Unlock() && !_Ven_TT_L__HAL_FLASH_OB_Unlock() )
  {
    m_cur_ob.RDPLevel = 0;
    _Ven_TT_L__HAL_FLASHEx_OBProgram(&m_cur_ob);
    _Ven_TT_L__HAL_FLASH_OB_Lock();
    _Ven_TT_L__HAL_FLASH_Lock();
  }
}

//----- (20017B00) --------------------------------------------------------
bool advance_software_protect_verify_authorization()
{
  advance_software_protect_get_cid(m_Chip_ID_Addr ^ 0x5BDB656E, m_Chip_ID_Size ^ 0x6E, m_Chip_ID_Data);
  return _Ven_TT_L__sissdk_ecdsa_verify(
           ECDSA_PUBLIC_KEY,
           m_Chip_ID_Data,
           m_Chip_ID_Size ^ 0x5BDB656E,
           (const S_ECDSA_SIGN_0 *)(m_signature_data_addr ^ 0x5BDB656E));
}

// nfuncs=294 queued=253 decompiled=253 lumina nreq=0 worse=0 better=0
// ALL OK, 253 function(s) have been successfully decompiled
